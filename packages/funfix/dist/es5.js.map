{"version":3,"file":"es5.js","sources":["../../funfix-core/src/std.ts","../../funfix-core/src/errors.ts","../../funfix-core/src/disjunctions.ts","../../funfix-exec/src/cancelable.ts","../../funfix-exec/src/time.ts","../../funfix-exec/src/ref.ts","../../funfix-exec/src/internals.ts","../../funfix-exec/src/scheduler.ts","../../funfix-exec/src/future.ts","../../funfix-effect/src/internals.ts","../../funfix-effect/src/eval.ts","../../funfix-effect/src/io.ts","../../funfix-types/src/kinds.ts","../../funfix-types/src/eq.ts","../../funfix-types/src/functor.ts","../../funfix-types/src/applicative.ts","../../funfix-types/src/monad.ts","../../funfix-types/src/comonad.ts","../../funfix-types/src/instances.ts"],"sourcesContent":["/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Interface for testing the equality of value objects.\n */\nexport interface IEquals<A> {\n  /**\n   * Indicates whether some other object is \"equal to\" this one.\n   *\n   * Properties:\n   *\n   *  - reflexive: for any value, `x.equals(x) == true`\n   *  - symmetric: for any values x and y, `x.equals(y) == y.equals(x)`\n   *  - transitive: `x.equals(y) && y.equals(z) => x.equals(z)`\n   *  - consistent: `x.equals(y)` always yields the same result\n   *\n   * Rule: equal objects MUST have equal hash codes!\n   */\n  equals(other: A): boolean\n\n  /**\n   * Returns a hash code value for this value.\n   *\n   * This method is supported for the benefit of hash tables.\n   *\n   * Properties:\n   *\n   *  - consistent: multiple invocations always yield the same result\n   *  - if `x.equals(y) == true` then `x.hashCode() == y.hashCode()`\n   *  - if `x.equals(y) == false` it is NOT required for their hash codes\n   *    to be equal, i.e. this function is not injective\n   */\n  hashCode(): number\n}\n\n/**\n * Test if the given reference is a value object.\n *\n * Value objects are objects that implement the [[IEquals]]\n * interface.\n *\n * @param ref is the reference to test\n */\nexport function isValueObject(ref: any): boolean {\n  return !!(ref &&\n    typeof ref.equals === \"function\" &&\n    typeof ref.hashCode === \"function\")\n}\n\n/**\n * Tests for universal equality.\n *\n * First attempting a reference check with `===`,\n * after which it tries to fallback on [[IEquals]], if the\n * left-hand side is implementing it.\n *\n * ```typescript\n * equals(10, 10) // true, because 10 === 10\n *\n * class Box implements IEquals<Box> {\n *   constructor(value: number) { this.value = value }\n *\n *   equals(other) { return this.value === other.value  }\n *   hashCode() { return this.value << 2 }\n * }\n *\n * // false, because they are not the same reference\n * new Box(10) === new Box(10)\n *\n * // true, because `Box#equals` gets called\n * equals(new Box(10), new Box(10))\n * ```\n */\nexport function is<A>(lh: A, rh: A): boolean {\n  if (lh === rh || (lh !== lh && rh !== rh)) {\n    return true\n  }\n  if (!lh || !rh) {\n    return false\n  }\n  /* istanbul ignore else */\n  /* tslint:disable-next-line:strict-type-predicates */\n  if (typeof lh.valueOf === \"function\" && typeof rh.valueOf === \"function\") {\n    const lh2 = lh.valueOf()\n    const rh2 = rh.valueOf()\n    if (lh2 === rh2 || (lh2 !== lh2 && rh2 !== rh2)) {\n      return true\n    }\n    if (!lh2 || !rh2) {\n      return false\n    }\n  }\n  // noinspection PointlessBooleanExpressionJS\n  return !!(\n    isValueObject(lh) &&\n    (lh as any).equals(rh)\n  )\n}\n\n/** Alias for [[is]]. */\nexport function equals<A>(lh: A, rh: A): boolean {\n  return is(lh, rh)\n}\n\n/**\n * Universal hash-code function.\n *\n * Depending on the given value, it calculates the hash-code like so:\n *\n *  1. if it's a `number`, then it gets truncated\n *     to an integer and returned\n *  2. if it's a \"value object\" (see [[isValueObject]]), then\n *     its `hashCode` is used\n *  3. if a `valueOf()` function is provided, then the\n *     `hashCode` gets recursively invoked on its result\n *  4. if all else fails, the value gets coerced to a `String`\n *     and a hash code is calculated using [[hashCodeOfString]]\n *\n * @param ref is the value to use for calculating a hash code\n * @return an integer with the aforementioned properties\n */\nexport function hashCode(ref: any): number {\n  if (typeof ref === \"number\") {\n    return ref & ref\n  }\n  /* istanbul ignore else */\n  if (typeof ref.valueOf === \"function\") {\n    const v = ref.valueOf()\n    if (v !== ref) return hashCode(v)\n  }\n  if (isValueObject(ref)) {\n    return (ref as IEquals<any>).hashCode()\n  }\n  return hashCodeOfString(String(ref))\n}\n\n/**\n * Calculates a hash code out of any string.\n */\nexport function hashCodeOfString(str: string): number {\n  let hash = 0\n  /* tslint:disable-next-line:strict-type-predicates */\n  if (str == null || str.length === 0) return hash\n  for (let i = 0; i < str.length; i++) {\n    const character = str.charCodeAt(i)\n    hash = ((hash << 5) - hash) + character\n    hash = hash & hash // Convert to 32bit integer\n  }\n  return hash\n}\n\n/** The identity function. */\nexport function id<A>(a: A): A {\n  return a\n}\n\n/**\n * Utility function for implementing mixins, based on the\n * [TypeScript Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * documentation.\n *\n * Sample:\n *\n * ```typescript\n * class Disposable { ... }\n * class Activatable { ... }\n * class SmartObject implements Disposable, Activatable { ... }\n *\n * applyMixins(SmartObject, [Disposable, Activatable]);\n * ```\n *\n * Using `implements` instead of `extends` for base classes\n * will make the type system treat them like interfaces instead of\n * classes. And by `applyMixins` we can also supply global\n * implementations for the non-abstract members.\n */\nexport function applyMixins(derivedCtor: {prototype: any}, baseCtors: {prototype: any}[]) {\n  baseCtors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      if (!derivedCtor.prototype[name])\n        derivedCtor.prototype[name] = baseCtor.prototype[name]\n    })\n  })\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Type alias for errors that can be thrown.\n *\n * Since in JavaScript any object can be thrown, the standard\n * `Error` class (capital `E`) is not useful as a type in signatures,\n * the needed type being effectively `any`, but we still need a type\n * alias for documentation purposes.\n *\n * And since `any` represents an untyped object that bypasses the\n * type system, Funfix is using `Object` for TypeScript and `mixed`\n * for Flow to represent such throwables.\n */\nexport type Throwable = Error | Object\n\n/**\n * A composite error represents a list of errors that were caught\n * while executing logic which delays re-throwing of errors.\n */\nexport class CompositeError extends Error {\n  private errorsRef: Array<Throwable>\n\n  constructor(errors: Array<Throwable>) {\n    let reasons = \"\"\n    for (const e of errors.slice(0, 2)) {\n      let message = \"\"\n      if (e instanceof Error) {\n        message = `${e.name}(${e.message})`\n      } else {\n        message = `${e}`\n      }\n      reasons += \", \" + message\n    }\n\n    reasons = reasons.slice(2)\n    if (errors.length > 2) reasons = reasons + \", ...\"\n    super(reasons)\n\n    this.name = \"CompositeError\"\n    this.errorsRef = errors\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = CompositeError\n    self.__proto__ = CompositeError.prototype\n  }\n\n  /**\n   * Returns the full list of caught errors.\n   */\n  public errors(): Array<Throwable> { return this.errorsRef.slice() }\n}\n\n/**\n * A dummy error that can be used for testing purposes.\n */\nexport class DummyError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"DummyError\"\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = DummyError\n    self.__proto__ = DummyError.prototype\n  }\n}\n\n/**\n * Thrown by various accessor methods or partial functions to indicate\n * that the element being requested does not exist.\n */\nexport class NoSuchElementError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"NoSuchElementError\"\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = NoSuchElementError\n    self.__proto__ = NoSuchElementError.prototype\n  }\n}\n\n/**\n * Error throw in class constructors by implementations that\n * are sealed or final.\n */\nexport class IllegalInheritanceError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"IllegalInheritanceError\"\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = IllegalInheritanceError\n    self.__proto__ = IllegalInheritanceError.prototype\n  }\n}\n\n/**\n * Signals that a function has been invoked at an illegal\n * or inappropriate time.\n *\n * In other words, environment or application is not in an\n * appropriate state for the requested operation.\n */\nexport class IllegalStateError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"IllegalStateError\"\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = IllegalStateError\n    self.__proto__ = IllegalStateError.prototype\n  }\n}\n\n/**\n * Signals that a function has been invoked with illegal\n * arguments.\n */\nexport class IllegalArgumentError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"IllegalArgumentError\"\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = IllegalArgumentError\n    self.__proto__ = IllegalArgumentError.prototype\n  }\n}\n\n/**\n * Signals that a function or a method is missing an implementation,\n * which should be provided in the future.\n */\nexport class NotImplementedError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"NotImplementedError\"\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = NotImplementedError\n    self.__proto__ = NotImplementedError.prototype\n  }\n}\n\n/**\n * Signals that completion of a procedure took longer than anticipated.\n */\nexport class TimeoutError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"TimeoutError\"\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = TimeoutError\n    self.__proto__ = TimeoutError.prototype\n  }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as std from \"./std\"\nimport { Throwable, NoSuchElementError } from \"./errors\"\n\n/**\n * Represents a value of one of two possible types (a disjoint union).\n *\n * A common use of Either is as an alternative to [[Option]] for dealing\n * with possible missing values. In this usage [[Option.none]] is replaced\n * with [[Either.left]] which can contain useful information and\n * [[Option.some]] is replaced with [[Either.right]].\n *\n * Convention dictates that `left` is used for failure and `right` is used\n * for success. Note that this `Either` type is right-biased, meaning that\n * operations such as `map`, `flatMap` and `filter` work on the `right` value\n * and if you want to work on the `left` value, then you need to do a `swap`.\n *\n * For example, you could use `Either<String, Int>` to detect whether an\n * input is a string or an number:\n *\n * ```typescript\n * function tryParseInt(str: string): Either<string, number> {\n *   const i = parseInt(value)\n *   return isNaN(i) ? Left(str) : Right(i)\n * }\n *\n * const result = tryParseInt(\"not an int\")\n * if (result.isRight()) {\n *   console.log(`Increment: ${result.get}`)\n * } else {\n *   console.log(`ERROR: could not parse ${result.swap.get}`)\n * }\n * ```\n *\n * @final\n */\nexport class Either<L, R> implements std.IEquals<Either<L, R>> {\n  private _isRight: boolean\n  private _rightRef: R\n  private _leftRef: L\n\n  private constructor(_leftRef: L, _rightRef: R, _isRight: boolean) {\n    this._isRight = _isRight\n    if (_isRight) this._rightRef = _rightRef\n    else this._leftRef = _leftRef\n  }\n\n  /**\n   * Returns `true` if this is a `left`, `false` otherwise.\n   *\n   * ```typescript\n   * Left(\"hello\").isLeft() // true\n   * Right(10).isLeft() // false\n   * ```\n   */\n  isLeft(): boolean { return !this._isRight }\n\n  /**\n   * Returns `true` if this is a `right`, `false` otherwise.\n   *\n   * ```typescript\n   * Left(\"hello\").isRight() // false\n   * Right(10).isRight() // true\n   * ```\n   */\n  isRight(): boolean { return this._isRight }\n\n  /**\n   * Returns true if this is a Right and its value is equal to `elem`\n   * (as determined by the `equals` protocol), returns `false` otherwise.\n   *\n   * ```typescript\n   * // True\n   * Right(\"something\").contains(\"something\")\n   *\n   * // False because the values are different\n   * Right(\"something\").contains(\"anything\") // false\n   *\n   * // False because the source is a `left`\n   * Left(\"something\").contains(\"something\") // false\n   * ```\n   */\n  contains(elem: R): boolean {\n    return this._isRight && std.is(this._rightRef, elem)\n  }\n\n  /**\n   * Returns `false` if the source is a `left`, or returns the result\n   * of the application of the given predicate to the `right` value.\n   *\n   * ```typescript\n   * // True, because it is a right and predicate holds\n   * Right(20).exists(n => n > 10)\n   *\n   * // False, because the predicate returns false\n   * Right(10).exists(n => n % 2 != 0)\n   *\n   * // False, because it is a left\n   * Left(10).exists(n => n == 10)\n   * ```\n   */\n  exists(p: (r: R) => boolean): boolean {\n    return this._isRight && p(this._rightRef)\n  }\n\n  /**\n   * Filters `right` values with the given predicate, returning\n   * the value generated by `zero` in case the source is a `right`\n   * value and the predicate doesn't hold.\n   *\n   * Possible outcomes:\n   *\n   *  - Returns the existing value of `right` if this is a `right` value and the\n   *    given predicate `p` holds for it\n   *  - Returns `Left(zero())` if this is a `right` value\n   *    and the given predicate `p` does not hold\n   *  - Returns the current \"left\" value, if the source is a `Left`\n   *\n   * ```typescript\n   * Right(12).filterOrElse(x => x > 10, () => -1) // Right(12)\n   * Right(7).filterOrElse(x => x > 10, () => -1)  // Left(-1)\n   * Left(7).filterOrElse(x => false, () => -1)    // Left(7)\n   * ```\n   */\n  filterOrElse(p: (r: R) => boolean, zero: () => L): Either<L, R> {\n    return this._isRight\n      ? (p(this._rightRef) ? (this as any) : Left(zero()))\n      : (this as any)\n  }\n\n  /**\n   * Binds the given function across `right` values.\n   *\n   * This operation is the monadic \"bind\" operation.\n   * It can be used to *chain* multiple `Either` references.\n   */\n  flatMap<S>(f: (r: R) => Either<L, S>): Either<L, S> {\n    return this._isRight ? f(this._rightRef) : (this as any)\n  }\n\n  /**\n   * Applies the `left` function to [[Left]] values, and the\n   * `right` function to [[Right]] values and returns the result.\n   *\n   * ```typescript\n   * const maybeNum: Either<string, number> =\n   *   tryParseInt(\"not a number\")\n   *\n   * const result: string =\n   *   maybeNum.fold(\n   *     str => `Could not parse string: ${str}`,\n   *     num => `Success: ${num}`\n   *   )\n   * ```\n   */\n  fold<S>(left: (l: L) => S, right: (r: R) => S): S {\n    return this._isRight ? right(this._rightRef) : left(this._leftRef)\n  }\n\n  /**\n   * Returns true if the source is a `left` or returns\n   * the result of the application of the given predicate to the\n   * `right` value.\n   *\n   * ```typescript\n   * // True, because it is a `left`\n   * Left(\"hello\").forAll(x => x > 10)\n   *\n   * // True, because the predicate holds\n   * Right(20).forAll(x => x > 10)\n   *\n   * // False, it's a right and the predicate doesn't hold\n   * Right(7).forAll(x => x > 10)\n   * ```\n   */\n  forAll(p: (r: R) => boolean): boolean {\n    return !this._isRight || p(this._rightRef)\n  }\n\n  /**\n   * Returns the `Right` value, if the source has one,\n   * otherwise throws an exception.\n   *\n   * WARNING!\n   *\n   * This function is partial, the `Either` must be a `Right`, otherwise\n   * a runtime exception will get thrown. Use with care.\n   *\n   * @throws [[NoSuchElementError]] in case the the `Either` is a `Left`\n   */\n  get(): R {\n    if (this._isRight) return this._rightRef\n    throw new NoSuchElementError(\"left.get()\")\n  }\n\n  /**\n   * Returns the value from this `right` or the given `fallback`\n   * value if this is a `left`.\n   *\n   * ```typescript\n   * Right(10).getOrElse(27) // 10\n   * Left(10).getOrElse(27)  // 27\n   * ```\n   */\n  getOrElse<RR>(fallback: RR): R | RR {\n    return this._isRight ? this._rightRef : fallback\n  }\n\n  /**\n   * Returns the value from this `right` or a value generated\n   * by the given `thunk` if this is a `left`.\n   *\n   * ```typescript\n   * Right(10).getOrElseL(() => 27) // 10\n   * Left(10).getOrElseL(() => 27)  // 27\n   * ```\n   */\n  getOrElseL<RR>(thunk: () => RR): R | RR {\n    return this._isRight ? this._rightRef : thunk()\n  }\n\n  /**\n   * Transform the source if it is a `right` with the given\n   * mapping function.\n   *\n   * ```typescript\n   * Right(10).map(x => x + 17) // right(27)\n   * Left(10).map(x => x + 17)  // left(10)\n   * ```\n   */\n  map<C>(f: (r: R) => C): Either<L, C> {\n    return this._isRight\n      ? Right(f(this._rightRef))\n      : (this as any)\n  }\n\n  /**\n   * Executes the given side-effecting function if the\n   * source is a `right` value.\n   *\n   * ```typescript\n   * Right(12).forAll(console.log) // prints 12\n   * Left(10).forAll(console.log)  // silent\n   * ```\n   */\n  forEach(cb: (r: R) => void): void {\n    if (this._isRight) cb(this._rightRef)\n  }\n\n  /**\n   * If this is a `left`, then return the left value as a `right`\n   * or vice versa.\n   *\n   * ```typescript\n   * Right(10).swap() // left(10)\n   * Left(20).swap()  // right(20)\n   * ```\n   */\n  swap(): Either<R, L> {\n    return this._isRight\n      ? Left(this._rightRef)\n      : Right(this._leftRef)\n  }\n\n  /**\n   * Returns an `Option.some(right)` if the source is a `right` value,\n   * or `Option.none` in case the source is a `left` value.\n   */\n  toOption(): Option<R> {\n    return this._isRight\n      ? Option.some(this._rightRef)\n      : Option.none()\n  }\n\n  /** Implements {@link IEquals.equals}. */\n  equals(other: Either<L, R>): boolean {\n    // tslint:disable-next-line:strict-type-predicates\n    if (other == null) return false\n    if (this._isRight) return std.is(this._rightRef, other._rightRef)\n    return std.is(this._leftRef, other._leftRef)\n  }\n\n  /** Implements {@link IEquals.hashCode}. */\n  hashCode(): number {\n    return this._isRight\n      ? std.hashCode(this._rightRef) << 2\n      : std.hashCode(this._leftRef) << 3\n  }\n\n  // Implements HK<F, A>\n  /** @hidden */ readonly _funKindF: Either<L, any>\n  /** @hidden */ readonly _funKindA: R\n\n  // Implements Constructor<T>\n  /** @hidden */ static readonly _funErasure: Either<any, any>\n\n  static left<L, R>(value: L): Either<L, R> {\n    return Left(value)\n  }\n\n  static right<L, R>(value: R): Either<L, R> {\n    return Right(value)\n  }\n\n  /**\n   * Maps 2 `Either` values by the mapping function, returning a new\n   * `Either` reference that is a `Right` only if both `Either` values are\n   * `Right` values, otherwise it returns the first `Left` value noticed.\n   *\n   * ```typescript\n   * // Yields Right(3)\n   * Try.map2(Right(1), Right(2),\n   *   (a, b) => a + b\n   * )\n   *\n   * // Yields Left, because the second arg is a Left\n   * Try.map2(Right(1), Left(\"error\"),\n   *   (a, b) => a + b\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map2`.\n   */\n  static map2<A1,A2,L,R>(fa1: Either<L,A1>, fa2: Either<L,A2>,\n                         f: (a1: A1, a2: A2) => R): Either<L, R> {\n\n    if (fa1.isLeft()) return ((fa1 as any) as Either<L, R>)\n    if (fa2.isLeft()) return ((fa2 as any) as Either<L, R>)\n    return Right(f(fa1._rightRef, fa2._rightRef))\n  }\n\n  /**\n   * Maps 3 `Either` values by the mapping function, returning a new\n   * `Either` reference that is a `Right` only if all 3 `Either` values are\n   * `Right` values, otherwise it returns the first `Left` value noticed.\n   *\n   * ```typescript\n   * // Yields Right(6)\n   * Try.map3(Right(1), Right(2), Right(3),\n   *   (a, b, c) => a + b + c\n   * )\n   *\n   * // Yields Left, because the second arg is a Left\n   * Try.map3(Right(1), Left(\"error\"), Right(3),\n   *   (a, b, c) => a + b + c\n   * )\n   * ```\n   */\n  static map3<A1,A2,A3,L,R>(\n    fa1: Either<L,A1>, fa2: Either<L,A2>, fa3: Either<L,A3>,\n    f: (a1: A1, a2: A2, a3: A3) => R): Either<L, R> {\n\n    if (fa1.isLeft()) return ((fa1 as any) as Either<L, R>)\n    if (fa2.isLeft()) return ((fa2 as any) as Either<L, R>)\n    if (fa3.isLeft()) return ((fa3 as any) as Either<L, R>)\n    return Right(f(fa1._rightRef, fa2._rightRef, fa3._rightRef))\n  }\n\n  /**\n   * Maps 4 `Either` values by the mapping function, returning a new\n   * `Either` reference that is a `Right` only if all 4 `Either` values are\n   * `Right` values, otherwise it returns the first `Left` value noticed.\n   *\n   * ```typescript\n   * // Yields Right(10)\n   * Try.map4(Right(1), Right(2), Right(3), Right(4),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   *\n   * // Yields Left, because the second arg is a Left\n   * Try.map4(Right(1), Left(\"error\"), Right(3), Right(4),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   * ```\n   */\n  static map4<A1,A2,A3,A4,L,R>(\n    fa1: Either<L,A1>, fa2: Either<L,A2>, fa3: Either<L,A3>, fa4: Either<L,A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R): Either<L, R> {\n\n    if (fa1.isLeft()) return ((fa1 as any) as Either<L, R>)\n    if (fa2.isLeft()) return ((fa2 as any) as Either<L, R>)\n    if (fa3.isLeft()) return ((fa3 as any) as Either<L, R>)\n    if (fa4.isLeft()) return ((fa4 as any) as Either<L, R>)\n    return Right(f(fa1._rightRef, fa2._rightRef, fa3._rightRef, fa4._rightRef))\n  }\n\n  /**\n   * Maps 5 `Either` values by the mapping function, returning a new\n   * `Either` reference that is a `Right` only if all 5 `Either` values are\n   * `Right` values, otherwise it returns the first `Left` value noticed.\n   *\n   * ```typescript\n   * // Yields Right(15)\n   * Try.map5(Right(1), Right(2), Right(3), Right(4), Right(5),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   *\n   * // Yields Left, because the second arg is a Left\n   * Try.map5(Right(1), Left(\"error\"), Right(3), Right(4), Right(5),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   * ```\n   */\n  static map5<A1,A2,A3,A4,A5,L,R>(\n    fa1: Either<L,A1>, fa2: Either<L,A2>, fa3: Either<L,A3>, fa4: Either<L,A4>, fa5: Either<L,A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R): Either<L, R> {\n\n    if (fa1.isLeft()) return ((fa1 as any) as Either<L, R>)\n    if (fa2.isLeft()) return ((fa2 as any) as Either<L, R>)\n    if (fa3.isLeft()) return ((fa3 as any) as Either<L, R>)\n    if (fa4.isLeft()) return ((fa4 as any) as Either<L, R>)\n    if (fa5.isLeft()) return ((fa5 as any) as Either<L, R>)\n    return Right(f(fa1._rightRef, fa2._rightRef, fa3._rightRef, fa4._rightRef, fa5._rightRef))\n  }\n\n  /**\n   * Maps 6 `Either` values by the mapping function, returning a new\n   * `Either` reference that is a `Right` only if all 6 `Either` values are\n   * `Right` values, otherwise it returns the first `Left` value noticed.\n   *\n   * ```typescript\n   * // Yields Right(21)\n   * Try.map5(Right(1), Right(2), Right(3), Right(4), Right(5), Right(6),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   *\n   * // Yields Left, because the second arg is a Left\n   * Try.map5(Right(1), Left(\"error\"), Right(3), Right(4), Right(5), Right(6),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   * ```\n   */\n  static map6<A1,A2,A3,A4,A5,A6,L,R>(\n    fa1: Either<L,A1>, fa2: Either<L,A2>, fa3: Either<L,A3>, fa4: Either<L,A4>, fa5: Either<L,A5>, fa6: Either<L,A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R): Either<L, R> {\n\n    if (fa1.isLeft()) return ((fa1 as any) as Either<L, R>)\n    if (fa2.isLeft()) return ((fa2 as any) as Either<L, R>)\n    if (fa3.isLeft()) return ((fa3 as any) as Either<L, R>)\n    if (fa4.isLeft()) return ((fa4 as any) as Either<L, R>)\n    if (fa5.isLeft()) return ((fa5 as any) as Either<L, R>)\n    if (fa6.isLeft()) return ((fa6 as any) as Either<L, R>)\n    return Right(f(fa1._rightRef, fa2._rightRef, fa3._rightRef, fa4._rightRef, fa5._rightRef, fa6._rightRef))\n  }\n\n  /**\n   * Keeps calling `f` until a `Right(b)` is returned.\n   *\n   * Based on Phil Freeman's\n   * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.\n   *\n   * Described in `FlatMap.tailRecM`.\n   */\n  static tailRecM<L, A, B>(a: A, f: (a: A) => Either<L, Either<A, B>>): Either<L, B> {\n    let cursor = a\n    while (true) {\n      const result = f(cursor)\n      if (result.isLeft()) return result as any\n\n      const some = result.get()\n      if (some.isRight()) return Right(some.get())\n      cursor = some.swap().get()\n    }\n  }\n}\n\n/**\n * The `Left` data constructor represents the left side of the\n * [[Either]] disjoint union, as opposed to the [[Right]] side.\n */\nexport function Left<L>(value: L): Either<L, never> {\n  return new (Either as any)(value, null as never, false)\n}\n\n/**\n * The `Right` data constructor represents the right side of the\n * [[Either]] disjoint union, as opposed to the [[Left]] side.\n */\nexport function Right<R>(value: R): Either<never, R> {\n  return new (Either as any)(null as never, value, true)\n}\n\n/**\n * Represents optional values, inspired by Scala's `Option` and by\n * Haskell's `Maybe` data types.\n *\n * Option is an immutable data type, represented as a sum type, being\n * either a [[Some]], in case it contains a single element, or a [[None]],\n * in case it is empty.\n *\n * The most idiomatic way to use an `Option` instance is to treat it\n * as a collection or monad and use `map`,`flatMap`, `filter`,\n * or `forEach`.\n *\n * @final\n */\nexport class Option<A> implements std.IEquals<Option<A>> {\n  // tslint:disable-next-line:variable-name\n  private _isEmpty: boolean\n  private _ref: A\n\n  private constructor(ref: A, isEmpty?: boolean) {\n    /* tslint:disable-next-line:strict-type-predicates */\n    this._isEmpty = isEmpty != null ? isEmpty : (ref === null || ref === undefined)\n    this._ref = ref\n  }\n\n  /**\n   * Returns the option's value.\n   *\n   * WARNING!\n   *\n   * This function is partial, the option must be non-empty, otherwise\n   * a runtime exception will get thrown. Use with care.\n   *\n   * @throws [[NoSuchElementError]] in case the option is empty\n   */\n  get(): A {\n    if (!this._isEmpty) return this._ref\n    else throw new NoSuchElementError(\"Option.get\")\n  }\n\n  /**\n   * Returns the option's value if the option is nonempty, otherwise\n   * return the given `fallback`.\n   *\n   * See [[Option.getOrElseL]] for a lazy alternative.\n   */\n  getOrElse<AA>(fallback: AA): A | AA {\n    if (!this._isEmpty) return this._ref\n    else return fallback\n  }\n\n  /**\n   * Returns the option's value if the option is nonempty, otherwise\n   * return `null`.\n   * ```\n   */\n  orNull(): A | null {\n    return !this._isEmpty ? this._ref : null\n  }\n\n  /**\n   * Returns the option's value if the option is nonempty, otherwise\n   * return `undefined`.\n   */\n  orUndefined(): A | undefined {\n    return !this._isEmpty ? this._ref : undefined\n  }\n\n  /**\n   * Returns the option's value if the option is nonempty, otherwise\n   * return the result of evaluating `thunk`.\n   *\n   * See [[Option.getOrElse]] for a strict alternative.\n   */\n  getOrElseL<AA>(thunk: () => AA): A | AA {\n    if (!this._isEmpty) return this._ref\n    else return thunk()\n  }\n\n  /**\n   * Returns this option if it is nonempty, otherwise returns the\n   * given `fallback`.\n   */\n  orElse<AA>(fallback: Option<AA>): Option<A | AA> {\n    if (!this._isEmpty) return this\n    else return fallback\n  }\n\n  /**\n   * Returns this option if it is nonempty, otherwise returns the\n   * given result of evaluating the given `thunk`.\n   *\n   * @param thunk a no-params function that gets evaluated and\n   *        whose result is returned in case this option is empty\n   */\n  orElseL<AA>(thunk: () => Option<AA>): Option<A | AA> {\n    if (!this._isEmpty) return this\n    else return thunk()\n  }\n\n  /**\n   * Returns `true` if the option is empty, `false` otherwise.\n   */\n  isEmpty(): boolean { return this._isEmpty }\n\n  /**\n   * Returns `true` if the option is not empty, `false` otherwise.\n   */\n  nonEmpty(): boolean { return !this._isEmpty }\n\n  /**\n   * Returns an option containing the result of applying `f` to\n   * this option's value, or an empty option if the source is empty.\n   *\n   * NOTE: this is similar with `flatMap`, except with `map` the\n   * result of `f` doesn't need to be wrapped in an `Option`.\n   *\n   * @param f the mapping function that will transform the value\n   *          of this option if nonempty.\n   *\n   * @return a new option instance containing the value of the\n   *         source mapped by the given function\n   */\n  map<B>(f: (a: A) => B): Option<B> {\n    return this._isEmpty ? None : Some(f(this._ref))\n  }\n\n  /**\n   * Returns an optioning containing the result of the source mapped\n   * by the given function `f`.\n   *\n   * Similar to `map`, except that if the mapping function `f` returns\n   * `null`, then the final result returned will be [[Option.none]].\n   *\n   * Comparison:\n   *\n   * ```typescript\n   * Option.of(1).mapN(x => null) // None\n   * Option.of(1).map(x => null)  // Some(null)\n   *\n   * Option.of(1).mapN(x => x+1)  // 2\n   * Option.of(1).map(x => x+1)   // 2\n   * ```\n   *\n   * What this operation does is to allow for safe chaining of multiple\n   * method calls or functions that might produce `null` results:\n   *\n   * ```typescript\n   * Option.of(user)\n   *   .mapN(_ => _.contacts)\n   *   .mapN(_ => _.length)\n   * ```\n   */\n  mapN<B>(f: (a: A) => B | null | undefined): Option<B> {\n    return this._isEmpty ? None : Option.of(f(this._ref))\n  }\n\n  /**\n   * Returns the result of applying `f` to this option's value if\n   * the option is nonempty, otherwise returns an empty option.\n   *\n   * NOTE: this is similar with `map`, except that `flatMap` the\n   * result returned by `f` is expected to be boxed in an `Option`\n   * already.\n   *\n   * Example:\n   *\n   * ```typescript\n   * const opt = Option.of(10)\n   *\n   * opt.flatMap(num => {\n   *   if (num % 2 == 0)\n   *     Some(num + 1)\n   *   else\n   *     None\n   * })\n   * ```\n   *\n   * @param f the mapping function that will transform the value\n   *          of this option if nonempty.\n   *\n   * @return a new option instance containing the value of the\n   *         source mapped by the given function\n   */\n  flatMap<B>(f: (a: A) => Option<B>): Option<B> {\n    if (this._isEmpty) return None\n    else return f(this._ref)\n  }\n\n  /** Alias for [[flatMap]]. */\n  chain<B>(f: (a: A) => Option<B>): Option<B> {\n    return this.flatMap(f)\n  }\n\n  /**\n   * Returns this option if it is nonempty AND applying the\n   * predicate `p` to the underlying value yields `true`,\n   * otherwise return an empty option.\n   *\n   * @param p is the predicate function that is used to\n   *        apply filtering on the option's value\n   *\n   * @return a new option instance containing the value of the\n   *         source filtered with the given predicate\n   */\n  filter(p: (a: A) => boolean): Option<A> {\n    if (this._isEmpty || !p(this._ref)) return None\n    else return this\n  }\n\n  /**\n   * Returns the result of applying `f` to this option's value,\n   * or in case the option is empty, the return the result of\n   * evaluating the `fallback` function.\n   *\n   * This function is equivalent with:\n   *\n   * ```typescript\n   * opt.map(f).getOrElseL(fallback)\n   * ```\n   *\n   * @param fallback is the function to be evaluated in case this\n   *        option is empty\n   *\n   * @param f is the mapping function for transforming this option's\n   *        value in case it is nonempty\n   */\n  fold<B>(fallback: () => B, f: (a: A) => B): B {\n    if (this._isEmpty) return fallback()\n    else return f(this._ref)\n  }\n\n  /**\n   * Returns true if this option is nonempty and the value it\n   * holds is equal to the given `elem`.\n   */\n  contains(elem: A): boolean {\n    return !this._isEmpty && std.is(this._ref, elem)\n  }\n\n  /**\n   * Returns `true` if this option is nonempty and the given\n   * predicate returns `true` when applied on this option's value.\n   *\n   * @param p is the predicate function to test\n   */\n  exists(p: (a: A) => boolean): boolean {\n    return !this._isEmpty && p(this._ref)\n  }\n\n  /**\n   * Returns true if this option is empty or the given predicate\n   * returns `true` when applied on this option's value.\n   *\n   * @param p is the predicate function to test\n   */\n  forAll(p: (a: A) => boolean): boolean {\n    return this._isEmpty || p(this._ref)\n  }\n\n  /**\n   * Apply the given procedure `cb` to the option's value if\n   * this option is nonempty, otherwise do nothing.\n   *\n   * @param cb the procedure to apply\n   */\n  forEach(cb: (a: A) => void): void {\n    if (!this._isEmpty) cb(this._ref)\n  }\n\n  // Implemented from IEquals\n  equals(that: Option<A>): boolean {\n    // tslint:disable-next-line:strict-type-predicates\n    if (that == null) return false\n    if (this.nonEmpty() && that.nonEmpty()) {\n      const l = this.get()\n      const r = that.get()\n      return std.is(l, r)\n    }\n    return this.isEmpty() && that.isEmpty()\n  }\n\n  // Implemented from IEquals\n  hashCode(): number {\n    if (this._isEmpty) return 2433880\n    else if (this._ref == null) return 2433881 << 2\n    else return std.hashCode(this._ref) << 2\n  }\n\n  // Implements HK<F, A>\n  /** @hidden */ readonly _funKindF: Option<any>\n  /** @hidden */ readonly _funKindA: A\n\n  // Implements Constructor<T>\n  /** @hidden */ static readonly _funErasure: Option<any>\n\n  /**\n   * Builds an [[Option]] reference that contains the given value.\n   *\n   * If the given value is `null` or `undefined` then the returned\n   * option will be empty.\n   */\n  static of<A>(value: A | null | undefined): Option<A> {\n    return value != null ? Some(value) : None\n  }\n\n  /**\n   * Builds an [[Option]] reference that contains the given reference.\n   *\n   * Note that `value` is allowed to be `null` or `undefined`, the\n   * returned option will still be non-empty. Use [[Option.of]]\n   * if you want to avoid this problem. This means:\n   *\n   * ```typescript\n   * const opt = Some<number | null>(null)\n   *\n   * opt.isEmpty()\n   * //=> false\n   *\n   * opt.get()\n   * //=> null\n   * ```\n   */\n  static some<A>(value: A): Option<A> {\n    return new Option(value, false)\n  }\n\n  /**\n   * Returns an empty [[Option]].\n   *\n   * NOTE: Because `Option` is immutable, this function returns the\n   * same cached reference is on different calls.\n   */\n  static none(): Option<never> {\n    return None\n  }\n\n  /**\n   * Returns an empty [[Option]].\n   *\n   * Similar to [[Option.none]], but this one allows specifying a\n   * type parameter (in the context of TypeScript or Flow or other\n   * type system).\n   *\n   * NOTE: Because `Option` is immutable, this function returns the\n   * same cached reference is on different calls.\n   */\n  static empty<A>(): Option<A> {\n    return None\n  }\n\n  /**\n   * Alias for [[Some]].\n   */\n  static pure<A>(value: A): Option<A> { return Some(value) }\n\n  /**\n   * Maps 2 optional values by the mapping function, returning a new\n   * optional reference that is `Some` only if both option values are\n   * `Some`, otherwise it returns a `None`.\n   *\n   * ```typescript\n   * // Yields Some(3)\n   * Option.map2(Some(1), Some(2),\n   *   (a, b) => a + b\n   * )\n   *\n   * // Yields None, because the second arg is None\n   * Option.map2(Some(1), None,\n   *   (a, b) => a + b\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map2`.\n   */\n  static map2<A1,A2,R>(fa1: Option<A1>, fa2: Option<A2>,\n                       f: (a1: A1, a2: A2) => R): Option<R> {\n\n    return fa1.nonEmpty() && fa2.nonEmpty()\n      ? Some(f(fa1.get(), fa2.get()))\n      : None\n  }\n\n  /**\n   * Maps 3 optional values by the mapping function, returning a new\n   * optional reference that is `Some` only if all 3 option values are\n   * `Some`, otherwise it returns a `None`.\n   *\n   * ```typescript\n   * // Yields Some(6)\n   * Option.map3(Some(1), Some(2), Some(3),\n   *   (a, b, c) => a + b + c\n   * )\n   *\n   * // Yields None, because the second arg is None\n   * Option.map3(Some(1), None, Some(3),\n   *   (a, b, c) => a + b + c\n   * )\n   * ```\n   */\n  static map3<A1,A2,A3,R>(fa1: Option<A1>, fa2: Option<A2>, fa3: Option<A3>,\n                          f: (a1: A1, a2: A2, a3: A3) => R): Option<R> {\n\n    return fa1.nonEmpty() && fa2.nonEmpty() && fa3.nonEmpty()\n      ? Some(f(fa1.get(), fa2.get(), fa3.get()))\n      : None\n  }\n\n  /**\n   * Maps 4 optional values by the mapping function, returning a new\n   * optional reference that is `Some` only if all 4 option values are\n   * `Some`, otherwise it returns a `None`.\n   *\n   * ```typescript\n   * // Yields Some(10)\n   * Option.map4(Some(1), Some(2), Some(3), Some(4),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   *\n   * // Yields None, because the second arg is None\n   * Option.map4(Some(1), None, Some(3), Some(4),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   * ```\n   */\n  static map4<A1,A2,A3,A4,R>(\n    fa1: Option<A1>, fa2: Option<A2>, fa3: Option<A3>, fa4: Option<A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R): Option<R> {\n\n    return fa1.nonEmpty() && fa2.nonEmpty() && fa3.nonEmpty() && fa4.nonEmpty()\n      ? Some(f(fa1.get(), fa2.get(), fa3.get(), fa4.get()))\n      : None\n  }\n\n  /**\n   * Maps 5 optional values by the mapping function, returning a new\n   * optional reference that is `Some` only if all 5 option values are\n   * `Some`, otherwise it returns a `None`.\n   *\n   * ```typescript\n   * // Yields Some(15)\n   * Option.map5(Some(1), Some(2), Some(3), Some(4), Some(5),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   *\n   * // Yields None, because the second arg is None\n   * Option.map5(Some(1), None, Some(3), Some(4), Some(5),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   * ```\n   */\n  static map5<A1,A2,A3,A4,A5,R>(\n    fa1: Option<A1>, fa2: Option<A2>, fa3: Option<A3>, fa4: Option<A4>, fa5: Option<A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R): Option<R> {\n\n    return fa1.nonEmpty() && fa2.nonEmpty() && fa3.nonEmpty() && fa4.nonEmpty() && fa5.nonEmpty()\n      ? Some(f(fa1.get(), fa2.get(), fa3.get(), fa4.get(), fa5.get()))\n      : None\n  }\n\n  /**\n   * Maps 6 optional values by the mapping function, returning a new\n   * optional reference that is `Some` only if all 6 option values are\n   * `Some`, otherwise it returns a `None`.\n   *\n   * ```typescript\n   * // Yields Some(21)\n   * Option.map6(Some(1), Some(2), Some(3), Some(4), Some(5), Some(6),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   *\n   * // Yields None, because the second arg is None\n   * Option.map6(Some(1), None, Some(3), Some(4), Some(5), Some(6),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   * ```\n   */\n  static map6<A1,A2,A3,A4,A5,A6,R>(\n    fa1: Option<A1>, fa2: Option<A2>, fa3: Option<A3>, fa4: Option<A4>, fa5: Option<A5>, fa6: Option<A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R): Option<R> {\n\n    return fa1.nonEmpty() && fa2.nonEmpty() && fa3.nonEmpty() && fa4.nonEmpty() && fa5.nonEmpty() && fa6.nonEmpty()\n      ? Some(f(fa1.get(), fa2.get(), fa3.get(), fa4.get(), fa5.get(), fa6.get()))\n      : None\n  }\n\n  /**\n   * Keeps calling `f` until a `Right(b)` is returned.\n   *\n   * Based on Phil Freeman's\n   * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.\n   *\n   * Described in `FlatMap.tailRecM`.\n   */\n  static tailRecM<A, B>(a: A, f: (a: A) => Option<Either<A, B>>): Option<B> {\n    let cursor = a\n    while (true) {\n      const result = f(cursor)\n      if (result.isEmpty()) return None\n\n      const some = result.get()\n      if (some.isRight()) return Some(some.get())\n      cursor = some.swap().get()\n    }\n  }\n}\n\n/**\n * The `Some<A>` data constructor for [[Option]] represents existing\n * values of type `A`.\n *\n * Using this function is equivalent with [[Option.some]].\n */\nexport function Some<A>(value: A): Option<A> {\n  return new (Option as any)(value, false)\n}\n\n/** @Hidden */\nfunction emptyOptionRef() {\n  // Ugly workaround to get around the limitation of\n  // Option's private constructor\n  const F: any = Option\n  return new F(null, true) as Option<never>\n}\n\n/**\n * The `None` data constructor for [[Option]] represents non-existing\n * values for any type.\n *\n * Using this reference directly is equivalent with [[Option.none]].\n */\nexport const None: Option<never> = emptyOptionRef()\n\n/**\n * The `Try` type represents a computation that may either result in an\n * exception, or return a successfully computed value. It's similar to,\n * but semantically different from the [[Either]] type.\n *\n * `Try` is a sum type and so instances of `Try` are either instances\n * of [[Success]] or of [[Failure]].\n *\n * For example, `Try` can be used to perform division on a user-defined\n * input, without the need to do explicit exception-handling in all of\n * the places that an exception might occur.\n *\n * Example:\n *\n * ```typescript\n * function divide(dividendS: string, divisorS: string): string {\n *   const dividend = Try(() => parseInt(dividendS))\n *     .filter(_ => _ === _) // filter out NaN\n *   const divisor = Try(() => parseInt(divisorS))\n *     .filter(_ => _ === _)  // filter out NaN\n *\n *   // map2 executes the given function only if both results are\n *   // successful; we could also express this with flatMap / chain\n *   const result = Try.map2(dividend, divisor,\n *     (a, b) => a / b\n *   )\n *\n *   result.fold(\n *     error => `failure: ${error}`\n *     result => `result: ${result}`\n *   )\n * }\n * ```\n *\n * An important property of `Try` is its ability to pipeline, or chain,\n * operations, catching exceptions along the way. The `flatMap` and `map`\n * combinators each essentially pass off either their successfully completed\n * value, wrapped in the [[Success]] type for it to be further operated upon\n * by the next combinator in the chain, or the exception wrapped in the\n * [[Failure]] type usually to be simply passed on down the chain.\n * Combinators such as `recover` and `recoverWith` are designed to provide\n * some type of global behavior in the case of failure.\n *\n * NOTE: all `Try` combinators will catch exceptions and return failure\n * unless otherwise specified in the documentation.\n */\nexport class Try<A> implements std.IEquals<Try<A>> {\n  private _isSuccess: boolean\n  private _successRef: A\n  private _failureRef: Throwable\n\n  private constructor(_success: A, _failure: Throwable, _isSuccess: boolean) {\n    this._isSuccess = _isSuccess\n    if (_isSuccess) this._successRef = _success\n    else this._failureRef = _failure\n  }\n\n  /**\n   * Returns `true` if the source is a [[Success]] result,\n   * or `false` in case it is a [[Failure]].\n   */\n  isSuccess(): boolean { return this._isSuccess }\n\n  /**\n   * Returns `true` if the source is a [[Failure]],\n   * or `false` in case it is a [[Success]] result.\n   */\n  isFailure(): boolean { return !this._isSuccess }\n\n  /**\n   * Returns a Try's successful value if it's a [[Success]] reference,\n   * otherwise throws an exception if it's a [[Failure]].\n   *\n   * WARNING!\n   *\n   * This function is partial, the option must be non-empty, otherwise\n   * a runtime exception will get thrown. Use with care.\n   */\n  get(): A {\n    if (!this._isSuccess) throw this._failureRef\n    return this._successRef\n  }\n\n  /**\n   * Returns the value from a `Success` or the given `fallback`\n   * value if this is a `Failure`.\n   *\n   * ```typescript\n   * Success(10).getOrElse(27) // 10\n   * Failure(\"error\").getOrElse(27)  // 27\n   * ```\n   */\n  getOrElse<AA>(fallback: AA): A | AA {\n    return this._isSuccess ? this._successRef : fallback\n  }\n\n  /**\n   * Returns the value from a `Success` or the value generated\n   * by a given `thunk` in case this is a `Failure`.\n   *\n   * ```typescript\n   * Success(10).getOrElseL(() => 27) // 10\n   * Failure(\"error\").getOrElseL(() => 27)  // 27\n   * ```\n   */\n  getOrElseL<AA>(thunk: () => AA): A | AA {\n    return this._isSuccess ? this._successRef : thunk()\n  }\n\n  /**\n   * Returns the current value if it's a [[Success]], or\n   * if the source is a [[Failure]] then return `null`.\n   *\n   * ```typescript\n   * Success(10).orNull()      // 10\n   * Failure(\"error\").orNull() // null\n   * ```\n   *\n   * This can be useful for use-cases such as:\n   *\n   * ```typescript\n   * Try.of(() => dict.user.profile.name).orNull()\n   * ```\n   */\n  orNull(): A | null {\n    return this._isSuccess ? this._successRef : null\n  }\n\n  /**\n   * Returns the current value if it's a [[Success]], or\n   * if the source is a [[Failure]] then return `undefined`.\n   *\n   * ```typescript\n   * Success(10).orUndefined()      // 10\n   * Failure(\"error\").orUndefined() // undefined\n   * ```\n   *\n   * This can be useful for use-cases such as:\n   *\n   * ```typescript\n   * Try.of(() => dict.user.profile.name).orUndefined()\n   * ```\n   */\n  orUndefined(): A | undefined {\n    return this._isSuccess ? this._successRef : undefined\n  }\n\n  /**\n   * Returns the current value if it's a [[Success]], or if\n   * the source is a [[Failure]] then return the `fallback`.\n   *\n   * ```typescript\n   * Success(10).orElse(Success(17))      // 10\n   * Failure(\"error\").orElse(Success(17)) // 17\n   * ```\n   */\n  orElse<AA>(fallback: Try<AA>): Try<A | AA> {\n    if (this._isSuccess) return this\n    return fallback\n  }\n\n  /**\n   * Returns the current value if it's a [[Success]], or if the source\n   * is a [[Failure]] then return the value generated by the given\n   * `thunk`.\n   *\n   * ```typescript\n   * Success(10).orElseL(() => Success(17))      // 10\n   * Failure(\"error\").orElseL(() => Success(17)) // 17\n   * ```\n   */\n  orElseL<AA>(thunk: () => Try<AA>): Try<A | AA> {\n    if (this._isSuccess) return this\n    return thunk()\n  }\n\n  /**\n   * Inverts this `Try`. If this is a [[Failure]], returns its exception wrapped\n   * in a [[Success]]. If this is a `Success`, returns a `Failure` containing a\n   * [[NoSuchElementError]].\n   */\n  failed(): Try<Throwable> {\n    return this._isSuccess\n      ? Failure(new NoSuchElementError(\"try.failed()\"))\n      : Success(this._failureRef)\n  }\n\n  /**\n   * Applies the `failure` function to [[Failure]] values, and the\n   * `success` function to [[Success]] values and returns the result.\n   *\n   * ```typescript\n   * const maybeNum: Try<number> =\n   *   tryParseInt(\"not a number\")\n   *\n   * const result: string =\n   *   maybeNum.fold(\n   *     error => `Could not parse string: ${error}`,\n   *     num => `Success: ${num}`\n   *   )\n   * ```\n   */\n  fold<R>(failure: (error: Throwable) => R, success: (a: A) => R): R {\n    return this._isSuccess\n      ? success(this._successRef)\n      : failure(this._failureRef)\n  }\n\n  /**\n   * Returns a [[Failure]] if the source is a [[Success]], but the\n   * given `p` predicate is not satisfied.\n   *\n   * @throws NoSuchElementError in case the predicate doesn't hold\n   */\n  filter(p: (a: A) => boolean): Try<A> {\n    if (!this._isSuccess) return this\n    try {\n      if (p(this._successRef)) return this\n      return Failure(\n        new NoSuchElementError(\n          `Predicate does not hold for ${this._successRef}`\n        ))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Returns the given function applied to the value if this is\n   * a [[Success]] or returns `this` if this is a [[Failure]].\n   *\n   * This operation is the monadic \"bind\" operation.\n   * It can be used to *chain* multiple `Try` references.\n   *\n   * ```typescript\n   * Try.of(() => parse(s1)).flatMap(num1 =>\n   *   Try.of(() => parse(s2)).map(num2 =>\n   *     num1 / num2\n   *   ))\n   * ```\n   */\n  flatMap<B>(f: (a: A) => Try<B>): Try<B> {\n    if (!this._isSuccess) return this as any\n    try {\n      return f(this._successRef)\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /** Alias for [[flatMap]]. */\n  chain<B>(f: (a: A) => Try<B>): Try<B> {\n    return this.flatMap(f)\n  }\n\n  /**\n   * Returns a `Try` containing the result of applying `f` to\n   * this option's value, but only if it's a `Success`, or\n   * returns the current `Failure` without any modifications.\n   *\n   * NOTE: this is similar with `flatMap`, except with `map` the\n   * result of `f` doesn't need to be wrapped in a `Try`.\n   *\n   * @param f the mapping function that will transform the value\n   *          of this `Try` if successful.\n   *\n   * @return a new `Try` instance containing the value of the\n   *         source mapped by the given function\n   */\n  map<B>(f: (a: A) => B): Try<B> {\n    return this._isSuccess\n      ? Try.of(() => f(this._successRef))\n      : ((this as any) as Try<B>)\n  }\n\n  /**\n   * Applies the given function `cb` if this is a [[Success]], otherwise\n   * returns `void` if this is a [[Failure]].\n   */\n  forEach(cb: (a: A) => void): void {\n    if (this._isSuccess) cb(this._successRef)\n  }\n\n  /**\n   * Applies the given function `f` if this is a `Failure`, otherwise\n   * returns `this` if this is a `Success`.\n   *\n   * This is like `map` for the exception.\n   *\n   * In the following example, if the `user.profile.email` exists,\n   * then it is returned as a successful value, otherwise\n   *\n   * ```typescript\n   * Try.of(() => user.profile.email).recover(e => {\n   *   // Access error? Default to empty.\n   *   if (e instanceof TypeError) return \"\"\n   *   throw e // We don't know what it is, rethrow\n   * })\n   *\n   * Note that on rethrow, the error is being caught in `recover` and\n   * it still returns it as a `Failure(e)`.\n   * ```\n   */\n  recover<AA>(f: (error: Throwable) => AA): Try<A | AA> {\n    return this._isSuccess ? this : Try.of(() => f(this._failureRef))\n  }\n\n  /**\n   * Applies the given function `f` if this is a `Failure`, otherwise\n   * returns `this` if this is a `Success`.\n   *\n   * This is like `map` for the exception.\n   *\n   * In the following example, if the `user.profile.email` exists,\n   * then it is returned as a successful value, otherwise\n   *\n   * ```typescript\n   * Try.of(() => user.profile.email).recover(e => {\n   *   // Access error? Default to empty.\n   *   if (e instanceof TypeError) return \"\"\n   *   throw e // We don't know what it is, rethrow\n   * })\n   *\n   * Note that on rethrow, the error is being caught in `recover` and\n   * it still returns it as a `Failure(e)`.\n   * ```\n   */\n  recoverWith<AA>(f: (error: Throwable) => Try<AA>): Try<A | AA> {\n    try {\n      return this._isSuccess ? this : f(this._failureRef)\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Transforms the source into an [[Option]].\n   *\n   * In case the source is a `Success(v)`, then it gets translated\n   * into a `Some(v)`. If the source is a `Failure(e)`, then a `None`\n   * value is returned.\n   *\n   * ```typescript\n   * Success(\"value\").toOption() // Some(\"value\")\n   * Failure(\"error\").toOption() // None\n   * ```\n   */\n  toOption(): Option<A> {\n    return this._isSuccess ? Some(this._successRef) : None\n  }\n\n  /**\n   * Transforms the source into an [[Either]].\n   *\n   * In case the source is a `Success(v)`, then it gets translated\n   * into a `Right(v)`. If the source is a `Failure(e)`, then a `Left(e)`\n   * value is returned.\n   *\n   * ```typescript\n   * Success(\"value\").toEither() // Right(\"value\")\n   * Failure(\"error\").toEither() // Left(\"error\")\n   * ```\n   */\n  toEither(): Either<Throwable, A> {\n    return this._isSuccess\n      ? Right(this._successRef)\n      : Left(this._failureRef)\n  }\n\n  // Implemented from IEquals\n  equals(that: Try<A>): boolean {\n    // tslint:disable-next-line:strict-type-predicates\n    if (that == null) return false\n    return this._isSuccess\n      ? that._isSuccess && std.is(this._successRef, that._successRef)\n      : !that._isSuccess && std.is(this._failureRef, that._failureRef)\n  }\n\n  // Implemented from IEquals\n  hashCode(): number {\n    return this._isSuccess\n      ? std.hashCode(this._successRef)\n      : std.hashCode(this._failureRef)\n  }\n\n  // Implements HK<F, A>\n  /** @hidden */ readonly _funKindF: Try<any>\n  /** @hidden */ readonly _funKindA: A\n\n  // Implements Constructor<T>\n  /** @hidden */ static readonly _funErasure: Try<any>\n\n  /**\n   * Evaluates the given `thunk` and returns either a [[Success]],\n   * in case the evaluation succeeded, or a [[Failure]], in case\n   * an exception was thrown.\n   *\n   * Example:\n   *\n   * ```typescript\n   * let effect = 0\n   *\n   * const e = Try.of(() => { effect += 1; return effect })\n   * e.get() // 1\n   * ```\n   */\n  static of<A>(thunk: () => A): Try<A> {\n    try {\n      return Success(thunk())\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /** Alias of [[Try.success]]. */\n  static pure<A>(value: A): Try<A> {\n    return Try.success(value)\n  }\n\n  /**\n   * Shorthand for `now(undefined as void)`, always returning\n   * the same reference as optimization.\n   */\n  static unit(): Try<void> {\n    return tryUnitRef\n  }\n\n  /**\n   * Returns a [[Try]] reference that represents a successful result\n   * (i.e. wrapped in [[Success]]).\n   */\n  static success<A>(value: A): Try<A> {\n    return Success(value)\n  }\n\n  /**\n   * Returns a [[Try]] reference that represents a failure\n   * (i.e. an exception wrapped in [[Failure]]).\n   */\n  static failure<A = never>(e: Throwable): Try<A> {\n    return Failure(e)\n  }\n\n  /**\n   * Alias for {@link Try.failure} and {@link Failure},\n   * wrapping any throwable into a `Try` value.\n   */\n  static raise<A = never>(e: Throwable): Try<A> {\n    return Failure(e)\n  }\n\n  /**\n   * Maps 2 `Try` values by the mapping function, returning a new\n   * `Try` reference that is a `Success` only if both `Try` values are\n   * a `Success`, otherwise it returns the first `Failure` noticed.\n   *\n   * ```typescript\n   * // Yields Success(3)\n   * Try.map2(Success(1), Success(2),\n   *   (a, b) => a + b\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Try.map2(Success(1), Failure(\"error\"),\n   *   (a, b) => a + b\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map2`.\n   */\n  static map2<A1,A2,R>(\n    fa1: Try<A1>, fa2: Try<A2>,\n    f: (a1: A1, a2: A2) => R): Try<R> {\n\n    if (fa1.isFailure()) return ((fa1 as any) as Try<R>)\n    if (fa2.isFailure()) return ((fa2 as any) as Try<R>)\n    try {\n      return Success(f(fa1._successRef, fa2._successRef))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Maps 3 `Try` values by the mapping function, returning a new\n   * `Try` reference that is a `Success` only if all 3 `Try` values are\n   * a `Success`, otherwise it returns the first `Failure` noticed.\n   *\n   * ```typescript\n   * // Yields Success(6)\n   * Try.map3(Success(1), Success(2), Success(3),\n   *   (a, b, c) => {\n   *     return a + b + c\n   *   }\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Try.map3(\n   *   Success(1),\n   *   Failure(\"error\"),\n   *   Success(3),\n   *\n   *   (a, b, c) => {\n   *     return a + b + c\n   *   }\n   * )\n   * ```\n   */\n  static map3<A1,A2,A3,R>(\n    fa1: Try<A1>, fa2: Try<A2>, fa3: Try<A3>,\n    f: (a1: A1, a2: A2, a3: A3) => R): Try<R> {\n\n    if (fa1.isFailure()) return ((fa1 as any) as Try<R>)\n    if (fa2.isFailure()) return ((fa2 as any) as Try<R>)\n    if (fa3.isFailure()) return ((fa3 as any) as Try<R>)\n    try {\n      return Success(f(\n        fa1._successRef,\n        fa2._successRef,\n        fa3._successRef))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Maps 4 `Try` values by the mapping function, returning a new\n   * `Try` reference that is a `Success` only if all 4 `Try` values are\n   * a `Success`, otherwise it returns the first `Failure` noticed.\n   *\n   * ```typescript\n   * // Yields Success(10)\n   * Try.map4(Success(1), Success(2), Success(3), Success(4),\n   *   (a, b, c, d) => {\n   *     return a + b + c + d\n   *   }\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Try.map3(\n   *   Success(1),\n   *   Failure(\"error\"),\n   *   Success(3),\n   *   Success(4),\n   *\n   *   (a, b, c, d) => {\n   *     return a + b + c + d\n   *   }\n   * )\n   * ```\n   */\n  static map4<A1,A2,A3,A4,R>(\n    fa1: Try<A1>, fa2: Try<A2>, fa3: Try<A3>, fa4: Try<A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R): Try<R> {\n\n    if (fa1.isFailure()) return ((fa1 as any) as Try<R>)\n    if (fa2.isFailure()) return ((fa2 as any) as Try<R>)\n    if (fa3.isFailure()) return ((fa3 as any) as Try<R>)\n    if (fa4.isFailure()) return ((fa4 as any) as Try<R>)\n    try {\n      return Success(f(\n        fa1._successRef,\n        fa2._successRef,\n        fa3._successRef,\n        fa4._successRef))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Maps 5 `Try` values by the mapping function, returning a new\n   * `Try` reference that is a `Success` only if all 5 `Try` values are\n   * a `Success`, otherwise it returns the first `Failure` noticed.\n   *\n   * ```typescript\n   * // Yields Success(15)\n   * Try.map5(\n   *   Success(1),\n   *   Success(2),\n   *   Success(3),\n   *   Success(4),\n   *   Success(5),\n   *\n   *   (a, b, c, d, e) => {\n   *     return a + b + c + d + e\n   *   }\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Try.map5(\n   *   Success(1),\n   *   Failure(\"error\"),\n   *   Success(3),\n   *   Success(4),\n   *   Success(5),\n   *\n   *   (a, b, c, d, e) => {\n   *     return a + b + c + d + e\n   *   }\n   * )\n   * ```\n   */\n  static map5<A1,A2,A3,A4,A5,R>(\n    fa1: Try<A1>, fa2: Try<A2>, fa3: Try<A3>, fa4: Try<A4>, fa5: Try<A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R): Try<R> {\n\n    if (fa1.isFailure()) return ((fa1 as any) as Try<R>)\n    if (fa2.isFailure()) return ((fa2 as any) as Try<R>)\n    if (fa3.isFailure()) return ((fa3 as any) as Try<R>)\n    if (fa4.isFailure()) return ((fa4 as any) as Try<R>)\n    if (fa5.isFailure()) return ((fa5 as any) as Try<R>)\n    try {\n      return Success(f(\n        fa1._successRef,\n        fa2._successRef,\n        fa3._successRef,\n        fa4._successRef,\n        fa5._successRef))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Maps 6 `Try` values by the mapping function, returning a new\n   * `Try` reference that is a `Success` only if all 6 `Try` values are\n   * a `Success`, otherwise it returns the first `Failure` noticed.\n   *\n   * ```typescript\n   * // Yields Success(21)\n   * Try.map6(\n   *   Success(1),\n   *   Success(2),\n   *   Success(3),\n   *   Success(4),\n   *   Success(5),\n   *   Success(6),\n   *\n   *   (a, b, c, d, e, f) => {\n   *     return a + b + c + d + e + f\n   *   }\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Try.map6(\n   *   Success(1),\n   *   Failure(\"error\"),\n   *   Success(3),\n   *   Success(4),\n   *   Success(5),\n   *   Success(6),\n   *\n   *   (a, b, c, d, e, f) => {\n   *     return a + b + c + d + e + f\n   *   }\n   * )\n   * ```\n   */\n  static map6<A1,A2,A3,A4,A5,A6,R>(\n    fa1: Try<A1>, fa2: Try<A2>, fa3: Try<A3>, fa4: Try<A4>, fa5: Try<A5>, fa6: Try<A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R): Try<R> {\n\n    if (fa1.isFailure()) return ((fa1 as any) as Try<R>)\n    if (fa2.isFailure()) return ((fa2 as any) as Try<R>)\n    if (fa3.isFailure()) return ((fa3 as any) as Try<R>)\n    if (fa4.isFailure()) return ((fa4 as any) as Try<R>)\n    if (fa5.isFailure()) return ((fa5 as any) as Try<R>)\n    if (fa6.isFailure()) return ((fa6 as any) as Try<R>)\n    try {\n      return Success(f(\n        fa1._successRef,\n        fa2._successRef,\n        fa3._successRef,\n        fa4._successRef,\n        fa5._successRef,\n        fa6._successRef))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Keeps calling `f` until a `Right(b)` is returned.\n   *\n   * Based on Phil Freeman's\n   * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.\n   *\n   * Described in `FlatMap.tailRecM`.\n   */\n  static tailRecM<A, B>(a: A, f: (a: A) => Try<Either<A, B>>): Try<B> {\n    let cursor = a\n    while (true) {\n      try {\n        const result = f(cursor) as Try<Either<A, B>>\n        if (result.isFailure()) return result as any\n\n        const some = result.get()\n        if (some.isRight()) return Success(some.get())\n        cursor = some.swap().get()\n      } catch (e) {\n        return Failure(e)\n      }\n    }\n  }\n}\n\n/**\n * The `Success` data constructor is for building [[Try]] values that\n * are successful results of computations, as opposed to [[Failure]].\n */\nexport function Success<A>(value: A): Try<A> {\n  return new (Try as any)(value, null, true)\n}\n\n/**\n * The `Failure` data constructor is for building [[Try]] values that\n * represent failures, as opposed to [[Success]].\n */\nexport function Failure(e: Throwable): Try<never> {\n  return new (Try as any)(null as never, e, false)\n}\n\n/**\n * Reusable reference, to use in {@link Try.unit}.\n *\n * @private\n */\nconst tryUnitRef: Try<void> = Success(undefined)\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  CompositeError,\n  IllegalStateError,\n  IllegalArgumentError\n} from \"funfix-core\"\n\n/**\n * `ICancelable` represents a one-time idempotent action that can be\n * used to cancel async computations, or to release resources that\n * active data sources are holding.\n *\n * It is similar in spirit to `java.io.Closeable`, but without the I/O\n * focus, or to `IDisposable` in Microsoft .NET.\n *\n * ```typescript\n * // Scheduling execution with a 10 seconds delay\n * const ref = setTimeout(() => console.log(\"Hello1\"), 10000)\n * const task = Cancelable.of(() => clearTimeout(ref))\n *\n * // If we change our mind\n * task.cancel()\n * ```\n *\n * In case some API requires the return of an `ICancelable` reference,\n * but there isn't anything that can be canceled, then\n * {@link Cancelable.empty} can be used to return a reusable reference\n * that doesn't do anything when canceled.\n *\n * ```typescript\n * const task = Cancelable.empty()\n *\n * // It's a no-op, doesn't do anything\n * task.cancel()\n * ```\n *\n * Implementation sample:\n *\n * ```typescript\n * class MyCancelable implements ICancelable {\n *   // Idempotency guard\n *   private _isCanceled: boolean = false\n *\n *   cancel() {\n *     // We need an idempotency guarantee, any side-effects\n *     // need to happen only once\n *     if (!this._isCanceled) {\n *       this._isCanceled = true\n *       console.log(\"Was canceled!\")\n *     }\n *   }\n * }\n * ```\n */\nexport interface ICancelable {\n  cancel(): void\n}\n\n/**\n * `Cancelable` is an {@link ICancelable} class providing useful\n * builders for simple cancelable references.\n */\nexport abstract class Cancelable implements ICancelable {\n  abstract cancel(): void\n\n  /**\n   * Lifts any callback into a `Cancelable` reference.\n   *\n   * ```typescript\n   * const task = Cancelable.of(() => {\n   *   console.log(\"I was canceled!\")\n   * })\n   *\n   * task.cancel()\n   * //=> I was canceled!\n   * ```\n   *\n   * The returned reference has guaranteed idempotence, so\n   * calling it multiple times will trigger the given\n   * callback only once.\n   */\n  static of(cb: () => void): Cancelable {\n    return new WrapFn(cb)\n  }\n\n  /**\n   * Returns a reusable `Cancelable` reference that doesn't\n   * do anything on `cancel`.\n   */\n  static empty(): Cancelable {\n    return Empty\n  }\n\n  /**\n   * Returns a [[Cancelable]] implementation that represents an\n   * immutable list of [[Cancelable]] references which can be canceled\n   * as a group.\n   *\n   * ```typescript\n   * const list = Cancelable.collection(\n   *   Cancelable.of(() => console.log(\"Cancelled #1\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #2\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #3\"))\n   * )\n   *\n   * list.cancel()\n   * //=> Cancelled #1\n   * //=> Cancelled #2\n   * //=> Cancelled #3\n   * ```\n   *\n   * @param refs is the array of references to cancel when\n   *        cancellation is triggered\n   */\n  static collection(...refs: Array<ICancelable>): Cancelable {\n    return new CollectionCancelable(refs)\n  }\n\n  /**\n   * Utility that cancels a list of cancelable references, delaying\n   * any thrown exceptions until all references have been cancelled.\n   *\n   * In case multiple exceptions are caught, then the thrown exception\n   * is going to be a `CompositeError`.\n   */\n  static cancelAll(refs: Cancelable[]): void {\n    let errors: any[] | null = null\n    for (const c of refs) {\n      try {\n        c.cancel()\n      } catch (e) {\n        if (!errors) errors = [e]\n        else errors.push(e)\n      }\n    }\n\n    if (!errors)\n      return\n    else if (errors.length === 1)\n      throw errors[0]\n    else\n      throw new CompositeError(errors)\n  }\n}\n\n/**\n * Concrete [[Cancelable]] implementation that wraps a callback.\n *\n * Implementation is package private, use {@link Cancelable.of}\n * to instantiate it.\n *\n * @Private\n * @Hidden\n */\nclass WrapFn extends Cancelable {\n  protected thunk: null | (() => void)\n\n  constructor(cb: () => void) {\n    super()\n    this.thunk = cb\n  }\n\n  cancel() {\n    if (this.thunk !== null) {\n      const ref = this.thunk\n      this.thunk = null\n      ref()\n    }\n  }\n}\n\n/**\n * A `DummyCancelable` is for {@link ICancelable} references that\n * don't do anything on `cancel()` and thus can be ignored.\n *\n * The common supertype of {@link Cancelable.empty} and\n * {@link BoolCancelable.alreadyCanceled}.\n */\nexport class DummyCancelable implements ICancelable {\n  protected readonly _funIsDummy = true\n\n  cancel(): void {\n  }\n}\n\n/**\n * Reusable [[Cancelable]] reference that doesn't do anything on\n * cancel.\n *\n * Implementation is package private, to access it use\n * [[Cancelable.empty]].\n *\n * @Hidden\n */\nconst Empty: ICancelable =\n  new DummyCancelable()\n\n/**\n * `IBoolCancelable` represents a {@link ICancelable} that can be queried\n * for the canceled status.\n */\nexport interface IBoolCancelable extends ICancelable {\n  /**\n   * Return `true` in case this cancelable hasn't been canceled,\n   * or `false` otherwise.\n   *\n   * ```typescript\n   * const ref = BoolCancelable.of()\n   *\n   * ref.isCanceled() // false\n   * ref.cancel()\n   * ref.isCanceled() // true\n   * ```\n   */\n  isCanceled(): boolean\n}\n\n/**\n * `BoolCancelable` is an {@link IBoolCancelable} class providing useful\n * builders for cancelable references that can be queried for their\n * canceled status.\n */\nexport abstract class BoolCancelable implements IBoolCancelable {\n  /** Inherited from {@link IBoolCancelable.isCanceled}. */\n  abstract isCanceled(): boolean\n\n  /** Inherited from {@link ICancelable.cancel}. */\n  abstract cancel(): void\n\n  /**\n   * Lifts any callback into a `BoolCancelable` reference.\n   *\n   * ```typescript\n   * const task = BoolCancelable.of(() => {\n   *   console.log(\"I was canceled!\")\n   * })\n   *\n   * task.isCanceled()\n   * //=> false\n   *\n   * task.cancel()\n   * //=> I was canceled!\n   *\n   * task.isCanceled()\n   * //=> true\n   * ```\n   *\n   * The returned reference has guaranteed idempotence, so\n   * calling it multiple times will trigger the given\n   * callback only once.\n   */\n  public static of(cb: () => void): BoolCancelable {\n    return new BoolWrapFn(cb)\n  }\n\n  /**\n   * Returns a [[BoolCancelable]] implementation that doesn't do\n   * anything on `cancel` except for changing the status of `isCanceled`\n   * from `false` to `true`.\n   *\n   * ```typescript\n   * const task = BoolCancelable.empty()\n   *\n   * task.isCanceled()\n   * //=> false\n   *\n   * task.cancel()\n   * task.isCanceled()\n   * //=> true\n   * ```\n   */\n  public static empty(): BoolCancelable {\n    return new BoolEmpty()\n  }\n\n  /**\n   * Returns a [[BoolCancelable]] reference that is already canceled.\n   *\n   * ```typescript\n   * const ref = BoolCancelable.alreadyCanceled()\n   *\n   * ref.isCanceled()\n   * //=> true\n   *\n   * // Doesn't do anything, it's a no-op\n   * ref.cancel()\n   * ```\n   *\n   * The implementation returns the same reusable reference.\n   */\n  public static alreadyCanceled(): BoolCancelable {\n    return AlreadyCanceledRef\n  }\n\n  /**\n   * Returns a [[BoolCancelable]] implementation that represents an\n   * immutable list of [[Cancelable]] references which can be\n   * canceled as a group.\n   *\n   * ```typescript\n   * const list = BoolCancelable.collection(\n   *   Cancelable.of(() => console.log(\"Cancelled #1\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #2\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #3\"))\n   * )\n   *\n   * list.cancel()\n   * //=> Cancelled #1\n   * //=> Cancelled #2\n   * //=> Cancelled #3\n   * ```\n   *\n   * @param refs is the array of references to cancel when\n   *        cancellation is triggered\n   */\n  public static collection(...refs: Array<ICancelable>): BoolCancelable {\n    return new CollectionCancelable(refs)\n  }\n}\n\n/**\n * [[Cancelable]] implementation that represents an immutable list of\n * [[Cancelable]] references which can be canceled as a group.\n *\n * Implementation is package private, to access it use\n * [[Cancelable.collection]].\n *\n * @Hidden\n */\nclass CollectionCancelable extends BoolCancelable {\n  private _refs?: ICancelable[]\n\n  constructor(refs: ICancelable[]) {\n    super()\n    this._refs = refs\n  }\n\n  public isCanceled(): boolean {\n    return !this._refs\n  }\n\n  public cancel(): void {\n    if (this._refs)\n      try {\n        Cancelable.cancelAll(this._refs)\n      } finally {\n        delete this._refs\n      }\n  }\n}\n\n/**\n * Concrete [[BoolCancelable]] implementation that wraps a callback.\n *\n * Implementation is package private, use [[BoolCancelable.of]]\n * to instantiate it.\n *\n * @Hidden\n */\nclass BoolWrapFn extends WrapFn implements BoolCancelable {\n  isCanceled() {\n    return this.thunk === null\n  }\n}\n\n/**\n * Concrete [[BoolCancelable]] implementation that doesn't do\n * anything on `cancel` except for changing the status of `isCanceled`\n * from `false` to `true`.\n *\n * Implementation is package private, use [[BoolCancelable.empty]]\n * to instantiate it.\n *\n * @Hidden\n */\nclass BoolEmpty extends BoolCancelable {\n  private canceled: boolean = false\n\n  isCanceled(): boolean {\n    return this.canceled\n  }\n\n  public cancel(): void {\n    this.canceled = true\n  }\n}\n\n/**\n * Implementation for {@link BoolCancelable.alreadyCanceled}.\n *\n * @Hidden\n */\nclass AlreadyCanceledBoolCancelable\n  extends DummyCancelable implements IBoolCancelable {\n\n  isCanceled() {\n    return true\n  }\n}\n\n/**\n * Reusable [[BoolCancelable]] reference that's already canceled.\n *\n * Implementation is package private, to access it use\n * [[BoolCancelable.alreadyCanceled]].\n *\n * @Hidden\n */\nconst AlreadyCanceledRef: BoolCancelable =\n  new AlreadyCanceledBoolCancelable()\n\n/**\n * Represents a type of [[ICancelable]] that can hold\n * an internal reference to another cancelable (and thus\n * has to support the `update` operation).\n *\n * On assignment, if this cancelable is already\n * canceled, then no assignment should happen and the update\n * reference should be canceled as well.\n */\nexport interface IAssignCancelable extends IBoolCancelable {\n  /**\n   * Updates the internal reference of this assignable cancelable\n   * to the given value.\n   *\n   * If this cancelable is already canceled, then `value` is\n   * going to be canceled on assignment as well.\n   */\n  update(value: ICancelable): this\n}\n\n/**\n * `AssignCancelable` is an {@link IAssignCancelable} class providing\n * useful builders for cancelable references that can be assigned.\n */\nexport abstract class AssignCancelable implements IAssignCancelable {\n  /** Inherited from {@link IAssignCancelable.update}. */\n  abstract update(value: ICancelable): this\n\n  /** Inherited from {@link IBoolCancelable.isCanceled}. */\n  abstract isCanceled(): boolean\n\n  /** Inherited from {@link ICancelable.cancel}. */\n  abstract cancel(): void\n\n  /**\n   * Returns an [[AssignCancelable]] reference that is already\n   * canceled.\n   *\n   * ```typescript\n   * const ref = AssignCancelable.alreadyCanceled()\n   * ref.isCanceled() //=> true\n   *\n   * const c = BooleanCancelable.empty()\n   * ref.update(c) // cancels c\n   * c.isCanceled() // true\n   * ```\n   *\n   * The implementation returns the same reusable reference.\n   */\n  public static alreadyCanceled(): AssignCancelable {\n    return AlreadyCanceledAssignCancelableRef\n  }\n\n  /**\n   * Returns a new [[AssignCancelable]] that's empty.\n   *\n   * The returned reference is an instance of\n   * [[MultiAssignCancelable]], but this is an implementation\n   * detail that may change in the future.\n   */\n  public static empty(): AssignCancelable {\n    return MultiAssignCancelable.empty()\n  }\n\n  /**\n   * Initiates an [[AssignCancelable]] reference and assigns it\n   * a reference that wraps the given `cb` callback.\n   *\n   * So this code:\n   *\n   * ```typescript\n   * AssignCancelable.of(() => console.log(\"cancelled\"))\n   * ```\n   *\n   * Is equivalent to this:\n   *\n   * ```typescript\n   * const ref = AssignCancelable.empty()\n   * ref.update(Cancelable.of(() => console.log(\"cancelled\")))\n   * ```\n   */\n  public static of(cb: () => void): AssignCancelable {\n    return MultiAssignCancelable.of(cb)\n  }\n}\n\n/**\n * Internal reusable class for an {@link IAssignCancelable} that\n * is already cancelled.\n *\n * @Hidden\n */\nclass AlreadyCanceledAssignCancelable\n  extends DummyCancelable implements IAssignCancelable {\n\n  isCanceled() { return true }\n  cancel() {}\n\n  update(value: ICancelable) {\n    value.cancel()\n    return this\n  }\n}\n\n/**\n * Internal reusable reference for an {@link IAssignCancelable} that\n * is already cancelled.\n *\n * @Hidden\n */\nconst AlreadyCanceledAssignCancelableRef: AssignCancelable =\n  new AlreadyCanceledAssignCancelable()\n\n/**\n * The `MultiAssignCancelable` is an {@link IAssignCancelable} whose\n * underlying cancelable reference can be swapped for another.\n *\n * Example:\n *\n * ```typescript\n * const ref = MultiAssignCancelable()\n * ref.update(c1) // sets the underlying cancelable to c1\n * ref.update(c2) // swaps the underlying cancelable to c2\n *\n * ref.cancel() // also cancels c2\n * ref := c3 // also cancels c3, because s is already canceled\n * ```\n *\n * Also see [[SerialCancelable]], which is similar, except that it\n * cancels the old cancelable upon assigning a new cancelable.\n */\nexport class MultiAssignCancelable implements IAssignCancelable {\n  private _underlying?: ICancelable\n  private _canceled: boolean\n\n  constructor(initial?: ICancelable) {\n    this._underlying = initial\n    this._canceled = false\n  }\n\n  /** @inheritdoc */\n  public update(value: ICancelable): this {\n    if (this._canceled) value.cancel()\n    else this._underlying = value\n    return this\n  }\n\n  /** @inheritdoc */\n  public isCanceled(): boolean {\n    return this._canceled\n  }\n\n  /** @inheritdoc */\n  public cancel(): void {\n    if (!this._canceled) {\n      this._canceled = true\n      if (this._underlying) {\n        this._underlying.cancel()\n        delete this._underlying\n      }\n    }\n  }\n\n  /**\n   * In case the underlying reference is also a `MultiAssignCancelable`, then\n   * collapse its state into this one.\n   *\n   * ```typescript\n   * const c = Cancelable.of(() => console.info(\"Cancelled!\"))\n   *\n   * const mc1 = new MultiAssignCancelable()\n   * mc1.update(c)\n   *\n   * const mc2 = new MultiAssignCancelable()\n   * mc2.update(mc1)\n   *\n   * // After this the underlying reference of `mc2` becomes `c`\n   * mc2.collapse()\n   * ```\n   */\n  public collapse(): this {\n    if (this._underlying && this._underlying instanceof MultiAssignCancelable) {\n      const ref = this._underlying\n      this._underlying = ref._underlying\n      this._canceled = ref._canceled\n    }\n    return this\n  }\n\n  /**\n   * Sets the underlying cancelable reference to `undefined`,\n   * useful for garbage-collecting purposes.\n   */\n  public clear(): this {\n    if (!this._canceled) this._underlying = undefined\n    return this\n  }\n\n  /**\n   * Returns a new [[MultiAssignCancelable]] that's empty.\n   */\n  public static empty(): MultiAssignCancelable {\n    return new MultiAssignCancelable()\n  }\n\n  /**\n   * Initiates an [[MultiAssignCancelable]] reference and assigns it\n   * a reference that wraps the given `cb` callback.\n   *\n   * So this code:\n   *\n   * ```typescript\n   * MultiAssignCancelable.of(() => console.log(\"cancelled\"))\n   * ```\n   *\n   * Is equivalent to this:\n   *\n   * ```typescript\n   * const ref = MultiAssignCancelable.empty()\n   * ref.update(Cancelable.of(() => console.log(\"cancelled\")))\n   * ```\n   */\n  public static of(cb: () => void): MultiAssignCancelable {\n    return new MultiAssignCancelable(Cancelable.of(cb))\n  }\n}\n\n/**\n * The `SerialCancelable` is an {@link IAssignCancelable} whose underlying\n * cancelable reference can be swapped for another and on each\n * swap the previous reference gets canceled.\n *\n * Example:\n *\n * ```typescript\n * const ref = SerialCancelable()\n * ref.update(c1) // sets the underlying cancelable to c1\n * ref.update(c2) // cancels c1, swaps the underlying cancelable to c2\n *\n * ref.cancel() // also cancels c2\n * ref := c3 // also cancels c3, because s is already canceled\n * ```\n *\n * Also see [[SerialCancelable]], which is similar, except that it\n * cancels the old cancelable upon assigning a new cancelable.\n */\nexport class SerialCancelable implements IAssignCancelable {\n  private _underlying?: ICancelable\n  private _canceled: boolean\n\n  constructor(initial?: ICancelable) {\n    this._underlying = initial\n    this._canceled = false\n  }\n\n  public update(value: ICancelable): this {\n    if (this._canceled) value.cancel(); else {\n      if (this._underlying) this._underlying.cancel()\n      this._underlying = value\n    }\n    return this\n  }\n\n  public isCanceled(): boolean {\n    return this._canceled\n  }\n\n  public cancel(): void {\n    if (!this._canceled) {\n      this._canceled = true\n      if (this._underlying) {\n        this._underlying.cancel()\n        delete this._underlying\n      }\n    }\n  }\n\n  /**\n   * Returns a new [[SerialCancelable]] that's empty.\n   */\n  public static empty(): SerialCancelable {\n    return new SerialCancelable()\n  }\n\n  /**\n   * Initiates an [[SerialCancelable]] reference and assigns it\n   * a reference that wraps the given `cb` callback.\n   *\n   * So this code:\n   *\n   * ```typescript\n   * SerialCancelable.of(() => console.log(\"cancelled\"))\n   * ```\n   *\n   * Is equivalent to this:\n   *\n   * ```typescript\n   * const ref = SerialCancelable.empty()\n   * ref.update(Cancelable.of(() => console.log(\"cancelled\")))\n   * ```\n   */\n  public static of(cb: () => void): SerialCancelable {\n    return new SerialCancelable(Cancelable.of(cb))\n  }\n}\n\n/**\n * The `SingleAssignCancelable` is a [[Cancelable]] that can be\n * assigned only once to another cancelable reference.\n *\n * Example:\n *\n * ```typescript\n * const ref = SingleAssignCancelable()\n * ref.update(c1) // sets the underlying cancelable to c1\n *\n * ref.update(c2) // throws IllegalStateError\n * ```\n *\n * See [[MultiAssignCancelable]] for a similar type that can be\n * assigned multiple types.\n */\nexport class SingleAssignCancelable implements IAssignCancelable {\n  private _wasAssigned: boolean\n  private _canceled: boolean\n  private _underlying?: ICancelable\n\n  constructor() {\n    this._canceled = false\n    this._wasAssigned = false\n  }\n\n  /** @inheritdoc */\n  public update(value: ICancelable): this {\n    if (this._wasAssigned)\n      throw new IllegalStateError(\"SingleAssignCancelable#update multiple times\")\n\n    this._wasAssigned = true\n    if (this._canceled) value.cancel()\n    else this._underlying = value\n    return this\n  }\n\n  /** @inheritdoc */\n  public isCanceled(): boolean {\n    return this._canceled\n  }\n\n  /** @inheritdoc */\n  public cancel(): void {\n    if (!this._canceled) {\n      this._canceled = true\n      if (this._underlying) {\n        this._underlying.cancel()\n        delete this._underlying\n      }\n    }\n  }\n\n  /**\n   * Returns a new [[SingleAssignCancelable]] that's empty.\n   */\n  public static empty(): SingleAssignCancelable {\n    return new SingleAssignCancelable()\n  }\n\n  /**\n   * Initiates an [[SingleAssignCancelable]] reference and assigns it\n   * a reference that wraps the given `cb` callback.\n   *\n   * So this code:\n   *\n   * ```typescript\n   * SingleAssignCancelable.of(() => console.log(\"cancelled\"))\n   * ```\n   *\n   * Is equivalent to this:\n   *\n   * ```typescript\n   * const ref = SingleAssignCancelable.empty()\n   * ref.update(Cancelable.of(() => console.log(\"cancelled\")))\n   * ```\n   */\n  public static of(cb: () => void): SingleAssignCancelable {\n    const ref = new SingleAssignCancelable()\n    ref.update(Cancelable.of(cb))\n    return ref\n  }\n}\n\n/**\n * Represents a composite of cancelable references that are stacked,\n * so you can push a new reference, or pop an existing one and when\n * it gets canceled, then the whole stack gets canceled.\n *\n * The references are pushed and popped in a FIFO order.\n *\n * Used in the implementation of `Task`.\n *\n * @final\n */\nexport class StackedCancelable implements IBoolCancelable {\n  private _refs?: ICancelable[]\n\n  constructor(initial?: ICancelable[]) {\n    this._refs = initial ? initial.slice(0) : []\n  }\n\n  cancel(): void {\n    if (this._refs)\n      try {\n        Cancelable.cancelAll(this._refs)\n      } finally {\n        delete this._refs\n      }\n  }\n\n  isCanceled(): boolean {\n    return !this._refs\n  }\n\n  /**\n   * Pushes a cancelable reference on the stack, to be popped or\n   * cancelled later in FIFO order.\n   */\n  push(value: ICancelable): this {\n    if (this._refs) {\n      this._refs.push(value)\n    } else {\n      value.cancel()\n    }\n    return this\n  }\n\n  /**\n   * Removes a cancelable reference from the stack in FIFO order.\n   *\n   * @return the cancelable reference that was removed.\n   */\n  pop(): ICancelable {\n    if (!this._refs) return Cancelable.empty()\n    return this._refs.pop() || Cancelable.empty()\n  }\n\n  /**\n   * Returns a new {@link StackedCancelable} that's empty.\n   */\n  static empty(): StackedCancelable {\n    return new StackedCancelable()\n  }\n\n  /**\n   * Returns a {@link StackedCancelable} that's initialized with\n   * the given list of cancelable references.\n   *\n   * ```typescript\n   * const list = StackedCancelable.collection(\n   *   Cancelable.of(() => console.log(\"Cancelled #1\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #2\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #3\"))\n   * )\n   *\n   * // Popping cancelable no. 3 from the stack\n   * list.pop()\n   *\n   * list.cancel()\n   * //=> Cancelled #1\n   * //=> Cancelled #2\n   * ```\n   *\n   * @param refs is the array of references to cancel when\n   *        cancellation is triggered\n   */\n  static collection(...refs: Array<ICancelable>): StackedCancelable {\n    return new StackedCancelable(refs)\n  }\n}\n\n/**\n * Represents an {@link IAssignCancelable} whose underlying\n * cancelable reference can be swapped for another. It can\n * be \"chained\" to another `ChainedCancelable`, forwarding all\n * operations to it.\n *\n * For most purposes it works like a {@link MultiAssignCancelable}:\n *\n * ```typescript\n *   const s = ChainedCancelable.empty()\n *   s.update(c1) // sets the underlying cancelable to c1\n *   s.update(c2) // swaps the underlying cancelable to c2\n *\n *   s.cancel() // also cancels c2\n *   s.update(c3) // also cancels c3, because s is already canceled\n * ```\n *\n * However it can also be linked to another `ChainedCancelable`\n * reference, forwarding all requests to it:\n *\n * ```typescript\n *   const source = ChainedCancelable.empty()\n *   const child1 = ChainedCancelable.empty()\n *   const child2 = ChainedCancelable.empty()\n *\n *   // Hence forth forwards all operations on `child1` to `source`\n *   child1.chainTo(source)\n *\n *   // Also forwarding all `child2` operations to `source`.\n *   // This happens because `child1` was linked to `source` first\n *   // but order matters, as `child2` will be linked directly\n *   // to `source` and not to `child1`, in order for `child1` to\n *   // be garbage collected if it goes out of scope ;-)\n *   child2.chainTo(child1)\n *\n *   // Source will be updated with a new Cancelable ref\n *   child1.update(Cancelable.from(() => println(\"Cancelling (1)\")))\n *\n *   // Source will be updated with another Cancelable ref\n *   child2.update(Cancelable.from(() => println(\"Cancelling (2)\")))\n *\n *   source.cancel()\n *   //=> Cancelling (2)\n * ```\n *\n * This implementation is a special purpose {@link IAssignCancelable},\n * much like {@link StackedCancelable}, to be used in `flatMap`\n * implementations that need it.\n *\n * The problem that it solves in Funfix's codebase is that various\n * `flatMap` implementations need to be memory safe.\n * By \"chaining\" cancelable references, we allow the garbage collector\n * to get rid of references created in a `flatMap` loop, the goal\n * being to consume a constant amount of memory. Thus this\n * implementation is used for the {@link Future} implementation.\n *\n * If unsure about what to use, then you probably don't need\n * {@link ChainedCancelable}. Use {@link MultiAssignCancelable} or\n * {@link SingleAssignCancelable} for most purposes.\n */\nexport class ChainedCancelable implements IAssignCancelable {\n  private _underlying?: ICancelable\n  private _chained: boolean\n\n  constructor(initial?: ICancelable) {\n    // Reference cannot be null, because that signals a cancelled `this`\n    this._underlying = initial || Empty\n    this._chained = false\n  }\n\n  update(value: ICancelable): this {\n    if (!value) throw new IllegalArgumentError(`cannot update to null value`)\n    // A null underlying value signals a canceled `this`\n    if (!this._underlying) {\n      value.cancel()\n      return this\n    }\n    else if (this._chained) {\n      (this._underlying as ChainedCancelable).update(value)\n      return this\n    }\n    else {\n      this._underlying = value\n      return this\n    }\n  }\n\n  cancel(): void {\n    if (this._underlying) {\n      this._underlying.cancel()\n      this._chained = false\n      delete this._underlying\n    }\n  }\n\n  /**\n   * Clears the underlying reference, resetting it to a dummy\n   * reference.\n   *\n   * To be used for garbage collecting purposes.\n   */\n  clear(): void {\n    if (this._underlying) {\n      this._underlying = Empty\n      this._chained = false\n    }\n  }\n\n  isCanceled(): boolean {\n    return !this._underlying || (\n      this._chained && (this._underlying as ChainedCancelable).isCanceled())\n  }\n\n  /**\n   * Chains this `ChainedCancelable` to another reference,\n   * such that all operations are forwarded to `other`.\n   *\n   * ```typescript\n   * const source = ChainedCancelable.empty()\n   * const child1 = ChainedCancelable.empty()\n   * const child2 = ChainedCancelable.empty()\n   *\n   * // Hence forth forwards all operations on `child1` to `source`\n   * child1.chainTo(source)\n   *\n   * // Also forwarding all `child2` operations to `source`\n   * // (this happens because `child1` was linked to `source` first\n   * // but order matters ;-))\n   * child2.chainTo(child1)\n   *\n   * // Source will be updated with a new Cancelable ref\n   * child1.update( Cancelable.of(() => console.log(\"Cancelling (1)\")) )\n   *\n   * // Source will be updated with another Cancelable ref\n   * child2.update( Cancelable.of (() => console.log(\"Cancelling (2)\")) )\n   *\n   * source.cancel()\n   * //=> Cancelling (2)\n   * ```\n   */\n  chainTo(other: ChainedCancelable): this {\n    if (!other) throw new IllegalArgumentError(`cannot chain to null value`)\n    // Short-circuit in case we have the same reference\n    if (other === this) return this\n\n    if (!this._underlying) {\n      other.cancel()\n      return this\n    }\n\n    // Getting the last ChainedCancelable reference in the\n    // chain, since that's the reference that we care about!\n    let ref: ChainedCancelable | undefined = other\n    let keepSearching = true\n\n    while (ref && keepSearching) {\n      if (ref._chained) {\n        const ref2: ICancelable | undefined = ref._underlying\n        // Interrupt infinite loop if we see the same reference\n        if (ref2 === this) return this\n        ref = ref2 as ChainedCancelable\n        keepSearching = !!ref2\n      } else {\n        if (!ref._underlying) ref = undefined\n        keepSearching = false\n      }\n    }\n\n    // A null or undefined reference means that `other` is already\n    // cancelled, therefore we are cancelling `this` as well\n    if (!ref) {\n      this.cancel()\n    } else {\n      const prev = this._underlying\n      this._underlying = ref\n      this._chained = true\n\n      if (!(prev instanceof DummyCancelable))\n        ref.update(prev)\n    }\n    return this\n  }\n\n  /**\n   * Returns a new, empty [[ChainedCancelable]].\n   */\n  public static empty(): ChainedCancelable {\n    return new ChainedCancelable()\n  }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IEquals, IllegalArgumentError } from \"funfix-core\"\n\n/**\n * A `TimeUnit` represents time durations at a given unit of\n * granularity and provides utility methods to convert across units,\n * and to perform timing and delay operations in these units.\n *\n * A `TimeUnit` does not maintain time information, but only helps\n * organize and use time representations that may be maintained\n * separately across various contexts. A nanosecond is defined as one\n * thousandth of a microsecond, a microsecond as one thousandth of a\n * millisecond, a millisecond as one thousandth of a second, a minute\n * as sixty seconds, an hour as sixty minutes, and a day as twenty\n * four hours.\n *\n * `TimeUnit` is an enumeration and in usage the already defined\n * constants should be used:\n *\n *  - [[NANOSECONDS]]\n *  - [[MICROSECONDS]]\n *  - [[MILLISECONDS]]\n *  - [[SECONDS]]\n *  - [[MINUTES]]\n *  - [[HOURS]]\n *  - [[DAYS]]\n *\n * Example:\n *\n * ```typescript\n * // Converting 10 minutes to nanoseconds\n * MINUTES.toNanos(10)\n * // Equivalent with the above:\n * NANOSECONDS.convert(10, MINUTES)\n * ```\n */\nexport abstract class TimeUnit {\n  /**\n   * Converts the given time duration in the given unit to this unit.\n   * Conversions from finer to coarser granularities truncate, so lose\n   * precision. For example, converting `999` milliseconds to seconds\n   * results in `0`. Conversions from coarser to finer granularities\n   * with arguments that would numerically overflow saturate to\n   * `Number.MAX_VALUE` if negative or `MAX_VALUE` if positive.\n   *\n   * For example, to convert 10 minutes to milliseconds, use:\n   *\n   * ```typescript\n   * MILLISECONDS.convert(10, MINUTES)\n   * // ... or ...\n   * MINUTES.toMillis(10)\n   * ```\n   *\n   * @param duration the time duration in the given `unit`\n   * @param unit the unit of the `duration` argument\n   *\n   * @return the converted duration in this unit, or `Number.MIN_VALUE`\n   * if conversion would negatively overflow, or `Number.MAX_VALUE`\n   * if it would positively overflow\n   */\n  abstract convert(duration: number, unit: TimeUnit): number\n\n  /**\n   * Converts the given `d` value to nanoseconds.\n   *\n   * Equivalent with `NANOSECONDS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toNanos(d: number): number\n\n  /**\n   * Converts the given `d` value to microseconds.\n   *\n   * Equivalent with `MICROSECONDS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toMicros(d: number): number\n\n  /**\n   * Converts the given `d` value to milliseconds.\n   *\n   * Equivalent with `MILLISECONDS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toMillis(d: number): number\n\n  /**\n   * Converts the given `d` value to seconds.\n   *\n   * Equivalent with `SECONDS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toSeconds(d: number): number\n\n  /**\n   * Converts the given `d` value to minutes.\n   *\n   * Equivalent with `MINUTES.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toMinutes(d: number): number\n\n  /**\n   * Converts the given `d` value to hours.\n   *\n   * Equivalent with `HOURS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toHours(d: number): number\n\n  /**\n   * Converts the given `d` value to days.\n   *\n   * Equivalent with `DAYS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toDays(d: number): number\n\n  /**\n   * A number representing the unit's ordering in the `TimeUnit`\n   * enumeration, useful for doing comparisons to find out which unit\n   * is more coarse grained.\n   *\n   * ```typescript\n   * MINUTES.ord < DAYS.ord // true\n   * SECONDS.ord > MICROSECONDS.org // true\n   * ```\n   */\n  abstract ord: number\n\n  /**\n   * A human readable label for this unit.\n   */\n  abstract label: string\n\n  /** Override for `Object.toString`. */\n  toString(): string {\n    return this.label.toUpperCase()\n  }\n}\n\n/** @hidden */ const C0 = 1\n/** @hidden */ const C1 = C0 * 1000\n/** @hidden */ const C2 = C1 * 1000\n/** @hidden */ const C3 = C2 * 1000\n/** @hidden */ const C4 = C3 * 60\n/** @hidden */ const C5 = C4 * 60\n/** @hidden */ const C6 = C5 * 24\n\n/** @hidden */ const MIN = -9007199254740992\n/** @hidden */ const MAX = 9007199254740992\n\n/** @hidden */\nconst trunc: (x: number) => number = Math.trunc ||\n  /* istanbul ignore next */\n  function (x) {\n    if (isNaN(x)) return NaN\n    if (x > 0) return Math.floor(x)\n    return Math.ceil(x)\n  }\n\n/** @hidden */\nfunction x(d: number, m: number, over: number): number {\n  if (d > over) return MAX\n  if (d < -over) return MIN\n  return d * m\n}\n\n/** @hidden */\nclass Nanoseconds extends TimeUnit {\n  ord: number = 0\n  label = \"nanoseconds\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toNanos(duration) }\n  toNanos(d: number): number { return d }\n  toMicros(d: number): number { return trunc(d / (C1 / C0)) }\n  toMillis(d: number): number { return trunc(d / (C2 / C0)) }\n  toSeconds(d: number): number { return trunc(d / (C3 / C0)) }\n  toMinutes(d: number): number { return trunc(d / (C4 / C0)) }\n  toHours(d: number): number { return trunc(d / (C5 / C0)) }\n  toDays(d: number): number { return trunc(d / (C6 / C0)) }\n}\n\n /**\n  * Time unit for representing nanoseconds, where 1 nanosecond is\n  * one thousandth of a microsecond.\n  */\nexport const NANOSECONDS: TimeUnit =\n  new Nanoseconds()\n\n/** @hidden */\nclass Microseconds extends TimeUnit {\n  ord: number = 1\n  label = \"microseconds\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toMicros(duration) }\n  toNanos(d: number): number { return x(d, C1 / C0, trunc(MAX / (C1 / C0))) }\n  toMicros(d: number): number { return d }\n  toMillis(d: number): number { return trunc(d / (C2 / C1)) }\n  toSeconds(d: number): number { return trunc(d / (C3 / C1)) }\n  toMinutes(d: number): number { return trunc(d / (C4 / C1)) }\n  toHours(d: number): number { return trunc(d / (C5 / C1)) }\n  toDays(d: number): number { return trunc(d / (C6 / C1)) }\n}\n\n /**\n  * Time unit for representing microseconds, where 1 microsecond is\n  * one thousandth of a millisecond.\n  */\nexport const MICROSECONDS: TimeUnit =\n  new Microseconds()\n\n/** @hidden */\nclass Milliseconds extends TimeUnit {\n  ord: number = 2\n  label = \"milliseconds\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toMillis(duration) }\n  toNanos(d: number): number { return x(d, C2 / C0, trunc(MAX / (C2 / C0))) }\n  toMicros(d: number): number { return x(d, C2 / C1, trunc(MAX / (C2 / C1))) }\n  toMillis(d: number): number { return d }\n  toSeconds(d: number): number { return trunc(d / (C3 / C2)) }\n  toMinutes(d: number): number { return trunc(d / (C4 / C2)) }\n  toHours(d: number): number { return trunc(d / (C5 / C2)) }\n  toDays(d: number): number { return trunc(d / (C6 / C2)) }\n}\n\n /**\n  * Time unit for representing milliseconds, where 1 millisecond is\n  * one thousandth of a second.\n  */\nexport const MILLISECONDS: TimeUnit =\n  new Milliseconds()\n\n/** @hidden */\nclass Seconds extends TimeUnit {\n  ord: number = 3\n  label = \"seconds\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toSeconds(duration) }\n  toNanos(d: number): number { return x(d, C3 / C0, trunc(MAX / (C3 / C0))) }\n  toMicros(d: number): number { return x(d, C3 / C1, trunc(MAX / (C3 / C1))) }\n  toMillis(d: number): number { return x(d, C3 / C2, trunc(MAX / (C3 / C2))) }\n  toSeconds(d: number): number { return d }\n  toMinutes(d: number): number { return trunc(d / (C4 / C3)) }\n  toHours(d: number): number { return trunc(d / (C5 / C3)) }\n  toDays(d: number): number { return trunc(d / (C6 / C3)) }\n}\n\n /**\n  * Time unit for representing seconds.\n  */\nexport const SECONDS: TimeUnit =\n  new Seconds()\n\n/** @hidden */\nclass Minutes extends TimeUnit {\n  ord: number = 4\n  label = \"minutes\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toMinutes(duration) }\n  toNanos(d: number): number { return x(d, C4 / C0, trunc(MAX / (C4 / C0))) }\n  toMicros(d: number): number { return x(d, C4 / C1, trunc(MAX / (C4 / C1))) }\n  toMillis(d: number): number { return x(d, C4 / C2, trunc(MAX / (C4 / C2))) }\n  toSeconds(d: number): number { return x(d, C4 / C3, trunc(MAX / (C4 / C3))) }\n  toMinutes(d: number): number { return d }\n  toHours(d: number): number { return trunc(d / (C5 / C4)) }\n  toDays(d: number): number { return trunc(d / (C6 / C4)) }\n}\n\n /**\n  * Time unit for representing minutes.\n  */\nexport const MINUTES: TimeUnit =\n  new Minutes()\n\n/** @hidden */\nclass Hours extends TimeUnit {\n  ord: number = 5\n  label = \"hours\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toHours(duration) }\n  toNanos(d: number): number { return x(d, C5 / C0, trunc(MAX / (C5 / C0))) }\n  toMicros(d: number): number { return x(d, C5 / C1, trunc(MAX / (C5 / C1))) }\n  toMillis(d: number): number { return x(d, C5 / C2, trunc(MAX / (C5 / C2))) }\n  toSeconds(d: number): number { return x(d, C5 / C3, trunc(MAX / (C5 / C3))) }\n  toMinutes(d: number): number { return x(d, C5 / C4, trunc(MAX / (C5 / C4))) }\n  toHours(d: number): number { return d }\n  toDays(d: number): number { return trunc(d / (C6 / C5)) }\n}\n\n /**\n  * Time unit for representing hours.\n  */\nexport const HOURS: TimeUnit =\n  new Hours()\n\n/** @hidden */\nclass Days extends TimeUnit {\n  ord: number = 6\n  label = \"days\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toDays(duration) }\n  toNanos(d: number): number { return x(d, C6 / C0, trunc(MAX / (C6 / C0))) }\n  toMicros(d: number): number { return x(d, C6 / C1, trunc(MAX / (C6 / C1))) }\n  toMillis(d: number): number { return x(d, C6 / C2, trunc(MAX / (C6 / C2))) }\n  toSeconds(d: number): number { return x(d, C6 / C3, trunc(MAX / (C6 / C3))) }\n  toMinutes(d: number): number { return x(d, C6 / C4, trunc(MAX / (C6 / C4))) }\n  toHours(d: number): number { return x(d, C6 / C5, trunc(MAX / (C6 / C5))) }\n  toDays(d: number): number { return d }\n}\n\n /**\n  * Time unit for representing days.\n  */\nexport const DAYS: TimeUnit =\n  new Days()\n\n/**\n * A simple representation for time durations, based on [[TimeUnit]].\n */\nexport class Duration implements IEquals<Duration> {\n  public duration: number\n  public unit: TimeUnit\n\n  constructor(duration: number, unit: TimeUnit) {\n    if (isNaN(duration)) {\n      throw new IllegalArgumentError(\"NaN is not supported for a Duration\")\n    }\n    // Only integers allowed\n    this.duration = trunc(duration)\n    this.unit = unit\n  }\n\n  /**\n   * This method returns `true` if this duration is finite,\n   * or `false otherwise.\n   */\n  isFinite(): boolean { return isFinite(this.duration) }\n\n  /**\n   * Calculates the nanoseconds described by the source [[Duration]].\n   */\n  toNanos(): number {\n    return NANOSECONDS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the microseconds described by the source [[Duration]].\n   */\n  toMicros(): number {\n    return MICROSECONDS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the milliseconds described by the source [[Duration]].\n   */\n  toMillis(): number {\n    return MILLISECONDS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the seconds described by the source [[Duration]].\n   */\n  toSeconds(): number {\n    return SECONDS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the minutes described by the source [[Duration]].\n   */\n  toMinutes(): number {\n    return MINUTES.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the hours described by the source [[Duration]].\n   */\n  toHours(): number {\n    return HOURS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the days described by the source [[Duration]].\n   */\n  toDays(): number {\n    return DAYS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Returns a new `Duration` value that represents `this` converted\n   * to use the given `unit`.\n   *\n   * Note that this may be a lossy conversion, e.g. when converting\n   * 27 hours to 1 day, there's a loss of fidelity.\n   */\n  convertTo(unit: TimeUnit): Duration {\n    return new Duration(unit.convert(this.duration, this.unit), unit)\n  }\n\n  /**\n   * Negates `this` duration, by changing the sign.\n   */\n  negate(): Duration {\n    switch (this.duration) {\n      case Infinity: return Duration.negInf()\n      case -Infinity: return Duration.inf()\n      default:\n        return new Duration(-this.duration, this.unit)\n    }\n  }\n\n  /**\n   * Return the sum of `this` duration and `other`.\n   *\n   * Note that the `unit` used for the result will be the\n   * more finer grained one out of the two.\n   *\n   * ```typescript\n   * // Result will be 27 hours\n   * Duration.days(1).plus(Duration.hours(3))\n   * ```\n   */\n  plus(other: Duration): Duration {\n    if (!isFinite(this.duration)) {\n      if (!isFinite(other.duration) && this.duration !== other.duration) {\n        throw new IllegalArgumentError(\n          \"cannot deal with two infinities with different signs, \" +\n          \"as that would be a NaN\")\n      }\n      return this\n    } else if (other.duration === 0) {\n      return this\n    } else if (this.duration === 0) {\n      return other\n    }\n\n    if (!isFinite(other.duration)) return other\n\n    let d1: Duration = this\n    let d2: Duration = other\n    if (d2.unit.ord < d1.unit.ord) { d1 = other; d2 = this }\n\n    d2 = d2.convertTo(d1.unit)\n    return new Duration(d1.duration + d2.duration, d1.unit)\n  }\n\n  /**\n   * Subtracts the `other` duration from `this`.\n   *\n   * Note that the `unit` used for the result will be the\n   * more finer grained one out of the two:\n   *\n   * ```typescript\n   * // Result will be 21 hours\n   * Duration.days(1).minus(Duration.hours(3))\n   * ```\n   */\n  minus(other: Duration): Duration {\n    return this.plus(other.negate())\n  }\n\n  /** @inheritdoc */\n  equals(other: Duration): boolean {\n    function cmp(s: Duration, o: Duration) {\n      const n = s.unit.convert(o.duration, o.unit)\n      return n === s.duration\n    }\n\n    if (!isFinite(this.duration)) {\n      return !isFinite(other.duration) &&\n        this.duration === other.duration\n    }\n    return this.unit.ord <= other.unit.ord\n      ? cmp(this, other) : cmp(other, this)\n  }\n\n  /** @inheritdoc */\n  hashCode(): number {\n    if (this.isFinite()) {\n      return this.toNanos()\n    } else if (this.duration === Infinity) {\n      return 7540833725118015\n    } else {\n      return 422082410550358\n    }\n  }\n\n  toString(): string {\n    if (this.isFinite())\n      return `${this.duration} ${this.unit.label}`\n    else if (this.duration >= 0)\n      return \"[end of time]\"\n    else\n      return \"[beginning of time]\"\n  }\n\n  /**\n   * Wraps the argument in a `Duration.millis` reference, in case it's\n   * a number, otherwise returns the argument as is.\n   *\n   * In Javascript code it is customary to express durations with\n   * numbers representing milliseconds and in functions it's good\n   * to still allow developers to do that because it's the standard\n   * convention.\n   *\n   * Thus one can work with a union type like `number | Duration`.\n   * And in case a `number` is given, then it is interpreted as\n   * milliseconds.\n   *\n   * Usage:\n   *\n   * ```typescript\n   * function delay(d: number | Duration, r: () => {}) {\n   *   const millis = Duration.of(d).toMillis()\n   *   return setTimeout(r, millis)\n   * }\n   * ```\n   */\n  static of(value: number | Duration): Duration {\n    return typeof value === \"number\"\n      ? Duration.millis(value)\n      : value\n  }\n\n  /** Returns a zero length duration. */\n  static zero(): Duration {\n    return new Duration(0, DAYS)\n  }\n\n  /** Returns a [[Duration]] representing positive infinite. */\n  static inf(): Duration {\n    return new Duration(Infinity, DAYS)\n  }\n\n  /** Returns a [[Duration]] representing negative infinite. */\n  static negInf(): Duration {\n    return new Duration(-Infinity, DAYS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * nanoseconds.\n   */\n  static nanos(d: number): Duration {\n    return new Duration(d, NANOSECONDS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * microseconds.\n   */\n  static micros(d: number): Duration {\n    return new Duration(d, MICROSECONDS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * milliseconds.\n   */\n  static millis(d: number): Duration {\n    return new Duration(d, MILLISECONDS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * seconds.\n   */\n  static seconds(d: number): Duration {\n    return new Duration(d, SECONDS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * minutes.\n   */\n  static minutes(d: number): Duration {\n    return new Duration(d, MINUTES)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * hours.\n   */\n  static hours(d: number): Duration {\n    return new Duration(d, HOURS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * days.\n   */\n  static days(d: number): Duration {\n    return new Duration(d, DAYS)\n  }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * `DynamicRef` provides a binding mechanism where the current value is\n * found through dynamic scope, but where access to the variable itself is\n * resolved through static scope.\n *\n * The current value can be retrieved with the {@link DynamicRef.get} method.\n * New values should be pushed using the {@link DynamicRef.bind} method.\n *\n * Values pushed via `bind` only stay valid while its second argument,\n * a parameterless function (the `thunk`), executes. When that thunk finishes\n * execution, the reference reverts to the previous value.\n *\n * See {@link DynamicRef.bind} for a usage sample.\n *\n * @final\n */\nexport class DynamicRef<A> {\n  /** Previous states of the ref, to use in `revert`. */\n  private _previous: (() => A)[] = []\n\n  /** Returns the current value of this `DynamicRef`. */\n  get: () => A\n\n  private constructor(fn: () => A) {\n    this.get = fn\n  }\n\n  /**\n   * Updates the underlying of this `DynamicRef` to the given `value`.\n   *\n   * Note that the previous state can be reverted with\n   * [revert]{@link DynamicRef.revert}:\n   *\n   * ```typescript\n   * const ref = DynamicRef.of(() => \"initial\")\n   *\n   * ref.set(\"another\")\n   * ref.get() // another\n   *\n   * ref.revert()\n   * ref.get() // initial\n   * ```\n   */\n  set(value: A): void {\n    return this.setL(() => value)\n  }\n\n  /**\n   * Updates the underlying of this `DynamicRef` to values generated by the\n   * given `thunk`.\n   *\n   * Note that the previous state can be reverted with\n   * [revert]{@link DynamicRef.revert}:\n   *\n   * ```typescript\n   * const ref = DynamicRef.of(() => \"initial\")\n   *\n   * ref.setL(() => \"another\")\n   * ref.get() // another\n   *\n   * ref.revert()\n   * ref.get() // initial\n   * ```\n   */\n  setL(thunk: () => A): void {\n    this._previous.push(this.get)\n    this.get = thunk\n  }\n\n  /**\n   * Reverts this `DynamicRef` to a previous state, if a previous\n   * state is available due to calling [set]{@link DynamicRef.set} or\n   * [setL]{@link DynamicRef.setL}.\n   *\n   * ```typescript\n   * const ref = DynamicRef.of(() => \"initial\")\n   *\n   * ref.set(\"state 2\")\n   * ref.set(\"state 3\")\n   * ref.get() // Yields: state 3\n   *\n   * ref.revert()\n   * ref.get() // Yields: state 2\n   *\n   * ref.revert()\n   * ref.get() // Yields: initial\n   *\n   * ref.revert() // No-op\n   * ref.get() // Yields: initial\n   * ```\n   */\n  revert(): void {\n    const thunk = this._previous.pop()\n    if (thunk) this.get = thunk\n  }\n\n  /**\n   * Binds this `DynamicRef` to a different (strict) `value` that's going to be\n   * visible while executing `thunk` and then it will get reverted to\n   * its previous value.\n   *\n   * Sample:\n   *\n   * ```typescript\n   * const ref = DynamicRef.of(() => \"original\")\n   *\n   * ref.get() // original\n   *\n   * ref.bind(\"modified\", () => {\n   *   ref.get() // modified\n   * })\n   *\n   * ref.get() // original\n   * ```\n   *\n   * @see [bindL]{@link DynamicRef.bindL} for binding a non-strict value instead.\n   *\n   * @param value is the value to bind to this reference within `thunk`'s execution\n   * @param thunk is a parameterless function to execute\n   *\n   * @return the result of executing `thunk`\n   */\n  bind<R>(value: A, thunk: () => R): R {\n    return this.bindL(() => value, thunk)\n  }\n\n  /**\n   * Binds this `DynamicRef` to a different (non-strict) `value` that's going\n   * to be visible while executing `thunk` and then it will get reverted to\n   * its previous value.\n   *\n   * Sample:\n   *\n   * ```typescript\n   * const ref = DynamicRef.of(() => \"original\")\n   *\n   * ref.get() // original\n   *\n   * ref.bindL(() => \"modified\", () => {\n   *   ref.get() // modified\n   * })\n   *\n   * ref.get() // original\n   * ```\n   *\n   * @see [bind]{@link DynamicRef.bindL} for binding a strict value instead.\n   *\n   * @param value is the value generator to bind to this reference within `thunk`'s execution\n   * @param thunk is a parameterless function to execute\n   *\n   * @return the result of executing `thunk`\n   */\n  bindL<R>(value: () => A, thunk: () => R): R {\n    const oldFn = this.get\n    const oldPrev = this._previous.slice(0)\n    const ta = this as any\n    try {\n      ta.get = value\n      return thunk()\n    } finally {\n      ta.get = oldFn\n      ta._previous = oldPrev\n    }\n  }\n\n  /**\n   * Builds a {@link DynamicRef}, where the given parameterless function\n   * is going to be the generator for the default value of the returned\n   *\n   *\n   */\n  static of<A>(fn: () => A): DynamicRef<A> {\n    return new DynamicRef(fn)\n  }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IllegalArgumentError } from \"funfix-core\"\n\n/**\n * Given a sorted array, searches for an insert position for a given search\n * element such that, if inserted in the array at the returned position,\n * the array would remain sorted.\n *\n * @Hidden\n */\nexport function arrayBSearchInsertPos<A>(array: Array<A>, f: (a: A) => number):\n  ((search: number) => number) {\n\n  return search => {\n    let minIndex = 0\n    let maxIndex = array.length - 1\n\n    while (minIndex <= maxIndex) {\n      const index = (minIndex + maxIndex) / 2 | 0\n      const current = f(array[index])\n      const next = index + 1 <= maxIndex ? f(array[index + 1]) : undefined\n\n      if (current <= search && (next === undefined || search < next)) {\n        return index + 1\n      } else if (current <= search) {\n        minIndex = index + 1\n      } else { /* if (current > search) */\n        maxIndex = index - 1\n      }\n    }\n\n    return 0\n  }\n}\n\n/**\n * Internal utility that builds an iterator out of an `Iterable` or an `Array`.\n *\n * @hidden\n */\nexport function iterableToArray<A>(values: Iterable<A>): A[] {\n  if (!values) return []\n  if (Object.prototype.toString.call(values) === \"[object Array]\")\n    return values as A[]\n\n  const cursor = values[Symbol.iterator]()\n  const arr: A[] = []\n\n  while (true) {\n    const item = cursor.next()\n    if (item.value) arr.push(item.value)\n    if (item.done) return arr\n  }\n}\n\n/**\n * Natural log of 2.\n * @hidden\n */\nexport const lnOf2 = Math.log(2)\n\n/**\n * Calculates the base 2 logarithm of the given argument.\n *\n * @hidden\n * @return a number such that 2^nr^ is equal to our argument.\n */\nexport function log2(x: number): number {\n  return Math.log(x) / lnOf2\n}\n\n/**\n * The maximum number that can be returned by {@link nextPowerOf2}.\n * @hidden\n */\nexport const maxPowerOf2: number = 1 << 30\n\n/**\n * Given a positive integer, returns the next power of 2 that is bigger\n * than our argument, or the maximum that this function can\n * return which is 2^30^ (or 1,073,741,824).\n *\n * @return an integer that is a power of 2, that is bigger or\n *        equal with our argument and that is \"closest\" to it.\n *\n * @hidden\n */\nexport function nextPowerOf2(nr: number): number {\n  if (nr < 0) throw new IllegalArgumentError(\"nr must be positive\")\n  const bit = Math.ceil(log2(nr))\n  return 1 << (bit > 30 ? 30 : (bit & bit))\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IEquals, hashCodeOfString, NotImplementedError, Throwable } from \"funfix-core\"\nimport { Duration } from \"./time\"\nimport { ICancelable, Cancelable, IAssignCancelable, MultiAssignCancelable } from \"./cancelable\"\nimport { DynamicRef } from \"./ref\"\nimport { arrayBSearchInsertPos, maxPowerOf2, nextPowerOf2 } from \"./internals\"\n\n/**\n * A `Scheduler` is an execution context that can execute units of\n * work asynchronously, with a delay or periodically.\n *\n * It replaces Javascript's `setTimeout`, which is desirable due to\n * the provided utilities and because special behavior might be needed\n * in certain specialized contexts (e.g. tests), even if the\n * [[Scheduler.global]] reference is implemented with `setTimeout`.\n */\nexport abstract class Scheduler {\n  /**\n   *  The {@link ExecutionModel} is a specification of how run-loops\n   * and producers should behave in regards to executing tasks\n   * either synchronously or asynchronously.\n   */\n  public readonly executionModel: ExecutionModel\n\n  /**\n   * Index of the current cycle, incremented automatically (modulo\n   * the batch size) when doing execution by means of\n   * {@link Scheduler.executeBatched} and the `Scheduler` is\n   * configured with {@link ExecutionModel.batched}.\n   *\n   * When observed as being zero, it means an async boundary just\n   * happened.\n   */\n  batchIndex: number = 0\n\n  /**\n   * @param em the {@link ExecutionModel} to use for\n   *        {@link Scheduler.executionModel}, should default to\n   *        {@link ExecutionModel.global}\n   */\n  protected constructor(em: ExecutionModel) {\n    this.executionModel = em\n\n    // Building an optimized executeBatched\n    switch (em.type) {\n      case \"alwaysAsync\":\n        this.executeBatched = this.executeAsync\n        break\n\n      case \"synchronous\":\n        this.executeBatched = this.trampoline\n        break\n\n      case \"batched\":\n        const modulus = em.recommendedBatchSize - 1\n\n        this.executeBatched = (r) => {\n          const next = (this.batchIndex + 1) & modulus\n          if (next) {\n            this.batchIndex = next\n            return this.trampoline(r)\n          } else {\n            return this.executeAsync(r)\n          }\n        }\n    }\n  }\n\n  /**\n   * Executes tasks in batches, according to the rules set by the\n   * given {@link ExecutionModel}.\n   *\n   * The rules, depending on the chosen `ExecutionModel`:\n   *\n   * - if `synchronous`, then all tasks are executed with\n   *   {@link Scheduler.trampoline}\n   * - if `asynchronous`, then all tasks are executed with\n   *   {@link Scheduler.executeAsync}\n   * - if `batched(n)`, then `n` tasks will be executed\n   *   with `Scheduler.trampoline` and then the next execution\n   *   will force an asynchronous boundary by means of\n   *   `Scheduler.executeAsync`\n   *\n   * Thus, in case of batched execution, an internal counter gets\n   * incremented to keep track of how many tasks where executed\n   * immediately (trampolined), a counter that's reset when reaching\n   * the threshold or when an `executeAsync` happens.\n   */\n  public readonly executeBatched: (runnable: () => void) => void\n\n  /**\n   * Schedules the given `command` for async execution.\n   *\n   * In [[GlobalScheduler]] this method uses\n   * [setImmediate]{@link https://developer.mozilla.org/en/docs/Web/API/Window/setImmediate}\n   * when available. But given that `setImmediate` is a very\n   * non-standard operation that is currently implemented only by\n   * IExplorer and Node.js, on non-supporting environments we fallback\n   * on `setTimeout`. See\n   * [the W3C proposal]{@link https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html}.\n   *\n   * @param runnable is the thunk to execute asynchronously\n   */\n  public abstract executeAsync(runnable: () => void): void\n\n  /**\n   * Execute the given `runnable` on the current call stack by means\n   * of a \"trampoline\", preserving stack safety.\n   *\n   * This is an alternative to {@link executeAsync} for triggering\n   * light asynchronous boundaries.\n   */\n  public abstract trampoline(runnable: () => void): void\n\n  /** Reports that an asynchronous computation failed. */\n  public abstract reportFailure(e: Throwable): void\n\n  /**\n   * Returns the current time in milliseconds.  Note that while the\n   * unit of time of the return value is a millisecond, the\n   * granularity of the value depends on the underlying operating\n   * system and may be larger.  For example, many operating systems\n   * measure time in units of tens of milliseconds.\n   *\n   * It's the equivalent of `Date.now()`. When wanting to measure\n   * time, do not use `Date.now()` directly, prefer this method\n   * instead, because then it can be mocked for testing purposes,\n   * or overridden for better precision.\n   */\n  public abstract currentTimeMillis(): number\n\n  /**\n   * Schedules a task to run in the future, after `delay`.\n   *\n   * For example the following schedules a message to be printed to\n   * standard output after 5 minutes:\n   *\n   * ```typescript\n   * const task =\n   *   scheduler.scheduleOnce(Duration.minutes(5), () => {\n   *     console.log(\"Hello, world!\")\n   *   })\n   *\n   * // later if you change your mind ... task.cancel()\n   * ```\n   *\n   * @param delay is the time to wait until the execution happens; if\n   *        specified as a `number`, then it's interpreted as milliseconds;\n   *        for readability, prefer passing [[Duration]] values\n   * @param runnable is the callback to be executed\n   *\n   * @return a [[Cancelable]] that can be used to cancel the created\n   *         task before execution.\n   */\n  public abstract scheduleOnce(delay: number | Duration, runnable: () => void): ICancelable\n\n  /**\n   * Given a function that will receive the underlying\n   * {@link ExecutionModel}, returns a new {@link Scheduler}\n   * reference, based on the source that exposes the new\n   * `ExecutionModel` value when queried by means of the\n   * {@link Scheduler.executionModel} property.\n   *\n   * This method enables reusing global scheduler references in\n   * a local scope, but with a modified execution model to inject.\n   *\n   * The contract of this method (things you can rely on):\n   *\n   *  1. the source `Scheduler` must not be modified in any way\n   *  2. the implementation should wrap the source efficiently, such\n   *     that the result mirrors the implementation of the source\n   *     `Scheduler` in every way except for the execution model\n   *\n   * Sample:\n   *\n   * ```typescript\n   * import { Scheduler, ExecutionModel } from \"funfix\"\n   *\n   * const scheduler = Schedule.global()\n   *   .withExecutionModel(ExecutionModel.trampolined())\n   * ```\n   */\n  public abstract withExecutionModel(em: ExecutionModel): Scheduler\n\n  /**\n   * Schedules for execution a periodic task that is first executed\n   * after the given initial delay and subsequently with the given\n   * delay between the termination of one execution and the\n   * commencement of the next.\n   *\n   * For example the following schedules a message to be printed to\n   * standard output every 10 seconds with an initial delay of 5\n   * seconds:\n   *\n   * ```typescript\n   * const task =\n   *   s.scheduleWithFixedDelay(Duration.seconds(5), Duration.seconds(10), () => {\n   *     console.log(\"repeated message\")\n   *   })\n   *\n   * // later if you change your mind ...\n   * task.cancel()\n   * ```\n   *\n   * @param initialDelay is the time to wait until the first execution happens\n   * @param delay is the time to wait between 2 successive executions of the task\n   * @param runnable is the thunk to be executed\n   * @return a cancelable that can be used to cancel the execution of\n   *         this repeated task at any time.\n   */\n  public scheduleWithFixedDelay(initialDelay: number | Duration, delay: number | Duration, runnable: () => void): ICancelable {\n    const loop = (self: Scheduler, ref: IAssignCancelable, delayNow: number | Duration) =>\n      ref.update(self.scheduleOnce(delayNow, () => {\n        runnable()\n        loop(self, ref, delay)\n      }))\n\n    const task = MultiAssignCancelable.empty()\n    return loop(this, task, initialDelay)\n  }\n\n  /**\n   * Schedules a periodic task that becomes enabled first after the given\n   * initial delay, and subsequently with the given period. Executions will\n   * commence after `initialDelay` then `initialDelay + period`, then\n   * `initialDelay + 2 * period` and so on.\n   *\n   * If any execution of the task encounters an exception, subsequent executions\n   * are suppressed. Otherwise, the task will only terminate via cancellation or\n   * termination of the scheduler. If any execution of this task takes longer\n   * than its period, then subsequent executions may start late, but will not\n   * concurrently execute.\n   *\n   * For example the following schedules a message to be printed to standard\n   * output approximately every 10 seconds with an initial delay of 5 seconds:\n   *\n   * ```typescript\n   * const task =\n   *   s.scheduleAtFixedRate(Duration.seconds(5), Duration.seconds(10), () => {\n   *     console.log(\"repeated message\")\n   *   })\n   *\n   *   // later if you change your mind ...\n   *   task.cancel()\n   * ```\n   *\n   * @param initialDelay is the time to wait until the first execution happens\n   * @param period is the time to wait between 2 successive executions of the task\n   * @param runnable is the thunk to be executed\n   * @return a cancelable that can be used to cancel the execution of\n   *         this repeated task at any time.\n   */\n  public scheduleAtFixedRate(initialDelay: number | Duration, period: number | Duration, runnable: () => void): ICancelable {\n    const loop = (self: Scheduler, ref: IAssignCancelable, delayNowMs: number, periodMs: number) =>\n      ref.update(self.scheduleOnce(delayNowMs, () => {\n        // Benchmarking the duration of the runnable\n        const startAt = self.currentTimeMillis()\n        runnable()\n        // Calculating the next delay based on the current execution\n        const elapsedMs = self.currentTimeMillis() - startAt\n        const nextDelayMs = Math.max(0, periodMs - elapsedMs)\n        loop(self, ref, periodMs, nextDelayMs)\n      }))\n\n    const task = MultiAssignCancelable.empty()\n    return loop(this, task,\n      typeof initialDelay === \"number\" ? initialDelay : initialDelay.toMillis(),\n      typeof period === \"number\" ? period : period.toMillis()\n    )\n  }\n\n  /**\n   * Exposes a reusable [[GlobalScheduler]] reference by means of a\n   * {@link DynamicRef}, which allows for lexically scoped bindings to happen.\n   *\n   * ```typescript\n   * const myScheduler = new GlobalScheduler(false)\n   *\n   * Scheduler.global.bind(myScheduler, () => {\n   *   Scheduler.global.get() // myScheduler\n   * })\n   *\n   * Scheduler.global.get() // default instance\n   * ```\n   */\n  static readonly global: DynamicRef<Scheduler> =\n    DynamicRef.of(() => globalSchedulerRef)\n}\n\n/**\n * The `ExecutionModel` is a specification for how potentially asynchronous\n * run-loops should execute, imposed by the `Scheduler`.\n *\n * When executing tasks, a run-loop can always execute tasks\n * asynchronously (by forking logical threads), or it can always\n * execute them synchronously (same thread and call-stack, by\n * using an internal trampoline), or it can do a mixed mode\n * that executes tasks in batches before forking.\n *\n * The specification is considered a recommendation for how\n * run loops should behave, but ultimately it's up to the client\n * to choose the best execution model. This can be related to\n * recursive loops or to events pushed into consumers.\n */\nexport class ExecutionModel implements IEquals<ExecutionModel> {\n  /**\n   * Recommended batch size used for breaking synchronous loops in\n   * asynchronous batches. When streaming value from a producer to\n   * a synchronous consumer it's recommended to break the streaming\n   * in batches as to not hold the current thread or run-loop\n   * indefinitely.\n   *\n   * This is rounded to the next power of 2, because then for\n   * applying the modulo operation we can just do:\n   *\n   * ```typescript\n   * const modulus = recommendedBatchSize - 1\n   * // ...\n   * nr = (nr + 1) & modulus\n   * ```\n   */\n  public recommendedBatchSize: number\n\n  /**\n   * The type of the execution model, which can be:\n   *\n   * - `batched`: the default, specifying an mixed execution\n   *   mode under which tasks are executed synchronously in\n   *   batches up to a maximum size; after a batch of\n   *   {@link recommendedBatchSize} is executed, the next\n   *   execution should be asynchronous.\n   * - `synchronous`: specifies that execution should be\n   *   synchronous (immediate / trampolined) for as long as\n   *   possible.\n   * - `alwaysAsync`: specifies a run-loop should always do\n   *   async execution of tasks, triggering asynchronous\n   *   boundaries on each step.\n   */\n  public type: \"batched\" | \"synchronous\" | \"alwaysAsync\"\n\n  private constructor(type: \"batched\" | \"synchronous\" | \"alwaysAsync\", batchSize?: number) {\n    this.type = type\n    switch (type) {\n      case \"synchronous\":\n        this.recommendedBatchSize = maxPowerOf2\n        break\n      case \"alwaysAsync\":\n        this.recommendedBatchSize = 1\n        break\n      case \"batched\":\n        this.recommendedBatchSize = nextPowerOf2(batchSize || 128)\n        break\n    }\n  }\n\n  /** Implements `IEquals.equals`. */\n  equals(other: ExecutionModel): boolean {\n    return this.type === other.type &&\n      this.recommendedBatchSize === other.recommendedBatchSize\n  }\n\n  /** Implements `IEquals.hashCode`. */\n  hashCode(): number {\n    return hashCodeOfString(this.type) * 47 + this.recommendedBatchSize\n  }\n\n  /**\n   * An {@link ExecutionModel} that specifies that execution should be\n   * synchronous (immediate, trampolined) for as long as possible.\n   */\n  static synchronous(): ExecutionModel {\n    return new ExecutionModel(\"synchronous\")\n  }\n\n  /**\n   * An {@link ExecutionModel} that specifies a run-loop should always do\n   * async execution of tasks, thus triggering asynchronous boundaries on\n   * each step.\n   */\n  static alwaysAsync(): ExecutionModel {\n    return new ExecutionModel(\"alwaysAsync\")\n  }\n\n  /**\n   * Returns an {@link ExecutionModel} that specifies a mixed execution\n   * mode under which tasks are executed synchronously in batches up to\n   * a maximum size, the `recommendedBatchSize`.\n   *\n   * After such a batch of {@link recommendedBatchSize} is executed, the\n   * next execution should have a forced asynchronous boundary.\n   */\n  static batched(recommendedBatchSize?: number): ExecutionModel {\n    return new ExecutionModel(\"batched\", recommendedBatchSize)\n  }\n\n  /**\n   * The default {@link ExecutionModel} that should be used whenever\n   * an execution model isn't explicitly specified.\n   */\n  static readonly global: DynamicRef<ExecutionModel> =\n    DynamicRef.of(() => ExecutionModel.batched())\n}\n\n/**\n * Internal trampoline implementation used for implementing\n * {@link Scheduler.trampoline}.\n *\n * @final\n * @hidden\n */\nclass Trampoline {\n  private readonly _reporter: (e: Throwable) => void\n  private readonly _queue: (() => void)[]\n  private _isActive: boolean\n\n  constructor(reporter: (e: Throwable) => void) {\n    this._isActive = false\n    this._queue = []\n    this._reporter = reporter\n  }\n\n  execute(r: () => void) {\n    if (!this._isActive) {\n      this.runLoop(r)\n    } else {\n      this._queue.push(r)\n    }\n  }\n\n  private runLoop(r: () => void) {\n    this._isActive = true\n    try {\n      let cursor: (() => void) | undefined = r\n      while (cursor) {\n        try { cursor() } catch (e) { this._reporter(e) }\n        cursor = this._queue.pop()\n      }\n    } finally {\n      this._isActive = false\n    }\n  }\n}\n\n/**\n * `GlobalScheduler` is a [[Scheduler]] implementation based on Javascript's\n * [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout}\n * and (if available and configured)\n * [setImmediate]{@link https://developer.mozilla.org/en/docs/Web/API/Window/setImmediate}.\n */\nexport class GlobalScheduler extends Scheduler {\n  /**\n   * If `true`, then `setImmediate` is used in `execute`.\n   */\n  private readonly _useSetImmediate: boolean\n\n  /**\n   * {@link Trampoline} used for immediate execution in\n   * {@link Scheduler.trampoline}.\n   */\n  private readonly _trampoline: Trampoline\n\n  /**\n   * @param canUseSetImmediate is a boolean informing the\n   *        `GlobalScheduler` implementation that it can use the\n   *        nonstandard `setImmediate` for scheduling asynchronous\n   *        tasks without extra delays.\n   *\n   * @param em the {@link ExecutionModel} to use for\n   *        {@link Scheduler.executionModel}, should default to\n   *        {@link ExecutionModel.global}\n   *\n   * @param reporter is the reporter to use for reporting uncaught\n   *        errors, defaults to `console.error`\n   */\n  constructor(\n    canUseSetImmediate: boolean = false,\n    em: ExecutionModel = ExecutionModel.global.get(),\n    reporter?: (e: Throwable) => void) {\n\n    super(em)\n    if (reporter) this.reportFailure = reporter\n    this._trampoline = new Trampoline(this.reportFailure)\n    // tslint:disable:strict-type-predicates\n    this._useSetImmediate = (canUseSetImmediate || false) && (typeof setImmediate === \"function\")\n\n    this.executeAsync = this._useSetImmediate\n      ? r => setImmediate(safeRunnable(r, this.reportFailure))\n      : r => setTimeout(safeRunnable(r, this.reportFailure))\n  }\n\n  /* istanbul ignore next */\n  executeAsync(runnable: () => void): void {\n    /* istanbul ignore next */\n    throw new NotImplementedError(\"Constructor of GlobalScheduler wasn't executed\")\n  }\n\n  trampoline(runnable: () => void): void {\n    return this._trampoline.execute(runnable)\n  }\n\n  /* istanbul ignore next */\n  reportFailure(e: Throwable): void {\n    console.error(e)\n  }\n\n  currentTimeMillis(): number {\n    return Date.now()\n  }\n\n  scheduleOnce(delay: number | Duration, runnable: () => void): ICancelable {\n    const r = () => {\n      this.batchIndex = 0\n      try { runnable() } catch (e) { this.reportFailure(e) }\n    }\n\n    const ms = Math.max(0, Duration.of(delay).toMillis())\n    const task = setTimeout(r, ms)\n    return Cancelable.of(() => clearTimeout(task))\n  }\n\n  withExecutionModel(em: ExecutionModel) {\n    return new GlobalScheduler(this._useSetImmediate, em)\n  }\n}\n\n/**\n * The `TestScheduler` is a {@link Scheduler} type meant for testing purposes,\n * being capable of simulating asynchronous execution and the passage of time.\n *\n * Example:\n *\n * ```typescript\n * const s = new TestScheduler()\n *\n * s.execute(() => { console.log(\"Hello, world!\") })\n *\n * // Triggers actual execution\n * s.tick()\n *\n * // Simulating delayed execution\n * const task = s.scheduleOnce(Duration.seconds(10), () => {\n *   console.log(\"Hello, delayed!\")\n * })\n *\n * // We can cancel a delayed task if we want\n * task.cancel()\n *\n * // Or we can execute it by moving the internal clock forward in time\n * s.tick(Duration.seconds(10))\n * ```\n */\nexport class TestScheduler extends Scheduler {\n  private _reporter: (error: any) => void\n  private _trampoline: Trampoline\n  private _stateRef?: TestSchedulerState\n\n  /**\n   * @param reporter is an optional function that will be called\n   *        whenever {@link Scheduler.reportFailure} is invoked.\n   *\n   * @param em the {@link ExecutionModel} to use for\n   *        the {@link Scheduler.executionModel}, defaults to\n   *        `\"synchronous\"` for `TestScheduler`\n   */\n  constructor(reporter?: (error: any) => void, em: ExecutionModel = ExecutionModel.synchronous()) {\n    super(em)\n    this._reporter = reporter || (_ => {})\n    this._trampoline = new Trampoline(this.reportFailure.bind(this))\n  }\n\n  private _state() {\n    if (!this._stateRef) {\n      this._stateRef = new TestSchedulerState()\n      this._stateRef.updateTasks([])\n    }\n    return this._stateRef\n  }\n\n  /**\n   * Returns a list of triggered errors, if any happened during\n   * the {@link tick} execution.\n   */\n  public triggeredFailures(): Array<any> { return this._state().triggeredFailures }\n\n  /**\n   * Returns `true` if there are any tasks left to execute, `false`\n   * otherwise.\n   */\n  public hasTasksLeft(): boolean { return this._state().tasks.length > 0 }\n\n  public executeAsync(runnable: () => void): void {\n    this._state().tasks.push([this._state().clock, runnable])\n  }\n\n  public trampoline(runnable: () => void): void {\n    this._trampoline.execute(runnable)\n  }\n\n  public reportFailure(e: Throwable): void {\n    this._state().triggeredFailures.push(e)\n    this._reporter(e)\n  }\n\n  public currentTimeMillis(): number {\n    return this._state().clock\n  }\n\n  public scheduleOnce(delay: number | Duration, runnable: () => void): ICancelable {\n    const d = Math.max(0, Duration.of(delay).toMillis())\n    const state = this._state()\n    const scheduleAt = state.clock + d\n    const insertAt = state.tasksSearch(-scheduleAt)\n    const ref: [number, () => void] = [scheduleAt, runnable]\n    state.tasks.splice(insertAt, 0, ref)\n\n    return Cancelable.of(() => {\n      const filtered: Array<[number, () => void]> = []\n      for (const e of state.tasks) {\n        if (e !== ref) filtered.push(e)\n      }\n      state.updateTasks(filtered)\n    })\n  }\n\n  public withExecutionModel(em: ExecutionModel): TestScheduler {\n    const ec2 = new TestScheduler(this._reporter, em)\n    ec2._stateRef = this._state()\n    return ec2\n  }\n\n  /**\n   * Executes the current batch of tasks that are pending, relative\n   * to [currentTimeMillis]{@link TestScheduler.currentTimeMillis}.\n   *\n   * ```typescript\n   * const s = new TestScheduler()\n   *\n   * // Immediate execution\n   * s.executeAsync(() => console.log(\"A\"))\n   * s.executeAsync(() => console.log(\"B\"))\n   * // Delay with 1 second from now\n   * s.scheduleOnce(Duration.seconds(1), () => console.log(\"C\"))\n   * s.scheduleOnce(Duration.seconds(1), () => console.log(\"D\"))\n   * // Delay with 2 seconds from now\n   * s.scheduleOnce(Duration.seconds(2), () => console.log(\"E\"))\n   * s.scheduleOnce(Duration.seconds(2), () => console.log(\"F\"))\n   *\n   * // Actual execution...\n   *\n   * // Prints A, B\n   * s.tick()\n   * // Prints C, D\n   * s.tick(Duration.seconds(1))\n   * // Prints E, F\n   * s.tick(Duration.seconds(1))\n   * ```\n   *\n   * @param duration is an optional timespan to user for incrementing\n   * [currentTimeMillis]{@link TestScheduler.currentTimeMillis}, thus allowing\n   * the execution of tasks scheduled to execute with a delay.\n   *\n   * @return the number of executed tasks\n   */\n  public tick(duration?: number | Duration): number {\n    const state = this._state()\n    let toExecute = []\n    let jumpMs = Duration.of(duration || 0).toMillis()\n    let executed = 0\n\n    while (true) {\n      const peek = state.tasks.length > 0\n        ? state.tasks[state.tasks.length - 1]\n        : undefined\n\n      if (peek && peek[0] <= state.clock) {\n        toExecute.push(state.tasks.pop())\n      } else if (toExecute.length > 0) {\n        // Executing current batch, randomized\n        while (toExecute.length > 0) {\n          const index = Math.floor(Math.random() * toExecute.length)\n          const elem = toExecute[index] as any\n          try {\n            toExecute.splice(index, 1)\n            this.batchIndex = 0\n            elem[1]()\n          } catch (e) {\n            this.reportFailure(e)\n          } finally {\n            executed += 1\n          }\n        }\n      } else if (jumpMs > 0) {\n        const nextTaskJump = peek && (peek[0] - state.clock) || jumpMs\n        const add = Math.min(nextTaskJump, jumpMs)\n        state.clock += add\n        jumpMs -= add\n      } else {\n        break\n      }\n    }\n    return executed\n  }\n\n  /**\n   * Executes the task that's at the top of the stack, in case we\n   * have a task to execute that doesn't require a jump in time.\n   *\n   * ```typescript\n   * const ec = new TestScheduler()\n   *\n   * ec.execute(() => console.log(\"A\"))\n   * ec.execute(() => console.log(\"B\"))\n   *\n   * // Prints B\n   * ec.tickOne()\n   * // Prints A\n   * ec.tickOne()\n   * ```\n   */\n  public tickOne(): boolean {\n    const state = this._state()\n    const peek = state.tasks.length > 0\n      ? state.tasks[state.tasks.length - 1]\n      : undefined\n\n    if (!peek || peek[0] > state.clock) return false\n    this._state().tasks.pop()\n    this.batchIndex = 0\n    try { peek[1]() } catch (e) { this.reportFailure(e) }\n    return true\n  }\n}\n\nclass TestSchedulerState {\n  public clock: number\n  public triggeredFailures: Array<any>\n  public tasks: Array<[number, () => void]>\n  public tasksSearch: (search: number) => number\n\n  constructor() {\n    this.clock = 0\n    this.triggeredFailures = []\n    this.updateTasks([])\n  }\n\n  updateTasks(tasks: Array<[number, () => void]>) {\n    this.tasks = tasks\n    this.tasksSearch = arrayBSearchInsertPos(this.tasks, e => -e[0])\n  }\n}\n\n/**\n * Internal, reusable [[GlobalScheduler]] reference.\n *\n * @Hidden\n */\nconst globalSchedulerRef = new GlobalScheduler(true)\n\n/**\n * Internal utility wrapper a runner in an implementation that\n * reports errors with the provided `reporter` callback.\n *\n * @Hidden\n */\nfunction safeRunnable(r: () => void, reporter: (error: any) => void): () => void {\n  return () => { try { r() } catch (e) { reporter(e) } }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Try, Success, Failure, Option, Some, None, Either, Left, Right,\n  IllegalStateError, IllegalArgumentError, TimeoutError, Throwable\n} from \"funfix-core\"\n\nimport { Scheduler } from \"./scheduler\"\nimport { Duration } from \"./time\"\nimport { ICancelable, Cancelable, ChainedCancelable, DummyCancelable } from \"./cancelable\"\nimport { iterableToArray } from \"./internals\"\n\n/**\n * `IPromiseLike` represents objects that have a `then` method complying with\n * the [Promises/A+](https://promisesaplus.com/) specification.\n */\nexport interface IPromiseLike<T> {\n  /**\n   * Attaches callbacks for the resolution and/or rejection of the promise.\n   *\n   * See [MDN: Promise.then]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then}.\n   *\n   * @param onFulfilled The callback to execute when the promise is resolved.\n   * @param onRejected The callback to execute when the promise is rejected.\n   *\n   * @returns A promise for the completion of which ever callback is executed.\n   */\n  then(onFulfilled?: (value: T) => any, onRejected?: (reason: Throwable) => any): IPromiseLike<any>\n}\n\n/**\n * A `Future` represents a value which may or may not *currently* be available, but will be\n * available at some point, or an exception if the operation producing the result fails.\n *\n * `Future<A>` is a Promise-like alternative data type, that's cancelable and lawful,\n * inspired by Scala's `Future[A]`.\n *\n * You can easily build futures out of functions, that will execute asynchronously\n * (e.g. not on the current call stack) by means of `Future.of`:\n *\n * ```typescript\n * Future.of(() => 1 + 1)\n * ```\n *\n * Such computations use the [[Scheduler.global]] reference for execution, which\n * can be overridden, many times in the function call, being an optional parameter\n * (e.g. in `Future.of`), or in the local context, because it is exposed as a\n * [[DynamicRef]], which allows for localised overrides:\n *\n * ```typescript\n * import { Scheduler, GlobalScheduler, Future } from \"funfix\"\n *\n * // Custom Scheduler reference that we want to use\n * const ec = new GlobalScheduler(false)\n *\n * Future.of(() => x + y, ec)\n *\n * // ... is equivalent with ...\n *\n * Scheduler.global.bind(ec, () => {\n *   Future.of(() => x + y)\n * })\n * ```\n *\n * To create a `Future` out of an actual asynchronous computation, you can\n * use `Future.create`. Here's an example that takes a function and executes\n * it with an initial delay, returning a cancelable `Future`:\n *\n * ```typescript\n * import { Scheduler, Future, Try, Duration, Cancelable } from \"funfix\"\n *\n * const delay = <A>(d: Duration, f: () => A, ec: Scheduler = Scheduler.global.get()) =>\n *   Future.create<A>(\n *     cb => {\n *       const task = ec.scheduleOnce(d, () => cb(Try.of(f)))\n *\n *       return Cancelable.of(() => {\n *         console.warn(\"Delayed task was cancelled\")\n *         task.cancel()\n *       })\n *     },\n *     ec\n *   )\n * ```\n *\n * Normally you can `await` on functions returning `Future<A>` values:\n *\n * ```typescript\n * async function asyncSample(n: number): Promise<number> {\n *   let sum = 0\n *   for (let i = 0; i < n; i++) {\n *     sum += await Future.of(() => i)\n *   }\n *   return sum\n * }\n * ```\n *\n * Such functions do need to return a `Promise`, because JavaScript\n * generates code that uses `Promise`'s constructor. But a `Future`\n * is \"thenable\", so you can await on functions returning `Future`\n * just fine.\n */\nexport abstract class Future<A> implements IPromiseLike<A>, ICancelable {\n  /**\n   * Reference to the current {@link Scheduler} available for subsequent\n   * data transformations. Can be set in `Future`'s constructors, or by\n   * transforming the source by {@link withScheduler}.\n   *\n   * Protected, because it shouldn't be public API, being meant for\n   * `Future` implementations.\n   *\n   * @protected\n   */\n  protected readonly _scheduler: Scheduler\n\n  /**\n   * Reference to the current {@link ICancelable} available for\n   * subsequent data transformations.\n   *\n   * Protected, because it shouldn't be public API, being meant for\n   * `Future` implementations.\n   *\n   * @protected\n   */\n  protected _cancelable?: ICancelable\n\n  /**\n   * Extracts the completed value for this `Future`, returning `Some(result)`\n   * if this `Future` is already complete or `None` in case the `Future` wasn't\n   * completed yet.\n   *\n   * ```typescript\n   * const f1 = Future.of(() => 1)\n   *\n   * // Given the async execution of `Future.of`, the immediate invocations of\n   * // `value()` will yield `None`, but after complete it will yield\n   * // `Some(Success(1))`\n   * f1.value()\n   *\n   * const f2 = Future.raise(new DummyError())\n   *\n   * // Immediately yields Some(Failure(DummyError))\n   * f2.value()\n   * ```\n   */\n  abstract value(): Option<Try<A>>\n\n  /**\n   * Given a callback, calls it with this `Future`'s result when that result\n   * is ready.\n   *\n   * The execution of this callback is always trampolined (for already completed\n   * futures), or asynchronous, which means that modeling loops based on it is\n   * memory safe.\n   *\n   * ```typescript\n   * Future.of(() => \"John\").complete(r => {\n   *   r.fold(\n   *    error => console.info(\"Error: \" + error),\n   *    success => console.info(\"Hello, \" + John)\n   *   )\n   * })\n   * ```\n   */\n  abstract onComplete(f: (a: Try<A>) => void): void\n\n  /**\n   * In case this `Future` isn't complete, then send it a cancel signal.\n   *\n   * Depending on the computation that will complete this future, its execution\n   * might be interrupted.\n   *\n   * Execution has the same properties of {@link ICancelable}, being idempotent\n   * (calling it multiple times has the same effect as calling it once).\n   *\n   * In order to create a cancelable `Future`, use {@link Future.create}.\n   */\n  abstract cancel(): void\n\n  /**\n   * Sets the {@link Scheduler} reference that's going to get used for\n   * subsequent data transformations.\n   *\n   * `Future` references have a {@link Scheduler} reference attached at build\n   * time, that's going to get used for data transformations. This method\n   * returns a new `Future` reference that's going to mirror the source,\n   * but that's going to use the given `Scheduler` for subsequent operations\n   * like `map`, `flatMap`, `transformWith`, etc.\n   *\n   * ```typescript\n   * const ec1 = new GlobalScheduler(true)\n   *\n   * // The default Scheduler is global (that second parameter is optiona)\n   * const f1 = Future.create(f, ec1)\n   *\n   * // The `f1` future is going to get executed by `ec1`, however\n   * // this subsequent `flatMap` is getting evaluated by `ec2`\n   * const ec2 = new GlobalScheduler(false)\n   * const f2 = f1.withScheduler(ec2).flatMap(x => Future.pure(x * 2))\n   * ```\n   *\n   * When no `Scheduler` is specified, the default is assumed to be\n   * {@link Scheduler.global}.\n   *\n   * @param ec is the scheduler that's going to get used asynchronous execution\n   *        of subsequent operations\n   */\n  abstract withScheduler(ec: Scheduler): Future<A>\n\n  /**\n   * Transforms the source, regardless if the result is a failure or a success.\n   *\n   * This function is a combination of {@link flatMap} and {@link recoverWith},\n   * being the (type safe) alternative to JavaScript's\n   * [then]{@link IPromiseLike.then} from the\n   * [Promises/A+](https://promisesaplus.com/) specification.\n   *\n   * NOTE: in Funfix these fold-like methods, by convention, take as the\n   * first parameter the function that transforms the failure (the left),\n   * whereas the second parameter is the function that transforms the\n   * successful result (the right). Think of `Either<Error, A>`.\n   *\n   * ```typescript\n   * const randomInt = (max: number) =>\n   *   Future.of(() => {\n   *     const n = Math.random() * max\n   *     n & n\n   *   })\n   *\n   * const randomEvenInt = (max: number) =>\n   *   randomInt(max).transformWith(\n   *     err => Future.pure(9),\n   *     value => (\n   *       // retry until we have an even value\n   *       value % 2 == 0 ? Future.pure(value) : randomEvenInt()\n   *     )\n   *   )\n   * ```\n   *\n   * Also see {@link transform}.\n   *\n   * @param failure is the function that's going to get executed in case the\n   *        source signals a failure\n   *\n   * @param success is the function that's going to get executed in case the\n   *        source signals a successful result\n   */\n  abstract transformWith<B>(failure: (e: Throwable) => Future<B>, success: (a: A) => Future<B>): Future<B>\n\n  /**\n   * Transforms the sources, regardless if the result is a failure or a success.\n   *\n   * This function is a combination of {@link map} and {@link recover},\n   * being the (type safe) alternative to JavaScript's\n   * [then]{@link IPromiseLike.then} from the\n   * [Promises/A+](https://promisesaplus.com/) specification.\n   *\n   * Example:\n   *\n   * ```typescript\n   * import { Left, Right } from \"funfix\"\n   *\n   * // Expose errors by lifting them to an Either<Error, A>\n   * future.transform<Either<Throwable, A>>(Left, Right)\n   * ```\n   *\n   * Also see {@link transformWith}.\n   *\n   * @param failure is the function that's going to get executed in case the\n   *        source signals a failure\n   *\n   * @param success is the function that's going to get executed in case the\n   *        source signals a successful result\n   */\n  transform<B>(failure: (e: Throwable) => B, success: (a: A) => B): Future<B> {\n    return this.transformWith(\n      e => Future.pure(failure(e), this._scheduler),\n      a => Future.pure(success(a), this._scheduler))\n  }\n\n  /**\n   * Exposes underlying errors by lifting both successful and failed\n   * results into an `Either` value.\n   *\n   * Given that errors are short-circuiting the processing of {@link flatMap}\n   * chains, this method is useful for exposing errors such that you can\n   * `flatMap` over them.\n   *\n   * ```typescript\n   * const f: Future<number> = Future.raise(new DummyError)\n   *\n   * // Yields a successful Left(DummyError) on completion\n   * const fe: Future<Either<Throwable, number>> = f.attempt()\n   *\n   * // Yields a Right(1) on completion\n   * const fr: Future<Either<Throwable, number>> = Future.pure(1).attempt()\n   * ```\n   */\n  attempt(): Future<Either<Throwable, A>> {\n    return this.transform<Either<Throwable, A>>(Left, Right)\n  }\n\n  /**\n   * Chains asynchronous operations.\n   *\n   * Creates a new future by applying a function to the successful result of\n   * the source and returns the result of the function as the new future.\n   * If this future is completed with an exception then the new future will\n   * also contain this exception.\n   *\n   * This operation is the monadic bind (e.g. `Monad.flatMap`).\n   *\n   * ```typescript\n   * const fa = Future.of(() => 3)\n   * const fb = Future.of(() => 5)\n   *\n   * // Yields 3 + 5\n   * fa.flatMap(a => fb.map(b => a + b))\n   * ```\n   */\n  flatMap<B>(f: (a: A) => Future<B>): Future<B> {\n    return this.transformWith(Future.raise, f)\n  }\n\n  /**\n   * Given a mapping function, transforms the successful result of the source.\n   *\n   * If the source is completed with an exception, then the new future will\n   * also be completed in an error.\n   *\n   * This operation is the functor map (e.g. `Functor.map`).\n   *\n   * ```typescript\n   * const f = Future.of(() => \"The future\")\n   *\n   * const g = f.map(x => x + \" is now!\")\n   * ```\n   */\n  map<B>(f: (a: A) => B): Future<B> {\n    return this.transformWith(Future.raise,\n      a => Future.pure(f(a), this._scheduler))\n  }\n\n  /**\n   * Creates a new future that will handle any matching throwable that this\n   * future might contain by assigning it a value of another future.\n   *\n   * If there is no match, or if this future contains a valid result then the\n   * new future will contain the same result.\n   *\n   * This operation is the equivalent of {@link flatMap} for handling errors.\n   * Also see {@link transformWith}, which can handle both successful results\n   * and failures.\n   *\n   * ```typescript\n   * const f = Future.of<number>(() => { throw new DummyError() })\n   *\n   * f.recoverWith(e => e instanceof DummyError\n   *   ? Future.pure(10) // Fallback\n   *   : Future.raise(e) // Re-throw\n   * )\n   * ```\n   */\n  recoverWith<AA>(f: (e: Throwable) => Future<AA>): Future<A | AA> {\n    return this.transformWith<A | AA>(f, Future.pure)\n  }\n\n  /**\n   *\n   *\n   * ```typescript\n   * const f = Future.of<number>(() => { throw new DummyError() })\n   *\n   * f.recover(e => {\n   *   if (e instanceof DummyError) return 10\n   *   // Don't re-throw exceptions like this, use `recoverWith` instead!\n   *   throw e\n   * })\n   * ```\n   */\n  recover<AA>(f: (e: Throwable) => AA): Future<A | AA> {\n    return this.transformWith<A | AA>(\n      e => Future.pure(f(e), this._scheduler),\n      a => Future.pure(a, this._scheduler))\n  }\n\n  then<TResult1, TResult2>(\n    onFulfilled?: ((value: A) => (IPromiseLike<TResult1> | TResult1)) | undefined | null,\n    onRejected?: ((reason: Throwable) => (IPromiseLike<TResult2> | TResult2)) | undefined | null): Future<TResult2 | TResult1> {\n\n    if (!onFulfilled && !onRejected) return this as any\n    const ec = this._scheduler\n    return this.transformWith(\n      promiseThen(onRejected, e => Future.raise(e, ec), ec),\n      promiseThen(onFulfilled, a => Future.pure(a, ec), ec)\n    ) as any\n  }\n\n  /**\n   * Transforms this `Future<A>` reference into a standard JavaScript `Promise<A>`\n   * reference.\n   *\n   * Normally a `Future` is \"thenable\", so JavaScript should have no problem\n   * working with it, however in certain contexts this conversion is useful for\n   * working with type definitions that don't recognize the structural typing\n   * defined by the Promises/A+ specification.\n   */\n  toPromise(): Promise<A> {\n    return new Promise<A>((resolve, reject) => {\n      this.onComplete(_ => _.fold(reject, resolve))\n    })\n  }\n\n  /**\n   * Delays signaling the result of this `Future` by the specified duration.\n   *\n   * It works for successful results:\n   *\n   * ```typescript\n   * const fa = Future.of(() => \"Alex\")\n   *\n   * // Delays the signaling by 1 second\n   * fa.delayResult(1000).flatMap\n   * ```\n   *\n   * And for failures as well:\n   *\n   * ```typescript\n   * Future.raise(new TimeoutError()).delayResult(1000)\n   * ```\n   *\n   * @param delay is the duration to wait before signaling the final result\n   */\n  delayResult(delay: number | Duration): Future<A> {\n    return this.transformWith(\n      err => Future.delayedTick(delay, this._scheduler).flatMap(_ => Future.raise(err, this._scheduler)),\n      a => Future.delayedTick(delay, this._scheduler).map(_ => a)\n    )\n  }\n\n  /**\n   * Returns a future that mirrors the source in case the result of the source\n   * is signaled within the required `after` duration, otherwise it\n   * fails with a `TimeoutError`, cancelling the source.\n   *\n   * ```typescript\n   * const fa = Future.of(() => 1).delayResult(10000)\n   *\n   * // Will fail with a TimeoutError\n   * fa.timeout(1000)\n   * ```\n   *\n   * @param after is the duration to wait until it triggers the timeout error\n   */\n  timeout(after: number | Duration): Future<A> {\n    // Creating the exception immediately, to get a good stack trace\n    const fb = Future.raise(new TimeoutError(Duration.of(after).toString()), this._scheduler)\n    return this.timeoutTo(after, () => fb)\n  }\n\n  /**\n   * Returns a future that mirrors the source in case the result of the source\n   * is signaled within the required `after` duration, otherwise it\n   * triggers the execution of the given `fallback` after the duration has\n   * passed, cancelling the source.\n   *\n   * This is literally the implementation of {@link Future.timeout}:\n   *\n   * ```typescript\n   * const fa = Future.of(() => 1).delayResult(10000)\n   *\n   * fa.timeoutTo(1000, () => Future.raise(new TimeoutError()))\n   * ```\n   *\n   * @param after is the duration to wait until it triggers the `fallback`\n   * @param fallback is a thunk generating a fallback `Future` to timeout to\n   */\n  timeoutTo<AA>(after: number | Duration, fallback: () => Future<AA>): Future<A | AA> {\n    const other = Future.delayedTick(after, this._scheduler).flatMap(_ => fallback())\n    const lst: Future<A | AA>[] = [this, other]\n    return Future.firstCompletedOf(lst, this._scheduler)\n  }\n\n  // Implements HK<F, A>\n  /** @hidden */ readonly _funKindF: Future<any>\n  /** @hidden */ readonly _funKindA: A\n\n  // Implements Constructor<T>\n  /** @hidden */ static readonly _funErasure: Future<any>\n\n  /**\n   * Given a function that executes immediately, executes it asynchronously\n   * and returns a `Future` that will complete when the result is ready.\n   *\n   * ```typescript\n   * const sum = (x: number, y: number) =>\n   *   Future.of(() => x + y)\n   * ```\n   *\n   * @param thunk is the function to execute asynchronously\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static of<A>(thunk: () => A, ec: Scheduler = Scheduler.global.get()): Future<A> {\n    const ref = FutureMaker.empty<A>(ec)\n    ec.executeAsync(() => ref.tryComplete(Try.of(thunk)))\n    return ref.future()\n  }\n\n  /**\n   * Lifts a pure value into the `Future` context, returning a `Future`\n   * reference that's already complete with the given value.\n   *\n   * This is the equivalent of `Promise.resolve(a)`.\n   *\n   * ```typescript\n   * const f: Future<number> = Future.pure(10)\n   *\n   * // Prints Success(10)\n   * f.onComplete(r => console.info(r))\n   * ```\n   *\n   * @param a is the value to lift in the `Future` context and that will\n   *        get signaled in `onComplete` callbacks\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static pure<A>(a: A, ec: Scheduler = Scheduler.global.get()): Future<A> {\n    return new PureFuture(Success(a), ec)\n  }\n\n  /**\n   * Lifts an error in the `Future` context, returning a `Future` reference\n   * that's already failed with the given error.\n   *\n   * This is the equivalent of `Promise.reject`.\n   *\n   * ```typescript\n   * const f: Future<number> = Future.raise(\"Oops!\")\n   *\n   * // Prints Failure(\"Oops!\")\n   * f.onComplete(r => console.info(r))\n   * ```\n   *\n   * @param e is the error to lift in the `Future` context and that will\n   *        get signaled as a failure in `onComplete` callbacks\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static raise(e: Throwable, ec: Scheduler = Scheduler.global.get()): Future<never> {\n    return new PureFuture(Failure(e), ec)\n  }\n\n  /**\n   * Given a side-effectful function that triggers an asynchronous computation,\n   * execute it and return a `Future` reference.\n   *\n   * The given `register` function will be invoked immediately to \"schedule\"\n   * the asynchronous callback, where the callback is the parameter injected in\n   * that function.\n   *\n   * The `register` function can optionally return a {@link ICancelable}\n   * reference that can get used to cancel the running asynchronous\n   * computation.\n   *\n   * Example:\n   *\n   * ```typescript\n   * import { Scheduler, Future, Try, Duration, Cancelable } from \"funfix\"\n   *\n   * const delay = <A>(d: Duration, f: () => A, ec: Scheduler = Scheduler.global.get()) =>\n   *   Future.create<A>(\n   *     cb => {\n   *       const task = ec.scheduleOnce(d, () => cb(Try.of(f)))\n   *\n   *       return Cancelable.of(() => {\n   *         console.warn(\"Delayed task was cancelled\")\n   *         task.cancel()\n   *       })\n   *     },\n   *     ec\n   *   )\n   * ```\n   *\n   * Note that by not returning a cancelable, the returned `Future` reference\n   * will NOT BE cancelable.\n   *\n   * ```typescript\n   * // This future is not cancelable, because we are not\n   * // returning a cancelable reference\n   * Future.create<number>(cb => {\n   *   setTimeout(1000, () => cb(Success(10)))\n   * })\n   * ```\n   *\n   * @param register is the side-effectful function that will get invoked\n   *        to build our `Future`, receiving a callback that's supposed to\n   *        get invoked (only once) when the asynchronous computation completes,\n   *        and that can optionally return a cancelable reference that can\n   *        get used to cancel the running computation\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static create<A>(register: (cb: (a: Try<A>) => void) => (ICancelable | void), ec: Scheduler = Scheduler.global.get()): Future<A> {\n    const ref = FutureMaker.empty<A>(ec)\n    try {\n      const cRef = register(ref.complete)\n      return ref.future(cRef || undefined)\n    } catch (e) {\n      return Future.raise(e, ec)\n    }\n  }\n\n  /**\n   * Returns a `Future` reference that's already completed with a `void` value.\n   *\n   * Alias for:\n   *\n   * ```typescript\n   * Future.pure(undefined)\n   * ```\n   *\n   * Note that the same reference is always returned, so this property holds:\n   *\n   * ```typescript\n   * Future.unit() === Future.unit()\n   * ```\n   */\n  static unit(ec: Scheduler = Scheduler.global.get()): Future<void> {\n    // Given that this reference is immutable once built for the given\n    // Scheduler, and that schedulers don't change that much, we are\n    // caching the reference in order to preserve memory\n    const ecAny = ec as any\n    let ref = ecAny[\"_funCache\"] && ecAny[\"_funCache\"][\"futureUnit\"]\n    if (!ref) {\n      ref = new PureFuture(Success(undefined), ec)\n      ecAny[\"_funCache\"] = ecAny[\"_funCache\"] || {}\n      ecAny[\"_funCache\"][\"futureUnit\"] = ref\n    }\n    return ref\n  }\n\n  /**\n   * Returns a `Future` that will complete after the given `delay`.\n   *\n   * This can be used to do delayed execution. For example:\n   *\n   * ```typescript\n   * Future.delayedTick(1000).flatMap(_ =>\n   *   Future.of(() => console.info(\"Hello!\"))\n   * )\n   * ```\n   *\n   * @param delay is the duration to wait before signaling the tick\n   * @param ec is the scheduler that will actually schedule the tick's execution\n   */\n  static delayedTick<A>(delay: number | Duration, ec: Scheduler = Scheduler.global.get()): Future<void> {\n    return Future.create<void>(cb => ec.scheduleOnce(delay, () => cb(Success(undefined))), ec)\n  }\n\n  /**\n   * Keeps calling `f` until it returns a `Right` value.\n   *\n   * Based on Phil Freeman's\n   * [[http://functorial.com/stack-safety-for-free/index.pdf Stack Safety for Free]].\n   *\n   * ```typescript\n   * const generate = () => {\n   *   const n = Math.random() * 1000\n   *   return n & n\n   * }\n   *\n   * // Keeps looping until an odd number is returned\n   * Future.tailRecM(0, a => Future.of(() => {\n   *   return a % 2 == 0 ? Left(generate()) : Right(a)\n   * })\n   * ```\n   *\n   * @param a is the initial seed\n   * @param f is the function that keeps being invoked with the previous\n   *          `Left(a)` value, until a `Right(b)` value is returned,\n   *          which will be the `onComplete` result of the `Future`\n   *          reference\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static tailRecM<A, B>(a: A, f: (a: A) => Future<Either<A, B>>, ec: Scheduler = Scheduler.global.get()): Future<B> {\n    // Recursive loop based on flatMap\n    return f(a).flatMap(r => {\n      if (r.isRight()) return Future.pure(r.get(), ec)\n      return Future.tailRecM(r.swap().get(), f, ec)\n    })\n  }\n\n  /**\n   * Transforms any `Promise`-like data type into a `Future`.\n   *\n   * ```typescript\n   * const p: Promise<number> = Promise.resolve(10)\n   *\n   * const f: Future<number> = Future.fromPromise(p)\n   * ```\n   *\n   * @param ref is the promise reference that we want to convert into a `Future`\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static fromPromise<A>(ref: IPromiseLike<A>, ec: Scheduler = Scheduler.global.get()): Future<A> {\n    if (ref instanceof Future)\n      return (ref as Future<A>).withScheduler(ec)\n    else\n      return Future.create<A>(\n        cb => { ref.then(value => cb(Success(value)),err => cb(Failure(err))) },\n        ec\n      )\n  }\n\n  /**\n   * Builds an already complete `Future` from a `Try` value.\n   *\n   * ```typescript\n   * import { Success, Failure, Future } from \"funfix\"\n   *\n   * // Already completed with 1\n   * const f1 = Future.fromTry(Success(1))\n   *\n   * // Already completed in error\n   * const f2 = Future.fromTry(Failure(\"err\"))\n   * ```\n   *\n   * @param value is the `Try` value to stream in `onComplete` listeners\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static fromTry<A>(value: Try<A>, ec: Scheduler = Scheduler.global.get()): Future<A> {\n    return new PureFuture(value, ec)\n  }\n\n  /**\n   * Creates a race condition between multiple futures, returning the result\n   * of the first one that completes, cancelling the rest.\n   *\n   * ```typescript\n   * const failure = Future.raise(new TimeoutError()).delayResult(2000)\n   *\n   * // Will yield 1\n   * const fa1 = Future.of(() => 1).delayResult(1000)\n   * Future.firstCompletedOf([fa1, failure])\n   *\n   * // Will yield a TimeoutError\n   * const fa2 = Future.of(() => 1).delayResult(10000)\n   * Future.firstCompletedOf([fa2, failure])\n   * ```\n   *\n   * @param list is the list of futures for which the race is started\n   * @param ec is the scheduler doing the needed scheduling and error reporting\n   *\n   * @return a future that will complete with the result of the first\n   *         future form the list to complete, the rest being cancelled\n   */\n  static firstCompletedOf<A>(list: Future<A>[] | Iterable<Future<A>>, ec: Scheduler = Scheduler.global.get()): Future<A> {\n    return futureFirstCompletedOf(list, ec)\n  }\n\n  /**\n   * Given a list of items, builds future results out of it with the specified\n   * mapping function and returns a new future that's going to be completed\n   * with the list of all generated results.\n   *\n   * This is the generic version of {@link Future.sequence}. Useful for\n   * processing futures in parallel, with the `parallelism` factor being\n   * configurable.\n   *\n   * Example:\n   *\n   * ```typescript\n   * const list = [1, 2, 3, 4]\n   *\n   * // Yields [2, 4, 6, 8]\n   * Future.traverse(list)(a => Future.pure(a * 2))\n   * // ... is equivalent to:\n   * Future.sequence(list.map(_ => _ * 2))\n   * ```\n   *\n   * Note that the given `list` is strictly processed, so no lazy behavior\n   * should be expected if an `Iterable` is given.\n   *\n   * But in comparison with {@link Future.sequence}, this builder has lazy\n   * behavior in applying the given mapping function. Coupled with the\n   * `parallelism` factor, this can be used to do batched processing:\n   *\n   * ```typescript\n   * const userIDs = [1, 2, 3, 4]\n   *\n   * // Make at most 2 requests in parallel:\n   * Future.traverse(userIDs, 2)(fetchUserDetails)\n   * ```\n   *\n   * @param list are the values that get fed in the generator function for\n   *        building a list of future results\n   *\n   * @param parallelism is the maximum number of futures that are going to\n   *        be processed in parallel, defaults to `Infinity`\n   *\n   * @param ec is an optional scheduler that's going to be used for scheduling\n   *        the needed asynchronous boundaries\n   *\n   * @return a function that takes as parameter a the generator function that's\n   *         going to map the given `list`, transforming it into a list of\n   *         futures, finally returning a future that's going to complete\n   *         with the list of all asynchronously generated results\n   */\n  static traverse<A>(list: A[] | Iterable<A>, parallelism: number = Infinity, ec: Scheduler = Scheduler.global.get()):\n    <B>(f: (a: A) => Future<B>) => Future<B[]> {\n\n    return <B>(f: (a: A) => Future<B>) =>\n      futureTraverse(list, f, parallelism, ec)\n  }\n\n  /**\n   * Asynchronously transforms a list of futures into a future of a list.\n   *\n   * The equivalent of `Promise.all`, this is the specialized version of\n   * {@link Future.traverse}.\n   *\n   * Contract:\n   *\n   * - the given `Iterable<Future<A>>` list is eagerly evaluated, transformed\n   *   from the start into an `Array<Future<A>>`, so don't expect laziness in\n   *   evaluating it\n   * - In case one of the future fails, then all other futures that are still\n   *   pending get cancelled\n   * - In case the returned future gets cancelled, then all in-progress futures\n   *   from that list get cancelled\n   *\n   * Sample:\n   *\n   * ```typescript\n   * const f1 = Future.of(() => 1)\n   * const f2 = Future.of(() => 2)\n   * const f3 = Future.of(() => 3)\n   *\n   * // Yields [1, 2, 3]\n   * const all: Future<number[]> = Future.sequence([f1, f2, f3])\n   * ```\n   */\n  static sequence<A>(list: Future<A>[] | Iterable<Future<A>>, ec: Scheduler = Scheduler.global.get()): Future<A[]> {\n    return futureSequence(list, ec)\n  }\n\n  /**\n   * Maps 2 `Future` values by the mapping function, returning a new\n   * `Future` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link Future.sequence} operation and as such\n   * on cancellation or failure all future values get cancelled.\n   *\n   * ```typescript\n   * const fa1 = Future.of(() => 1)\n   * const fa2 = Future.of(() => 2)\n   *\n   *\n   * // Yields Success(3)\n   * Future.map2(fa1, fa2, (a, b) => a + b)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Future.map2(fa1, Future.raise(\"error\"),\n   *   (a, b) => a + b\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map2`.\n   */\n  static map2<A1, A2, R>(\n    fa1: Future<A1>, fa2: Future<A2>, f: (a1: A1, a2: A2) => R,\n    ec: Scheduler = Scheduler.global.get()): Future<R> {\n\n    const fl: Future<any[]> = Future.sequence([fa1, fa2] as any[], ec)\n    return fl.map(lst => f(lst[0], lst[1]))\n  }\n\n  /**\n   * Maps 3 `Future` values by the mapping function, returning a new\n   * `Future` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link Future.sequence} operation and as such\n   * on cancellation or failure all future values get cancelled.\n   *\n   * ```typescript\n   * const fa1 = Future.of(() => 1)\n   * const fa2 = Future.of(() => 2)\n   * const fa3 = Future.of(() => 3)\n   *\n   *\n   * // Yields Success(6)\n   * Future.map3(fa1, fa2, fa3, (a, b, c) => a + b + c)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Future.map3(\n   *   fa1, fa2, Future.raise(\"error\"),\n   *   (a, b, c) => a + b + c\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map3`.\n   */\n  static map3<A1, A2, A3, R>(\n    fa1: Future<A1>, fa2: Future<A2>, fa3: Future<A3>,\n    f: (a1: A1, a2: A2, a3: A3) => R,\n    ec: Scheduler = Scheduler.global.get()): Future<R> {\n\n    const fl: Future<any[]> = Future.sequence([fa1, fa2, fa3] as any[], ec)\n    return fl.map(lst => f(lst[0], lst[1], lst[2]))\n  }\n\n  /**\n   * Maps 4 `Future` values by the mapping function, returning a new\n   * `Future` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link Future.sequence} operation and as such\n   * on cancellation or failure all future values get cancelled.\n   *\n   * ```typescript\n   * const fa1 = Future.of(() => 1)\n   * const fa2 = Future.of(() => 2)\n   * const fa3 = Future.of(() => 3)\n   * const fa4 = Future.of(() => 4)\n   *\n   * // Yields Success(10)\n   * Future.map4(fa1, fa2, fa3, fa4, (a, b, c, d) => a + b + c + d)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Future.map4(\n   *   fa1, fa2, fa3, Future.raise(\"error\"),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map4`.\n   */\n  static map4<A1, A2, A3, A4, R>(\n    fa1: Future<A1>, fa2: Future<A2>, fa3: Future<A3>, fa4: Future<A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R,\n    ec: Scheduler = Scheduler.global.get()): Future<R> {\n\n    const fl: Future<any[]> = Future.sequence([fa1, fa2, fa3, fa4] as any[], ec)\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3]))\n  }\n\n  /**\n   * Maps 5 `Future` values by the mapping function, returning a new\n   * `Future` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link Future.sequence} operation and as such\n   * on cancellation or failure all future values get cancelled.\n   *\n   * ```typescript\n   * const fa1 = Future.of(() => 1)\n   * const fa2 = Future.of(() => 2)\n   * const fa3 = Future.of(() => 3)\n   * const fa4 = Future.of(() => 4)\n   * const fa5 = Future.of(() => 5)\n   *\n   * // Yields Success(15)\n   * Future.map5(fa1, fa2, fa3, fa4, fa5,\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Future.map5(\n   *   fa1, fa2, fa3, fa4, Future.raise(\"error\"),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map5`.\n   */\n  static map5<A1, A2, A3, A4, A5, R>(\n    fa1: Future<A1>, fa2: Future<A2>, fa3: Future<A3>, fa4: Future<A4>, fa5: Future<A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R,\n    ec: Scheduler = Scheduler.global.get()): Future<R> {\n\n    const fl: Future<any[]> = Future.sequence([fa1, fa2, fa3, fa4, fa5] as any[], ec)\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3], lst[4]))\n  }\n\n  /**\n   * Maps 6 `Future` values by the mapping function, returning a new\n   * `Future` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link Future.sequence} operation and as such\n   * on cancellation or failure all future values get cancelled.\n   *\n   * ```typescript\n   * const fa1 = Future.of(() => 1)\n   * const fa2 = Future.of(() => 2)\n   * const fa3 = Future.of(() => 3)\n   * const fa4 = Future.of(() => 4)\n   * const fa5 = Future.of(() => 5)\n   * const fa6 = Future.of(() => 6)\n   *\n   * // Yields Success(21)\n   * Future.map6(\n   *   fa1, fa2, fa3, fa4, fa5, fa6,\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Future.map6(\n   *   fa1, fa2, fa3, fa4, fa5, Future.raise(\"error\"),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map6`.\n   */\n  static map6<A1, A2, A3, A4, A5, A6, R>(\n    fa1: Future<A1>, fa2: Future<A2>, fa3: Future<A3>, fa4: Future<A4>, fa5: Future<A5>, fa6: Future<A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R,\n    ec: Scheduler = Scheduler.global.get()): Future<R> {\n\n    const fl: Future<any[]> = Future.sequence([fa1, fa2, fa3, fa4, fa5, fa6] as any[], ec)\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3], lst[4], lst[5]))\n  }\n}\n\nclass PureFuture<A> extends Future<A> {\n  constructor(\n    private readonly _value: Try<A>,\n    protected readonly _scheduler: Scheduler) { super() }\n\n  cancel(): void {}\n  value(): Option<Try<A>> { return Some(this._value) }\n\n  withScheduler(ec: Scheduler): Future<A> {\n    if (this._scheduler === ec) return this\n    return new PureFuture(this._value, ec)\n  }\n\n  onComplete(f: (a: Try<A>) => void): void {\n    this._scheduler.executeBatched(() => f(this._value))\n  }\n\n  transformWith<B>(failure: (e: Throwable) => Future<B>, success: (a: A) => Future<B>): Future<B> {\n    return genericTransformWith(this, failure, success, this._scheduler)\n  }\n\n  toPromise(): Promise<A> {\n    return this._value.fold(e => Promise.reject(e), a => Promise.resolve(a))\n  }\n}\n\n/**\n * Internal state shared between {@link AsyncFuture} and\n * {@link FutureMaker}.\n *\n * @Hidden\n */\nclass AsyncFutureState<A> {\n  id: null | \"chained\" | \"complete\"\n  ref: null | ((a: Try<A>) => void)[] | AsyncFutureState<A> | Try<A>\n\n  constructor() {\n    this.id = null\n    this.ref = null\n  }\n\n  compressedRoot(): AsyncFutureState<A> {\n    let cursor: AsyncFutureState<A> = this\n    while (cursor.id === \"chained\") {\n      cursor = cursor.ref as AsyncFutureState<A>\n      this.ref = cursor\n    }\n    return cursor\n  }\n\n  value(): Option<Try<A>> {\n    switch (this.id) {\n      case null: return None\n      case \"complete\":\n        return Some(this.ref as Try<A>)\n      case \"chained\":\n        return this.compressedRoot().value()\n    }\n  }\n\n  tryComplete(r: Try<A>, ec: Scheduler): boolean {\n    switch (this.id) {\n      case null:\n        const xs = (this.ref as (null | ((a: Try<A>) => void)[]))\n        this.ref = r\n        this.id = \"complete\"\n        if (xs) {\n          for (let i = 0; i < xs.length; i++)\n            ec.executeBatched(() => xs[i](r))\n        }\n        return true\n\n      case \"complete\":\n        return false\n\n      case \"chained\":\n        const ref = (this.ref as AsyncFutureState<A>).compressedRoot()\n        const result = ref.tryComplete(r, ec)\n        this.id = \"complete\"\n        this.ref = result ? r : ref.value().get()\n        return result\n    }\n  }\n\n  chainTo(target: AsyncFutureState<A>, ec: Scheduler): void {\n    switch (this.id) {\n      case null:\n        const xs = (this.ref as (null | ((a: Try<A>) => void)[]))\n        this.id = \"chained\"\n        this.ref = target.compressedRoot()\n\n        if (xs && xs.length > 0) {\n          // Transferring all listeners to chained future\n          for (let i = 0; i < xs.length; i++)\n            target.onComplete(xs[i], ec)\n        }\n        break\n\n      case \"chained\":\n        this.compressedRoot().chainTo(target.compressedRoot(), ec)\n        break\n\n      case \"complete\":\n        target.tryComplete(this.ref as Try<A>, ec)\n        break\n    }\n  }\n\n  onComplete(f: (a: Try<A>) => void, ec: Scheduler): void {\n    switch (this.id) {\n      case null:\n        if (!this.ref) this.ref = [];\n        (this.ref as ((a: Try<A>) => void)[]).push(f)\n        break\n      case \"complete\":\n        // Forced async boundary\n        ec.executeBatched(() => f(this.ref as Try<A>))\n        break\n      case \"chained\":\n        (this.ref as AsyncFutureState<A>).onComplete(f, ec)\n        break\n    }\n  }\n}\n\n/**\n * Internal `Future` implementation that's the result of a\n * {@link FutureMaker.future}.\n *\n * @Hidden\n */\nclass AsyncFuture<A> extends Future<A> {\n  readonly _state: AsyncFutureState<A>\n  readonly _scheduler: Scheduler\n  _cancelable?: ICancelable\n\n  constructor(state: AsyncFutureState<A>, cRef: ICancelable | undefined, ec: Scheduler) {\n    super()\n    this._state = state\n    this._scheduler = ec\n    if (cRef) this._cancelable = cRef\n  }\n\n  value(): Option<Try<A>> {\n    return this._state.value()\n  }\n\n  onComplete(f: (a: Try<A>) => void): void {\n    return this._state.onComplete(f, this._scheduler)\n  }\n\n  cancel(): void {\n    if (this._cancelable) {\n      try { this._cancelable.cancel() }\n      finally { delete this._cancelable }\n    }\n  }\n\n  withScheduler(ec: Scheduler): Future<A> {\n    if (this._scheduler === ec) return this\n    return new AsyncFuture(this._state, this._cancelable, ec)\n  }\n\n  transformWith<B>(failure: (e: Throwable) => Future<B>, success: (a: A) => Future<B>): Future<B> {\n    return genericTransformWith(this, failure, success, this._scheduler, this._cancelable)\n  }\n}\n\n/**\n * A write interface for {@link Future} to use when implementing\n * producers.\n *\n * This would be the equivalent of the now deprecated `Deferred`\n * data type in JavaScript.\n *\n * Example:\n *\n * ```typescript\n * import { Future, FutureMaker, Scheduler, Success } from \"funfix\"\n *\n * const ec = Scheduler.global.get()\n * const m = FutureMaker.empty<number>()\n *\n * // The producer\n * ec.scheduleOnce(1000, () => m.complete(Success(1)))\n *\n * // The future that will eventually complete when\n * // `m.complete` gets called\n * const f: Future<number> = maker.future()\n * ```\n */\nexport class FutureMaker<A> {\n  private readonly _state: AsyncFutureState<A>\n  private readonly _scheduler: Scheduler\n\n  private constructor(state: AsyncFutureState<A>, ec: Scheduler) {\n    this[\"_state\"] = state\n    this._scheduler = ec\n  }\n\n  /**\n   * Tries to complete this future builder either with a successful\n   * value or with a failure.\n   *\n   * This function can be used in concurrent races where multiple\n   * actors compete for completing the same `FutureMaker`.\n   *\n   * ```typescript\n   * const m = FutureMaker.empty<number>()\n   *\n   * m.tryComplete(Success(1)) //=> true\n   * m.tryComplete(Success(2)) //=> false\n   *\n   * m.future() //=> Yields 1\n   * ```\n   *\n   * In case you have a guarantee that the completion only\n   * happens once, then usage of {@link complete} is recommended.\n   *\n   * @return `false` in case the `FutureMaker` has been already\n   *         completed, or `true` otherwise\n   */\n  readonly tryComplete: (result: Try<A>) => boolean =\n    r => this[\"_state\"].tryComplete(r, this._scheduler)\n\n  /**\n   * Completes this `FutureMaker` either with a successful value or\n   * with a failure, but throws an exception if this maker was\n   * already completed.\n   *\n   * Due to throwing exceptions, this function is recommended for\n   * usage in cases where there's a guarantee that the completion\n   * of the `FutureMaker` is attempted only once.\n   *\n   * ```typescript\n   * const m = FutureMaker.empty<number>()\n   *\n   * m.complete(Success(1))\n   *\n   * m.complete(Success(2)) //=> throws IllegalStateError\n   * ```\n   *\n   * In case you have a concurrent race, see {@link tryComplete}\n   * for a version that does not throw exceptions.\n   */\n  readonly complete: (result: Try<A>) => void =\n    r => {\n      if (!this.tryComplete(r))\n        throw new IllegalStateError(\"Cannot complete a FutureMaker twice!\")\n    }\n\n  /**\n   * Alias for `tryComplete(Success(value))`.\n   *\n   * See {@link tryComplete}.\n   */\n  trySuccess(value: A): boolean {\n    return this.tryComplete(Success(value))\n  }\n\n  /**\n   * Alias for `complete(Success(value))`.\n   *\n   * See {@link complete}.\n   */\n  success(value: A): void {\n    return this.complete(Success(value))\n  }\n\n  /**\n   * Alias for `tryComplete(Failure(error))`.\n   *\n   * See {@link tryComplete}.\n   */\n  tryFailure(error: Throwable): boolean {\n    return this.tryComplete(Failure(error))\n  }\n\n  /**\n   * Alias for `complete(Failure(value))`.\n   *\n   * See {@link complete}.\n   */\n  failure(error: Throwable): void {\n    return this.complete(Failure(error))\n  }\n\n  /**\n   * Chains this to `target` such that any subsequent operations on\n   * this future maker is reflected on `target`.\n   *\n   * ```typescript\n   * const main = FutureMaker.empty<number>()\n   * const child = FutureMaker.empty<number>()\n   *\n   * // Now all operations on `child` will be redirected to `main`\n   * child.chainTo(main)\n   *\n   * // Completing `child` will complete `main`\n   * child.complete(Success(1))\n   *\n   * main.future() //=> Yields 1\n   * child.future() //=> Yields 1\n   * ```\n   *\n   * The purpose of this method is the same as with\n   * {@link ChainedCancelable}, to be used in pieces of logic where\n   * the chaining of `onComplete` calls creates a memory leaks,\n   * chaining being used to get rid of such chains.\n   *\n   * This method is being used in the implementation of\n   * {@link Future.flatMap} for example to make it memory safe.\n   *\n   * CREDITS: this was inspired by Scala's `scala.concurrent.Scala`\n   * implementation.\n   */\n  chainTo(target: FutureMaker<A>): void {\n    this[\"_state\"].chainTo(target[\"_state\"], this._scheduler)\n  }\n\n  /**\n   * Creates and returns a {@link Future} that will complete when this\n   * future maker is completed.\n   *\n   * ```typescript\n   * const m = FutureMaker.empty<number>()\n   *\n   * // Creates a simple future, no cancellation logic:\n   * m.future()\n   *\n   * // Creates a future with baked in cancellation logic:\n   * const cRef = Cancelable.of(() => console.log(\"Cancelled!\"))\n   * m.future(cRef)\n   * ```\n   *\n   * @param cancelable is an optional reference that can indicate\n   *        cancellation logic to be baked into the created future\n   */\n  future(cancelable?: ICancelable): Future<A> {\n    switch (this._state.id) {\n      case \"complete\":\n        return new PureFuture(this[\"_state\"].ref as Try<A>, this._scheduler)\n      default:\n        return new AsyncFuture(this[\"_state\"], cancelable, this._scheduler)\n    }\n  }\n\n  /**\n   * Returns a new `FutureMaker` that mirrors the state of the source,\n   * but that uses the given {@link Scheduler} reference for\n   * managing the required async boundaries.\n   *\n   * The given `Scheduler` reference is used for inserting async\n   * boundaries when the registered listeners are triggered when\n   * [.complete]{@link complete} is called or for data transformations\n   * executed on the future references returned by\n   * [.future]{@link FutureMaker.future}.\n   *\n   * See {@link Future.withScheduler}.\n   */\n  withScheduler(ec: Scheduler): FutureMaker<A> {\n    if (this._scheduler === ec) return this\n    return new FutureMaker(this._state, ec)\n  }\n\n  /**\n   * Returns an empty `FutureMaker` reference awaiting completion.\n   *\n   * This is the builder that one should use for building\n   * `FutureMaker` instances, since the default constructor is not\n   * exposed due to it exposing internal state.\n   */\n  static empty<A>(ec: Scheduler = Scheduler.global.get()): FutureMaker<A> {\n    return new FutureMaker(new AsyncFutureState(), ec)\n  }\n\n  /**\n   * Returns an already completed {@link FutureMaker} reference.\n   *\n   * Example:\n   *\n   * ```typescript\n   * const m = FutureMaker.completed(Success(1))\n   *\n   * m.future() // Yields 1\n   *\n   * m.complete(Success(2)) // Throws IllegalStateError\n   * ```\n   *\n   * If all you need is a `Future`, then use {@link Future.fromTry}\n   * instead.\n   */\n  static completed<A>(value: Try<A>, ec: Scheduler = Scheduler.global.get()): FutureMaker<A> {\n    const state = new AsyncFutureState<A>()\n    state.id = \"complete\"\n    state.ref = value\n    return new FutureMaker(state, ec)\n  }\n}\n\n/**\n * Internal, common `transformWith` implementation.\n *\n * @Hidden\n */\nfunction genericTransformWith<A, B>(\n  self: Future<A>,\n  failure: (e: Throwable) => Future<B>,\n  success: (a: A) => Future<B>,\n  scheduler: Scheduler,\n  cancelable?: ICancelable): Future<B> {\n\n  const defer = FutureMaker.empty<B>(scheduler)\n  const cRef = new ChainedCancelable(cancelable)\n\n  self.onComplete(tryA => {\n    let fb: Future<B>\n    try {\n      fb = tryA.fold(failure, success)\n    } catch (e) {\n      fb = Future.raise(e)\n    }\n\n    // If the resulting Future is already completed, there's no point\n    // in treating it as being cancelable\n    if (fb.value().isEmpty()) {\n      const fbb = fb as any\n      const cNext = fbb._cancelable\n\n      if (cNext && cNext instanceof ChainedCancelable) {\n        // Trick we are doing to get rid of extraneous memory\n        // allocations, otherwise we can leak memory\n        cNext.chainTo(cRef)\n      } else if (cNext && !(cNext instanceof DummyCancelable)) {\n        cRef.update(cNext)\n      }\n    } else {\n      // GC purposes\n      cRef.clear()\n    }\n\n    if (fb instanceof AsyncFuture) {\n      fb._state.chainTo(defer[\"_state\"] as AsyncFutureState<B>, scheduler)\n    } else {\n      (fb as Future<B>).onComplete(defer.tryComplete)\n    }\n  })\n\n  return defer.future(cRef)\n}\n\n/**\n * Internal, reusable function used in the implementation of {@link Future.then}.\n *\n * @Hidden\n */\nfunction promiseThen<T, R>(\n  f: ((t: T) => IPromiseLike<R> | R) | undefined | null,\n  alt: (t: T) => Future<T>,\n  ec: Scheduler):\n  ((value: T) => Future<R | T>) {\n\n  return value => {\n    if (typeof f !== \"function\") return alt(value)\n\n    const fb = f(value)\n    if (!fb) return Future.pure(value, ec)\n\n    if (typeof (fb as any).then === \"function\")\n      return Future.fromPromise(fb as IPromiseLike<R>, ec)\n    else\n      return Future.pure(fb as R, ec)\n  }\n}\n\n/** @Hidden */\nfunction futureCancelAll<A>(list: Future<A>[], ec: Scheduler, skip: number = -1): void {\n  const errors = []\n  for (let i = 0; i < list.length; i++) {\n    if (i !== skip)\n      try { list[i].cancel() } catch (e) { errors.push(e) }\n  }\n\n  if (errors.length > 0) {\n    for (const e of errors) ec.reportFailure(e)\n  }\n}\n\n/** @Hidden */\nfunction futureIterableToArray<A>(values: Future<A>[] | Iterable<Future<A>>, ec: Scheduler): Future<A>[] {\n  if (!values) return []\n  if (Object.prototype.toString.call(values) === \"[object Array]\")\n    return values as Future<A>[]\n\n  const arr: Future<A>[] = []\n  try {\n    const cursor = values[Symbol.iterator]()\n\n    while (true) {\n      const item = cursor.next()\n      if (item.value) arr.push(item.value)\n      if (item.done) break\n    }\n\n    return arr\n  } catch (e) {\n    futureCancelAll(arr, ec)\n    throw e\n  }\n}\n\n/**\n * Internal implementation for `Future.sequence`.\n *\n * @Hidden\n */\nfunction futureSequence<A>(values: Future<A>[] | Iterable<Future<A>>, ec: Scheduler): Future<A[]> {\n  return Future.create<A[]>(cb => {\n    try {\n      // This can throw, handling error below\n      const futures = futureIterableToArray(values, ec)\n      // Short-circuit in case the list is empty, otherwise the\n      // futureSequenceLoop fails (must be non-empty as an invariant)\n      if (futures.length === 0) return cb(Success([]))\n      const cRef = Cancelable.of(() => futureCancelAll(futures, ec))\n\n      // Creating race condition\n      let isDone = false\n      let finishedCount = 0\n      let finalArray: A[] = []\n\n      for (let index = 0; index < futures.length; index++) {\n        const fi = index\n        const fa = futures[index]\n\n        fa.onComplete(result => {\n          finishedCount += 1\n\n          if (result.isSuccess()) {\n            if (!isDone) {\n              finalArray[fi] = result.get()\n              isDone = finishedCount === futures.length\n              if (isDone) cb(Success(finalArray))\n            }\n          } else {\n            if (!isDone) {\n              isDone = true\n              cRef.cancel()\n              cb(result as any)\n            } else {\n              ec.reportFailure(result.failed().get())\n            }\n          }\n        })\n      }\n\n      return cRef\n    } catch (e) {\n      // If an error happens here, it means the conversion from iterable to\n      // array failed, and the futures we've seen are already canceled\n      cb(Failure(e))\n    }\n  }, ec)\n}\n\n/**\n * Internal implementation for `Future.firstCompletedOf`.\n *\n * @Hidden\n */\nfunction futureFirstCompletedOf<A>(iterable: Future<A>[] | Iterable<Future<A>>, ec: Scheduler): Future<A> {\n  return Future.create<A>(cb => {\n    try {\n      // This can throw, handling error below\n      const futures = futureIterableToArray(iterable, ec)\n      // Short-circuit in case the list is empty, otherwise the\n      // futureSequenceLoop fails (must be non-empty as an invariant)\n      if (futures.length === 0) return cb(Failure(new IllegalArgumentError(\"empty list of futures\")))\n\n      // Creating race condition\n      let isDone = false\n\n      for (let index = 0; index < futures.length; index++) {\n        const fi = index\n        const fa = futures[index]\n\n        fa.onComplete(result => {\n          if (!isDone) {\n            isDone = true\n            futureCancelAll(futures, ec, fi)\n            cb(result)\n          } else if (result.isFailure()) {\n            ec.reportFailure(result.failed().get())\n          }\n        })\n      }\n\n      return Cancelable.of(() => futureCancelAll(futures, ec))\n    } catch (e) {\n      // If an error happens here, it means the conversion from iterable to\n      // array failed, and the futures we've seen are already canceled\n      cb(Failure(e))\n    }\n  }, ec)\n}\n\n/**\n * Internal implementation for `Future.traverse`.\n *\n * @Hidden\n */\nfunction futureTraverse<A, B>(\n  list: A[] | Iterable<A>,\n  f: (a: A) => Future<B>,\n  parallelism: number,\n  ec: Scheduler): Future<B[]> {\n\n  if (parallelism <= 0) {\n    throw new IllegalArgumentError(`parallelism <= 0`)\n  }\n  return Future.of(() => iterableToArray(list), ec)\n    .flatMap(values => futureTraverseLoop(values, f, parallelism, ec, 0, []))\n}\n\n/** @Hidden */\nfunction futureTraverseLoop<A, B>(\n  list: A[],\n  f: (a: A) => Future<B>,\n  parallelism: number,\n  ec: Scheduler,\n  index: number,\n  result: B[]): Future<B[]> {\n\n  if (index >= list.length) return Future.pure(result, ec)\n  let batch: Future<B>[] = []\n  let length = 0\n\n  try {\n    while (index < list.length && length < parallelism) {\n      batch.push(f(list[index++]))\n      length += 1\n    }\n\n    const fa = Future.sequence(batch, ec).map(b => {\n      for (let i = 0; i < b.length; i++) result.push(b[i])\n    })\n\n    if (index >= list.length) {\n      // We are done, signal final result\n      return fa.map(_ => result)\n    } else {\n      // Continue with the next batch\n      return fa.flatMap(_ => futureTraverseLoop(list, f, parallelism, ec, index, result))\n    }\n  } catch (e) {\n    // Batch generation triggered an error\n    futureCancelAll(batch, ec)\n    return Future.raise(e)\n  }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * We don't need the full power of JS's iterators, just a way\n * to traverse data structures.\n *\n * @hidden\n */\nexport interface IteratorLike<A> {\n  next(): { done: boolean, value?: A }\n}\n\n/**\n * Reusable empty `IteratorLike` reference.\n *\n * @hidden\n */\nexport const emptyIteratorRef: IteratorLike<never> =\n  { next: () => ({ done: true }) }\n\n/**\n * Given an array or an `Iterable`, returns a simple iterator type\n * that we can use to traverse the given list lazily.\n *\n * @hidden\n */\nexport function iteratorOf<A>(list: A[] | Iterable<A>): IteratorLike<A> {\n  if (!list) return emptyIteratorRef\n  if (Object.prototype.toString.call(list) !== \"[object Array]\")\n    return list[Symbol.iterator]()\n\n  const array = list as A[]\n  if (array.length === 0) return emptyIteratorRef\n\n  let cursor = 0\n  const next = () => {\n    const value = array[cursor++]\n    const done = cursor >= array.length\n    return { done, value }\n  }\n\n  return { next }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Either, Throwable } from \"funfix-core\"\nimport {\n  IteratorLike,\n  iteratorOf\n} from \"./internals\"\n\n/**\n * Eval is a monad which controls evaluation.\n *\n * This type wraps a value (or an expression that produces a value)\n * and can produce it on command via the {@link Eval.get get()}\n * method.\n *\n * There are three basic evaluation strategies:\n *\n *  - {@link Eval.now}: for describing strict values, evaluated\n *    immediately\n *  - {@link Eval.once}: evaluated only once when the value is needed,\n *    with the result memoized (cached) for subsequent evaluations\n *  - [[Eval.always]]: evaluated every time the value is needed,\n *    being equivalent to a function\n *\n * Eval supports stack-safe lazy computation via the {@link Eval.map .map}\n * and {@link Eval.flatMap .flatMap} methods, which use an internal\n * trampoline to avoid stack overflows. Computation done within `map`\n * and `flatMap` is always done lazily, even when applied to an\n * `Eval.now` instance.\n *\n * Use `map` and `flatMap` to chain computation, and use `get()` to\n * get the result when needed. It is also not good style to create\n * `Eval` instances whose computation involves calling `get()` on\n * another `Eval` instance -- this can defeat the trampolining and\n * lead to stack overflows.\n *\n * ```typescript\n * const rndInt = Eval.of(() => {\n *   const nr = Math.random() * 1000000\n *   return nr & nr\n * })\n *\n * const evenInt = () =>\n *   rndInt.flatMap(int => {\n *     if (i % 2 == 0)\n *       return Eval.now(i)\n *     else // Retry until we have an even number!\n *       return evenInt()\n *   })\n *\n * const cached = evenInt().memoize()\n *\n * // Nothing happens until now, this triggers the\n * // actual evaluation:\n * const n: number = cached.get()\n * ```\n *\n * ## Versus IO\n *\n * For dealing with lazy evaluation, the other alternative is\n * the {@link IO} data type.\n *\n * Differences between `Eval` and `IO`:\n *\n * 1. `IO` is capable of describing asynchronous computations as well\n * 2. `IO` is capable of error handling (it implements `MonadError`),\n *    whereas `Eval` does not provide error handling capabilities,\n *    being meant to be used for pure expressions (it implements\n *    `Comonad`, which is incompatible with `MonadError`)\n *\n * So if you need error handling capabilities\n * (i.e. `MonadError<Throwable, ?>`), or if you need to describe\n * asynchronous processes, then {@link IO} is for you. `Eval`\n * is a simpler data type with the sole purpose of controlling the\n * evaluation of expressions (i.e. strict versus lazy).\n *\n * ## Credits\n *\n * This type is inspired by `cats.Eval` from\n * {@link http://typelevel.org/cats/|Typelevel Cats}\n * and by `monix.eval.Coeval` from {@link https://monix.io|Monix}.\n *\n * @final\n */\nexport class Eval<A> {\n  /**\n   * Evaluates the source `Eval` and returns the result.\n   *\n   * ```typescript\n   * const ref = Eval.always(() => 100 * 2)\n   *\n   * ref.get() // 200\n   * ```\n   */\n  get(): A { return evalRunLoop(this) }\n\n  /**\n   * Returns a new `Eval` that applies the mapping function to the\n   * successful result emitted by the source.\n   *\n   * ```typescript\n   * Eval.now(111).map(_ => _ * 2).get() // 222\n   * ```\n   */\n  map<B>(f: (a: A) => B): Eval<B> {\n    return new FlatMap(this, (a: A) => Eval.now(f(a)))\n  }\n\n  /**\n   * Creates a new `Eval` by applying a function to the successful\n   * result of the source, and returns a new instance equivalent to\n   * the result of the function.\n   *\n   * ```typescript\n   * const rndInt = Eval.of(() => {\n   *   const nr = Math.random() * 1000000\n   *   return nr & nr\n   * })\n   *\n   * const evenInt = () =>\n   *   rndInt.flatMap(int => {\n   *     if (i % 2 == 0)\n   *       return Eval.now(i)\n   *     else // Retry until we have an even number!\n   *       return evenInt()\n   *   })\n   * ```\n   */\n  flatMap<B>(f: (a: A) => Eval<B>): Eval<B> {\n    return new FlatMap(this, f)\n  }\n\n  /**\n   * Alias for {@link Eval.flatMap .flatMap}.\n   */\n  chain<B>(f: (a: A) => Eval<B>): Eval<B> {\n    return this.flatMap(f)\n  }\n\n  /**\n   * Memoizes (caches) the result of the source on the first\n   * evaluation and reuses it on subsequent invocations of `get()`.\n   *\n   * The resulting `Eval` will be idempotent, meaning that\n   * evaluating it multiple times will have the same effect\n   * as evaluating it once.\n   */\n  memoize(): Eval<A> {\n    switch (this._funADType) {\n      case \"now\":\n      case \"once\":\n        return this\n      case \"always\":\n        return new Once(this.get)\n      default:\n        return new Once(() => this.get())\n    }\n  }\n\n  /**\n   * Returns a new `Eval` that upon evaluation will execute the given\n   * function for the generated element, transforming the source into\n   * an `Eval<void>`.\n   *\n   * Similar in spirit with normal {@link Eval.forEach .forEach},\n   * but lazy, as obviously nothing gets executed at this point.\n   */\n  forEachL(cb: (a: A) => void): Eval<void> {\n    return this.map(cb)\n  }\n\n  /**\n   * Triggers the evaluation of the source, executing the given\n   * function for the generated element.\n   *\n   * The application of this function has strict behavior, as the\n   * coeval is immediately executed.\n   */\n  forEach(cb: (a: A) => void): void {\n    this.forEachL(cb).get()\n  }\n\n  /**\n   * Identifies the `Eval` reference type, useful for debugging and\n   * for pattern matching in the implementation.\n   *\n   * @hidden\n   */\n  readonly _funADType: \"now\" | \"always\" | \"once\" | \"suspend\" | \"flatMap\"\n\n  // Implements HK<F, A>\n  /** @hidden */ readonly _funKindF: Eval<any>\n  /** @hidden */ readonly _funKindA: A\n\n  // Implements Constructor<T>\n  /** @hidden */ static readonly _funErasure: Eval<any>\n\n  /**\n   * Alias for {@link Eval.always}.\n   */\n  static of<A>(thunk: () => A): Eval<A> {\n    return Eval.always(thunk)\n  }\n\n  /**\n   * Lifts a value into the `Eval` context.\n   *\n   * Alias for {@link Eval.now}.\n   */\n  static pure<A>(value: A): Eval<A> { return Eval.now(value) }\n\n  /**\n   * Returns an `Eval` that on execution is always successful,\n   * emitting the given strict value.\n   */\n  static now<A>(value: A): Eval<A> { return new Now(value) }\n\n  /**\n   * Shorthand for `now(undefined as void)`, always returning\n   * the same reference as optimization.\n   */\n  static unit(): Eval<void> {\n    return evalUnitRef\n  }\n\n  /**\n   * Promote a `thunk` function to an `Eval`, catching exceptions in\n   * the process.\n   *\n   * Note that since `Eval` is not memoized by global, this will\n   * recompute the value each time the `Eval` is executed.\n   */\n  static always<A>(thunk: () => A): Eval<A> {\n    return new Always(thunk)\n  }\n\n  /**\n   * Promote a `thunk` function to a `Coeval` that is memoized on the\n   * first evaluation, the result being then available on subsequent\n   * evaluations.\n   *\n   * Note this is equivalent with:\n   *\n   * ```typescript\n   * Eval.always(thunk).memoize()\n   * ```\n   */\n  static once<A>(thunk: () => A): Eval<A> {\n    return new Once(thunk)\n  }\n\n  /**\n   * Promote a `thunk` function generating `Eval` results to an `Eval`\n   * of the same type.\n   */\n  static suspend<A>(thunk: () => Eval<A>): Eval<A> {\n    return new Suspend(thunk)\n  }\n\n  /**\n   * Promote a `thunk` function generating `Eval` results to an `Eval`\n   * of the same type.\n   *\n   * Alias for {@link Eval.suspend}.\n   */\n  static defer<A>(thunk: () => Eval<A>): Eval<A> {\n    return Eval.suspend(thunk)\n  }\n\n  /**\n   * Keeps calling `f` until a `Right(b)` is returned.\n   *\n   * Based on Phil Freeman's\n   * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.\n   *\n   * Described in `FlatMap.tailRecM`.\n   */\n  static tailRecM<A, B>(a: A, f: (a: A) => Eval<Either<A, B>>): Eval<B> {\n    return f(a).flatMap(either => {\n      if (either.isRight()) {\n        return Eval.now(either.get())\n      } else {\n        // Recursive call\n        return Eval.tailRecM(either.swap().get(), f)\n      }\n    })\n  }\n\n  /**\n   * Transforms a list of `Eval` values into an `Eval` of a list.\n   *\n   * Sample:\n   *\n   * ```typescript\n   * const io1 = Eval.of(() => 1)\n   * const io2 = Eval.of(() => 2)\n   * const io3 = Eval.of(() => 3)\n   *\n   * // Yields [1, 2, 3]\n   * const all: Eval<number[]> = Eval.sequence([f1, f2, f3])\n   * ```\n   */\n  static sequence<A>(list: Eval<A>[] | Iterable<Eval<A>>): Eval<A[]> {\n    return evalSequence(list)\n  }\n\n  /**\n   * Maps 2 `Eval` values by the mapping function, returning a new\n   * `Eval` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * ```typescript\n   * const fa1 = Eval.of(() => 1)\n   * const fa2 = Eval.of(() => 2)\n   *\n   *\n   * // Yields Success(3)\n   * Eval.map2(fa1, fa2, (a, b) => a + b)\n   * ```\n   *\n   * This operation is the `Applicative.map2`.\n   */\n  static map2<A1, A2, R>(\n    fa1: Eval<A1>, fa2: Eval<A2>,\n    f: (a1: A1, a2: A2) => R): Eval<R> {\n\n    const fl: Eval<any[]> = Eval.sequence([fa1, fa2] as any[])\n    return fl.map(lst => f(lst[0], lst[1]))\n  }\n\n  /**\n   * Maps 3 `Eval` values by the mapping function, returning a new\n   * `Eval` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * ```typescript\n   * const fa1 = Eval.of(() => 1)\n   * const fa2 = Eval.of(() => 2)\n   * const fa3 = Eval.of(() => 3)\n   *\n   *\n   * // Yields Success(6)\n   * Eval.map3(fa1, fa2, fa3, (a, b, c) => a + b + c)\n   * ```\n   */\n  static map3<A1, A2, A3, R>(\n    fa1: Eval<A1>, fa2: Eval<A2>, fa3: Eval<A3>,\n    f: (a1: A1, a2: A2, a3: A3) => R): Eval<R> {\n\n    const fl: Eval<any[]> = Eval.sequence([fa1, fa2, fa3] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2]))\n  }\n\n  /**\n   * Maps 4 `Eval` values by the mapping function, returning a new\n   * `Eval` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * ```typescript\n   * const fa1 = Eval.of(() => 1)\n   * const fa2 = Eval.of(() => 2)\n   * const fa3 = Eval.of(() => 3)\n   * const fa4 = Eval.of(() => 4)\n   *\n   * // Yields Success(10)\n   * Eval.map4(fa1, fa2, fa3, fa4, (a, b, c, d) => a + b + c + d)\n   * ```\n   */\n  static map4<A1, A2, A3, A4, R>(\n    fa1: Eval<A1>, fa2: Eval<A2>, fa3: Eval<A3>, fa4: Eval<A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R): Eval<R> {\n\n    const fl: Eval<any[]> = Eval.sequence([fa1, fa2, fa3, fa4] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3]))\n  }\n\n  /**\n   * Maps 5 `Eval` values by the mapping function, returning a new\n   * `Eval` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * ```typescript\n   * const fa1 = Eval.of(() => 1)\n   * const fa2 = Eval.of(() => 2)\n   * const fa3 = Eval.of(() => 3)\n   * const fa4 = Eval.of(() => 4)\n   * const fa5 = Eval.of(() => 5)\n   *\n   * // Yields Success(15)\n   * Eval.map5(fa1, fa2, fa3, fa4, fa5,\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   * ```\n   */\n  static map5<A1, A2, A3, A4, A5, R>(\n    fa1: Eval<A1>, fa2: Eval<A2>, fa3: Eval<A3>, fa4: Eval<A4>, fa5: Eval<A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R): Eval<R> {\n\n    const fl: Eval<any[]> = Eval.sequence([fa1, fa2, fa3, fa4, fa5] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3], lst[4]))\n  }\n\n  /**\n   * Maps 6 `Eval` values by the mapping function, returning a new\n   * `Eval` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * ```typescript\n   * const fa1 = Eval.of(() => 1)\n   * const fa2 = Eval.of(() => 2)\n   * const fa3 = Eval.of(() => 3)\n   * const fa4 = Eval.of(() => 4)\n   * const fa5 = Eval.of(() => 5)\n   * const fa6 = Eval.of(() => 6)\n   *\n   * // Yields Success(21)\n   * Eval.map6(\n   *   fa1, fa2, fa3, fa4, fa5, fa6,\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   * ```\n   */\n  static map6<A1, A2, A3, A4, A5, A6, R>(\n    fa1: Eval<A1>, fa2: Eval<A2>, fa3: Eval<A3>, fa4: Eval<A4>, fa5: Eval<A5>, fa6: Eval<A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R): Eval<R> {\n\n    const fl: Eval<any[]> = Eval.sequence([fa1, fa2, fa3, fa4, fa5, fa6] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3], lst[4], lst[5]))\n  }\n}\n\n/**\n * `Now` is an internal `Eval` state that wraps any strict\n * value in an `Eval` reference. Returned by [[Eval.now]].\n *\n * @private\n */\nclass Now<A> extends Eval<A> {\n  readonly _funADType: \"now\" = \"now\"\n\n  /**\n   * @param value is the value that's going to be returned\n   * when `get()` is called.\n   */\n  constructor(public readonly value: A) { super() }\n\n  get(): A { return this.value }\n  toString(): string { return `Eval.now(${JSON.stringify(this.value)})` }\n}\n\n/**\n * Reusable reference, to use in {@link Eval.unit}.\n *\n * @private\n */\nconst evalUnitRef: Now<void> = new Now(undefined)\n\n/**\n * `Once` is an internal `Eval` state that executes the given `thunk`\n * only once, upon calling `get()` and then memoize its result for\n * subsequent invocations.\n *\n * Returned by [[Eval.once]].\n *\n * @private\n */\nclass Once<A> extends Eval<A> {\n  readonly _funADType: \"once\" = \"once\"\n\n  private _thunk: () => A\n  private _cache?: Throwable | A\n  private _isError?: boolean\n\n  constructor(thunk: () => A) {\n    super()\n    this._thunk = thunk\n  }\n\n  get(): A {\n    if (this._thunk) {\n      try {\n        this._cache = this._thunk()\n        this._isError = false\n      } catch (e) {\n        this._cache = e\n        this._isError = true\n      }\n      // GC purposes\n      delete this._thunk\n    }\n\n    if (this._isError) throw this._cache\n    return this._cache as A\n  }\n\n  toString(): string { return `Eval.once([thunk])` }\n}\n\n/**\n * `Always` is an internal `Eval` state that executes the given `thunk`\n * every time the call to `get()` happens. Returned by [[Eval.always]].\n *\n * @private\n */\nclass Always<A> extends Eval<A> {\n  readonly _funADType: \"always\" = \"always\"\n\n  constructor(thunk: () => A) {\n    super()\n    this.get = thunk\n  }\n\n  toString(): string { return `Eval.always([thunk])` }\n}\n\n/**\n * `Suspend` is an internal `Eval` state that represents a factory of\n * `Eval` values. Returned by [[Eval.suspend]].\n *\n * @private\n */\nclass Suspend<A> extends Eval<A> {\n  readonly _funADType: \"suspend\" = \"suspend\"\n\n  constructor(public readonly thunk: () => Eval<A>) { super() }\n  toString(): string { return `Eval.suspend([thunk])` }\n}\n\n/**\n * `FlatMap` is an internal `Eval` state that represents a\n * [[Eval.flatMap .flatMap]], [[Eval.map .map]], [[Eval.transform .transform]]\n * or a [[Eval.transformWith .transformWith]] operation, all of them\n * being expressed with this state.\n *\n * @private\n */\nclass FlatMap<A, B> extends Eval<B> {\n  readonly _funADType: \"flatMap\" = \"flatMap\"\n\n  constructor(\n    public readonly source: Eval<A>,\n    public readonly f: (a: A) => Eval<B>) { super() }\n\n  toString(): string {\n    return `Eval#FlatMap(${String(this.source)}, [function])`\n  }\n}\n\n/** @hidden */\ntype Current = Eval<any>\n/** @hidden */\ntype Bind = ((a: any) => Eval<any>)\n/** @hidden */\ntype CallStack = Array<Bind>\n\n/** @hidden */\nfunction _popNextBind(bFirst: Bind | null, bRest: CallStack | null): Bind | undefined | null {\n  if (bFirst) return bFirst\n  if (bRest && bRest.length > 0) return bRest.pop()\n  return null\n}\n\n/** @hidden */\nfunction evalRunLoop<A>(start: Eval<A>): A {\n  let current: Current = start\n  let bFirst: Bind | null = null\n  let bRest: CallStack | null = null\n\n  while (true) {\n    switch (current._funADType) {\n      case \"now\":\n        const now = current as Now<A>\n        const bind = _popNextBind(bFirst, bRest)\n        if (!bind) return now.value\n        bFirst = null\n        current = bind(now.value)\n        break\n\n      case \"always\":\n      case \"once\":\n        current = new Now(current.get())\n        break\n\n      case \"suspend\":\n        current = (current as Suspend<A>).thunk()\n        break\n\n      case \"flatMap\":\n        if (bFirst) {\n          if (!bRest) bRest = []\n          bRest.push(bFirst)\n        }\n        const fm = current as FlatMap<any, any>\n        bFirst = fm.f\n        current = fm.source\n        break\n    }\n  }\n}\n\n/**\n * Implementation for `Eval.sequence`.\n * @hidden\n */\nfunction evalSequence<A>(list: Eval<A>[] | Iterable<Eval<A>>): Eval<A[]> {\n  return Eval.of(() => iteratorOf(list))\n    .flatMap(cursor => evalSequenceLoop([], cursor))\n}\n\n/**\n * Recursive loop that goes through the given `cursor`, element by\n * element, gathering the results of all generated `Eval` elements.\n *\n * @hidden\n */\nfunction evalSequenceLoop<A>(acc: A[], cursor: IteratorLike<Eval<A>>): Eval<A[]> {\n  while (true) {\n    const elem = cursor.next()\n    const isDone = elem.done\n\n    if (elem.value) {\n      const io: Eval<A> = elem.value\n      return io.flatMap(a => {\n        acc.push(a)\n        if (isDone) return Eval.pure(acc)\n        return evalSequenceLoop(acc, cursor)\n      })\n    } else {\n      /* istanbul ignore else */\n      if (isDone) return Eval.pure(acc)\n    }\n  }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Either,\n  Try,\n  Success,\n  Failure,\n  Throwable,\n  TimeoutError,\n  Option, Some, None\n} from \"funfix-core\"\n\nimport {\n  ICancelable,\n  Cancelable,\n  StackedCancelable,\n  Scheduler,\n  Future, ExecutionModel,\n  execInternals, Duration\n} from \"funfix-exec\"\n\nimport {\n  IteratorLike,\n  iteratorOf\n} from \"./internals\"\n\n/**\n * `IO` represents a specification for a possibly lazy or\n * asynchronous computation, which when executed will produce an `A`\n * as a result, along with possible side-effects.\n *\n * Compared with Funfix's\n * [Future](https://funfix.org/api/exec/classes/future.html) (see\n * [funfix-exec](https://funfix.org/api/exec/)) or JavaScript's\n * [Promise](https://promisesaplus.com/),\n * `IO` does not represent a running computation or a value detached\n * from time, as `IO` does not execute anything when working with its\n * builders or operators and it does not submit any work into the\n * [Scheduler](https://funfix.org/api/exec/classes/scheduler.html) or any\n * run-loop for execution, the execution eventually\n * taking place only after {@link IO.run} is called and not before\n * that.\n *\n * In order to understand `IO`, here's the design space:\n *\n * |                  | Strict                     | Lazy                               |\n * |------------------|:--------------------------:|:----------------------------------:|\n * | **Synchronous**  | `A`                        | `() => A`                          |\n * |                  |                            | [Eval&lt;A&gt;]{@link Eval}        |\n * | **Asynchronous** | `(Try<A> => void) => void` | `() => ((Try<A> => void) => void)` |\n * |                  | `Future<A>` / `Promise`    | [IO&lt;A&gt;]{@link IO}            |\n *\n * JavaScript is a language (and runtime) that's strict by default,\n * meaning that expressions are evaluated immediately instead of\n * being evaluated on a by-need basis, like in Haskell.\n *\n * So a value `A` is said to be strict. To turn an `A` value into a lazy\n * value, you turn that expression into a parameterless function of\n * type `() => A`, also called a \"thunk\".\n *\n * A [Future](https://funfix.org/api/exec/classes/future.html) is a\n * value that's produced by an asynchronous process, but it is said\n * to have strict behavior, meaning that when you receive a `Future`\n * reference, whatever process that's supposed to complete the\n * `Future` has probably started already. This goes for\n * [JavaScript's Promise](https://promisesaplus.com) as well.\n *\n * But there are cases where we don't want strict values, but lazily\n * evaluated ones. In some cases we want functions, or\n * `Future`-generators. Because we might want better handling of\n * parallelism, or we might want to suspend *side effects*. As\n * without suspending *side effects* we don't have *referential\n * transparency*, which really helps with reasoning about the code,\n * being the essence of *functional programming*.\n *\n * This `IO` type is thus the complement to `Future`, a lazy, lawful\n * monadic type that can describe any side effectful action, including\n * asynchronous ones, also capable of suspending side effects.\n *\n * ## Getting Started\n *\n * To build an `IO` from a parameterless function returning a value\n * (a thunk), we can use `IO.of`:\n *\n * ```typescript\n * const hello = IO.of(() => \"Hello \")\n * const world = IO.of(() => \"World!\")\n * ```\n *\n * Nothing gets executed yet, as `IO` is lazy, nothing executes\n * until you trigger [run]{@link IO.run} on it.\n *\n * To combine `IO` values we can use `map` and `flatMap`, which\n * describe sequencing and this time is in a very real sense because\n * of the laziness involved:\n *\n * ```typescript\n * const sayHello = hello\n *   .flatMap(h => world.map(w => h + w))\n *   .map(console.info)\n * ```\n *\n * This `IO` reference will trigger a side effect on evaluation, but\n * not yet. To make the above print its message:\n *\n * ```typescript\n * const f: Future<void> = sayHello.run()\n *\n * //=> Hello World!\n * ```\n *\n * The returned type is a\n * [Future](https://funfix.org/api/exec/classes/future.html), a value\n * that can be completed already or might be completed at some point\n * in the future, once the running asynchronous process finishes.\n * It's the equivalent of JavaScript's `Promise`, only better and\n * cancelable, see next topic.\n *\n * ## Laziness\n *\n * The fact that `IO` is lazy, whereas `Future` and `Promise` are not\n * has real consequences. For example with `IO` you can do this:\n *\n * ```typescript\n * function retryOnFailure<A>(times: number, io: IO<A>): IO<A> {\n *   return source.recoverWith(err => {\n *     // No more retries left? Re-throw error:\n *     if (times <= 0) return IO.raise(err)\n *     // Recursive call, yes we can!\n *     return retryOnFailure(times - 1, io)\n *       // Adding 500 ms delay for good measure\n *       .delayExecution(500)\n *   })\n * }\n * ```\n *\n * `Future` being a strict value-wannabe means that the actual value\n * gets \"memoized\" (means cached), however `IO` is basically a function\n * that can be repeated for as many times as you want. `IO` can also\n * do memoization of course:\n *\n * ```typescript\n * io.memoize()\n * ```\n *\n * The difference between this and just calling `run()` is that\n * `memoize()` still returns an `IO` and the actual memoization\n * happens on the first `run()` (with idempotency guarantees of\n * course).\n *\n * But here's something else that `Future` or your favorite\n * `Promise`-like data type cannot do:\n *\n * ```typescript\n * io.memoizeOnSuccess()\n * ```\n *\n * This keeps repeating the computation for as long as the result is a\n * failure and caches it only on success. Yes we can!\n *\n * ### Parallelism\n *\n * Because of laziness, invoking {@link IO.sequence} will not work like\n * it does for `Future.sequence` or `Promise.all`, the given `IO` values\n * being evaluated one after another, in *sequence*, not in *parallel*.\n * If you want parallelism, then you need to use {@link IO.gather} and\n * thus be explicit about it.\n *\n * This is great because it gives you the possibility of fine tuning the\n * execution. For example, say you want to execute things in parallel,\n * but with a maximum limit of 30 tasks being executed in parallel.\n * One way of doing that is to process your list in batches.\n *\n * This sample assumes you have [lodash](https://lodash.com/) installed,\n * for manipulating our array:\n *\n * ```typescript\n * import * as _ from \"lodash\"\n * import { IO } from \"funfix\"\n *\n * // Some array of IOs, you come up with something good :-)\n * const list: IO<string>[] = ???\n *\n * // Split our list in chunks of 30 items per chunk,\n * // this being the maximum parallelism allowed\n * const chunks = _.chunks(list, 30)\n * // Specify that each batch should process stuff in parallel\n * const batchedIOs = _.map(chunks, chunk => IO.gather(chunk))\n * // Sequence the batches\n * const allBatches = IO.sequence(batchedIOs)\n *\n * // Flatten the result, within the context of IO\n * const all: IO<string[]> =\n *   allBatches.map(batches => _.flatten(batches))\n * ```\n *\n * Note that the built `IO` reference is just a specification at this point,\n * or you can view it as a function, as nothing has executed yet, you need\n * to call {@link IO.run .run} explicitly.\n *\n * ## Cancellation\n *\n * The logic described by an `IO` task could be cancelable, depending\n * on how the `IO` gets built. This is where the `IO`-`Future`\n * symbiosis comes into play.\n *\n * Futures can also be canceled, in case the described computation can\n * be canceled. When describing `IO` tasks with `IO.of` nothing can be\n * cancelled, since there's nothing about a plain function that you\n * can cancel, but, we can build cancelable tasks with\n * {@link IO.async}:\n *\n * ```typescript\n * import { Cancelable, Success, IO } from \"funfix\"\n *\n * const delayedHello = IO.async((scheduler, callback) => {\n *   const task = scheduler.scheduleOnce(1000, () => {\n *     console.info(\"Delayed Hello!\")\n *     // Signaling successful completion\n *     // (\"undefined\" inhabits type \"void\")\n *     callback(Success(undefined))\n *   })\n *\n *   return Cancelable.of(() => {\n *     console.info(\"Cancelling!\")\n *     task.cancel()\n *   })\n * })\n * ```\n *\n * The sample above prints a message with a delay, where the delay\n * itself is scheduled with the injected `Scheduler`. The `Scheduler`\n * is in fact an optional parameter to {@link IO.run} and if one\n * isn't explicitly provided, then `Scheduler.global` is assumed.\n *\n * This action can be cancelled, because it specifies cancellation\n * logic. If we wouldn't return an explicit `Cancelable` there,\n * then cancellation wouldn't work. But for this `IO` reference\n * it does:\n *\n * ```typescript\n * // Triggering execution, which sends a task to execute by means\n * // of JavaScript's setTimeout (under the hood):\n * const f: Future<void> = delayedHello.run()\n *\n * // If we change our mind before the timespan has passed:\n * f.cancel()\n * ```\n *\n * Also, given an `IO` task, we can specify actions that need to be\n * triggered in case of cancellation:\n *\n * ```typescript\n * const io = IO.of(() => console.info(\"Hello!\"))\n *   .executeForked()\n *\n * io.doOnCancel(IO.of(() => {\n *   console.info(\"A cancellation attempt was made!\")\n * })\n *\n * const f: Future<void> = io.run()\n *\n * // Note that in this case cancelling the resulting Future\n * // will not stop the actual execution, since it doesn't know\n * // how, but it will trigger our on-cancel callback:\n *\n * f.cancel()\n * //=> A cancellation attempt was made!\n * ```\n *\n * ## Note on the ExecutionModel\n *\n * `IO` is conservative in how it introduces async boundaries.\n * Transformations like `map` and `flatMap` for example will default\n * to being executed on the current call stack on which the\n * asynchronous computation was started. But one shouldn't make\n * assumptions about how things will end up executed, as ultimately\n * it is the implementation's job to decide on the best execution\n * model. All you are guaranteed is asynchronous execution after\n * executing `run`.\n *\n * Currently the default `ExecutionModel` specifies batched execution\n * by default and `IO` in its evaluation respects the injected\n * `ExecutionModel`. If you want a different behavior, you need to\n * execute the `IO` reference with a different scheduler.\n *\n * In order to configure a different execution model, this config\n * can be injected by means of a custom scheduler:\n *\n * ```typescript\n * import { Scheduler, ExecutionModel } from \"funfix\"\n *\n * const ec = Scheduler.global.get()\n *   .withExecutionModel(ExecutionModel.alwaysAsync())\n *\n * // ...\n * io.run(ec)\n * ```\n *\n * Or you can configure an `IO` reference to execute with a certain\n * execution model that overrides the configuration of the injected\n * scheduler, by means of {@link IO.executeWithModel}:\n *\n * ```typescript\n * io.executeWithModel(ExecutionModel.batched(256))\n * ```\n *\n * ## Versus Eval\n *\n * For dealing with lazy evaluation, the other alternative is\n * the {@link Eval} data type.\n *\n * Differences between `Eval` and `IO`:\n *\n * 1. `IO` is capable of describing asynchronous computations as well\n * 2. `IO` is capable of error handling (it implements `MonadError`),\n *    whereas `Eval` does not provide error handling capabilities,\n *    being meant to be used for pure expressions (it implements\n *    `Comonad`, which is incompatible with `MonadError`)\n * 3. You cannot rely on `IO` to produce a value immediately, since\n *    we cannot block threads on top of JavaScript engines\n *\n * So if you need error handling capabilities\n * (i.e. `MonadError<Throwable, ?>`), or if you need to describe\n * asynchronous processes, then `IO` is for you. {@link Eval}\n * is a simpler data type with the sole purpose of controlling the\n * evaluation of expressions (i.e. strict versus lazy).\n *\n * ## Credits\n *\n * This type is inspired by `cats.effect.IO` from\n * {@link http://typelevel.org/cats/|Typelevel Cats},\n * by `monix.eval.Task` from {@link https://monix.io|Monix}, by\n * `scalaz.effect.IO` from [Scalaz](https://github.com/scalaz/scalaz),\n * which are all inspired by Haskell's `IO` data type.\n *\n * @final\n */\nexport class IO<A> {\n  /**\n   * Triggers the asynchronous execution.\n   *\n   * Without invoking `run` on a `IO`, nothing gets evaluated, as an\n   * `IO` has lazy behavior.\n   *\n   * ```typescript\n   * // Describing a side effect\n   * const io = IO.of(() => console.log(\"Hello!\"))\n   *   // Delaying it for 1 second, for didactical purposes\n   *   .delayExecution(1000)\n   *\n   * // Nothing executes until we call run on it, which gives\n   * // us a Future in return:\n   * const f: Future<void> = io.run()\n   *\n   * // The given Future is cancelable, in case the logic\n   * // decribed by our IO is cancelable, so we can do this:\n   * f.cancel()\n   * ```\n   *\n   * Note that `run` takes a\n   * [Scheduler](https://funfix.org/api/exec/classes/scheduler.html)\n   * as an optional parameter and if one isn't provided, then the\n   * default scheduler gets used. The `Scheduler` is in charge\n   * of scheduling asynchronous boundaries, executing tasks\n   * with a delay (e.g. `setTimeout`) or of reporting failures\n   * (with `console.error` by default).\n   *\n   * Also see {@link IO.runOnComplete} for a version that takes a\n   * callback as parameter.\n   *\n   * @return a `Future` that will eventually complete with the\n   *         result produced by this `IO` on evaluation\n   */\n  run(ec: Scheduler = Scheduler.global.get()): Future<A> {\n    return taskToFutureRunLoop(this, ec)\n  }\n\n  /**\n   * Triggers the asynchronous execution.\n   *\n   * Without invoking `run` on a `IO`, nothing gets evaluated, as an\n   * `IO` has lazy behavior.\n   *\n   * `runComplete` starts the evaluation and takes a callback which\n   * will be triggered when the computation is complete.\n   *\n   * Compared with JavaScript's `Promise.then` the provided callback\n   * is a function that receives a\n   * [Try](https://funfix.org/api/core/classes/try.html) value, a data\n   * type which is what's called a \"logical disjunction\", or a \"tagged\n   * union type\", a data type that can represent both successful\n   * results and failures. This is because in Funfix we don't work\n   * with `null`.\n   *\n   * Also the returned value is an\n   * [ICancelable](https://funfix.org/api/exec/interfaces/icancelable.html)\n   * reference, which can be used to cancel the running computation,\n   * in case the logic described by our `IO` is cancelable (note that\n   * some procedures cannot be cancelled, it all depends on how the\n   * `IO` value was described, see {@link IO.async} for how cancelable\n   * `IO` values can be built).\n   *\n   * Example:\n   *\n   * ```typescript\n   * // Describing a side effect\n   * const io = IO.of(() => console.log(\"Hello!\"))\n   *   .delayExecution(1000)\n   *\n   * // Nothing executes until we explicitly run our `IO`:\n   * const c: ICancelable = io.runOnComplete(r =>\n   *   r.fold(\n   *     err => console.error(err),\n   *     _ => console.info(\"Done!\")\n   *   ))\n   *\n   * // In case we change our mind and the logic described by\n   * // our `IO` is cancelable, we can cancel it:\n   * c.cancel()\n   * ```\n   *\n   * Note that `runOnComplete` takes a\n   * [Scheduler](https://funfix.org/api/exec/classes/scheduler.html)\n   * as an optional parameter and if one isn't provided, then the\n   * default scheduler gets used. The `Scheduler` is in charge\n   * of scheduling asynchronous boundaries, executing tasks\n   * with a delay (e.g. `setTimeout`) or of reporting failures\n   * (with `console.error` by default).\n   *\n   * Also see {@link IO.run} for a version that returns a `Future`,\n   * which might be easier to work with, especially since a `Future`\n   * is `Promise`-like.\n   *\n   * @param cb is the callback that will be eventually called with\n   *        the final result, or error, when the evaluation completes\n   *\n   * @param ec is the scheduler that controls the triggering of\n   *        asynchronous boundaries (e.g. `setTimeout`)\n   *\n   * @return a cancelable action that can be triggered to cancel\n   *         the running computation, assuming that the implementation\n   *         of the source `IO` can be cancelled\n   */\n  runOnComplete(\n    cb: (result: Try<A>) => void,\n    ec: Scheduler = Scheduler.global.get()): ICancelable {\n\n    const ref = ioGenericRunLoop(this, ec, null, cb, null, null, null)\n    return ref || Cancelable.empty()\n  }\n\n  /**\n   * Handle errors by lifting results into `Either` values.\n   *\n   * If there's an error, then a `Left` value will be signaled. If\n   * there is no error, then a `Right` value will be signaled instead.\n   *\n   * The returned type is an\n   * [Either](https://funfix.org/api/core/classes/either.html) value,\n   * which is what's called a \"logical disjunction\" or a \"tagged union\n   * type\", representing a choice between two values, in this case\n   * errors on the \"Left\" and successful results on the \"Right\".\n   *\n   * ```typescript\n   * // Describing an IO that can fail on execution:\n   * const io: IO<number> = IO.of(() => {\n   *   const n = Math.random() * 1000\n   *   const m = n & n // to integer\n   *   if (m % 2) throw new Error(\"No odds please!\")\n   *   return m\n   * })\n   *\n   * // By using attempt() we can observe and use errors\n   * // in `map` and `flatMap` transformations:\n   * io.attempt().map(either =>\n   *   either.fold(\n   *     err => \"odd\",\n   *     val => \"even\"\n   *   ))\n   * ```\n   *\n   * For other error handling capabilities, see {@link IO.recoverWith}\n   * and {@link IO.transformWith}.\n   */\n  attempt(): IO<Either<Throwable, A>> {\n    return this.transform(\n      _ => Either.left<Throwable, A>(_),\n      Either.right)\n  }\n\n  /**\n   * Introduces an asynchronous boundary at the current stage in the\n   * asynchronous processing pipeline (after the source has been\n   * evaluated).\n   *\n   * Consider the following example:\n   *\n   * ```typescript\n   * const readPath: () => \"path/to/file\"\n   *\n   * const io = IO.of(readPath)\n   *   .asyncBoundary()\n   *   .map(fs.readFileSync)\n   * ```\n   *\n   * Between reading the path and then reading the file from that\n   * path, we schedule an async boundary (it usually happens with\n   * JavaScript's `setTimeout` under the hood).\n   *\n   * This is equivalent with:\n   *\n   * ```typescript\n   * self.flatMap(a => IO.shift(ec).map(_ => a))\n   *\n   * // ... or ...\n   *\n   * self.forEffect(IO.shift(ec))\n   * ```\n   *\n   * Also see {@link IO.shift} and {@link IO.fork}.\n   *\n   * @param ec is an optional `Scheduler` implementation that can\n   *        be used for scheduling the async boundary, however if\n   *        not specified, the `IO`'s default scheduler (the one\n   *        passed to `run()`) gets used\n   */\n  asyncBoundary(ec?: Scheduler): IO<A> {\n    return this.flatMap(a => IO.shift(ec).map(_ => a))\n  }\n\n  /**\n   * Alias for {@link IO.flatMap .flatMap}.\n   */\n  chain<B>(f: (a: A) => IO<B>): IO<B> {\n    return this.flatMap(f)\n  }\n\n  /**\n   * Delays the evaluation of this `IO` by the specified duration.\n   *\n   * ```typescript\n   * const fa = IO.of(() => \"Hello\")\n   *\n   * // Delays the evaluation by 1 second\n   * fa.delayExecution(1000)\n   * ```\n   *\n   * @param delay is the duration to wait before signaling the\n   *        final result\n   */\n  delayExecution(delay: number | Duration): IO<A> {\n    return IO.delayedTick(delay).flatMap(_ => this)\n  }\n\n  /**\n   * Delays signaling the result of this `IO` on evaluation by the\n   * specified duration.\n   *\n   * It works for successful results:\n   *\n   * ```typescript\n   * const fa = IO.of(() => \"Alex\")\n   *\n   * // Delays the signaling by 1 second\n   * fa.delayResult(1000)\n   * ```\n   *\n   * And for failures as well:\n   *\n   * ```typescript\n   * Future.raise(new TimeoutError()).delayResult(1000)\n   * ```\n   *\n   * @param delay is the duration to wait before signaling the\n   *        final result\n   */\n  delayResult(delay: number | Duration): IO<A> {\n    return this.transformWith(\n      err => IO.delayedTick(delay).flatMap(_ => IO.raise(err)),\n      a => IO.delayedTick(delay).map(_ => a)\n    )\n  }\n\n  /**\n   * Returns a new `IO` in which `f` is scheduled to be run on\n   * completion. This would typically be used to release any\n   * resources acquired by this `IO`.\n   *\n   * The returned `IO` completes when both the source and the task\n   * returned by `f` complete.\n   *\n   * NOTE: The given function is only called when the task is\n   * complete.  However the function does not get called if the task\n   * gets canceled. Cancellation is a process that's concurrent with\n   * the execution of a task and hence needs special handling.\n   *\n   * See {@link IO.doOnCancel} for specifying a callback to call on\n   * canceling a task.\n   */\n  doOnFinish(f: (e: Option<Throwable>) => IO<void>): IO<A> {\n    return this.transformWith(\n      e => f(Some(e)).flatMap(_ => IO.raise(e)),\n      a => f(None).map(_ => a)\n    )\n  }\n\n  /**\n   * Returns a new `IO` that will mirror the source, but that will\n   * execute the given `callback` if the task gets canceled before\n   * completion.\n   *\n   * This only works for premature cancellation. See\n   * {@link IO.doOnFinish} for triggering callbacks when the\n   * source finishes.\n   *\n   * @param callback is the `IO` value to execute if the task gets\n   *        canceled prematurely\n   */\n  doOnCancel(callback: IO<void>): IO<A> {\n    return IO.asyncUnsafe<A>((ctx, cb) => {\n      const ec = ctx.scheduler\n      ec.trampoline(() => {\n        const conn = ctx.connection\n        conn.push(Cancelable.of(() => callback.run(ec)))\n        IO.unsafeStart(this, ctx, ioSafeCallback(ec, conn, cb))\n      })\n    })\n  }\n\n  /**\n   * Ensures that an asynchronous boundary happens before the\n   * execution, managed by the provided scheduler.\n   *\n   * Alias for {@link IO.fork}.\n   *\n   * Calling this is equivalent with:\n   *\n   * ```typescript\n   * IO.shift(ec).flatMap(_ => self)\n   *\n   * // ... or ...\n   *\n   * IO.shift(ec).followedBy(self)\n   * ```\n   *\n   * See {@link IO.fork}, {@link IO.asyncBoundary} and {@link IO.shift}.\n   */\n  executeForked(ec?: Scheduler): IO<A> {\n    return IO.fork(this, ec)\n  }\n\n  /**\n   * Override the `ExecutionModel` of the default scheduler.\n   *\n   * ```typescript\n   * import { ExecutionModel } from \"funfix\"\n   *\n   * io.executeWithModel(ExecutionModel.alwaysAsync())\n   * ```\n   */\n  executeWithModel(em: ExecutionModel): IO<A> {\n    return IO.asyncUnsafe<A>((ctx, cb) => {\n      const ec = ctx.scheduler.withExecutionModel(em)\n      const ctx2 = new IOContext(ec, ctx.connection, ctx.options)\n      ec.trampoline(() => IO.unsafeStart(this, ctx2, cb))\n    })\n  }\n\n  /**\n   * Returns a new `IO` that upon evaluation will execute with the\n   * given set of {@link IOOptions}, allowing for tuning the run-loop.\n   *\n   * This allows for example making run-loops \"auto-cancelable\",\n   * an option that's off by default due to safety concerns:\n   *\n   * ```typescript\n   * io.executeWithOptions({\n   *   autoCancelableRunLoops: true\n   * })\n   * ```\n   */\n  executeWithOptions(set: IOOptions): IO<A> {\n    return IO.asyncUnsafe<A>((ctx, cb) => {\n      const ec = ctx.scheduler\n      const ctx2 = new IOContext(ec, ctx.connection, set)\n      ec.trampoline(() => IO.unsafeStart(this, ctx2, cb))\n    })\n  }\n\n  /**\n   * Creates a new `IO` by applying a function to the successful\n   * result of the source, and returns a new instance equivalent to\n   * the result of the function.\n   *\n   * ```typescript\n   * const rndInt = IO.of(() => {\n   *   const nr = Math.random() * 1000000\n   *   return nr & nr\n   * })\n   *\n   * const evenInt = () =>\n   *   rndInt.flatMap(int => {\n   *     if (i % 2 == 0)\n   *       return IO.now(i)\n   *     else // Retry until we have an even number!\n   *       return evenInt()\n   *   })\n   * ```\n   */\n  flatMap<B>(f: (a: A) => IO<B>): IO<B> {\n    return new IOFlatMap(this, f)\n  }\n\n  /**\n   * Sequentially compose two `IO` actions, discarding any value\n   * produced by the first.\n   *\n   * So this:\n   *\n   * ```typescript\n   * ioA.followedBy(ioB)\n   * ```\n   *\n   * Is equivalent with this:\n   *\n   * ```typescript\n   * ioA.flatMap(_ => fb)\n   * ```\n   */\n  followedBy<B>(fb: IO<B>): IO<B> {\n    return this.flatMap(_ => fb)\n  }\n\n  /**\n   * Returns a new `IO` that upon evaluation will execute the given\n   * function for the generated element, transforming the source into\n   * an `IO<void>`.\n   */\n  forEach(cb: (a: A) => void): IO<void> {\n    return this.map(cb)\n  }\n\n  /**\n   * Sequentially compose two actions, discarding any value\n   * produced by the second.\n   *\n   * So this:\n   *\n   * ```typescript\n   * ioA.forEffect(ioB)\n   * ```\n   *\n   * Is equivalent with this:\n   *\n   * ```typescript\n   * ioA.flatMap(a => ioB.map(_ => a))\n   * ```\n   */\n  forEffect<B>(fb: IO<B>): IO<A> {\n    return this.flatMap(a => fb.map(_ => a))\n  }\n\n  /**\n   * Returns a new `IO` that applies the mapping function to the\n   * successful result emitted by the source.\n   *\n   * ```typescript\n   * IO.now(111).map(_ => _ * 2).get() // 222\n   * ```\n   *\n   * Note there's a correspondence between `flatMap` and `map`:\n   *\n   * ```typescript\n   * fa.map(f) <-> fa.flatMap(x => IO.pure(f(x)))\n   * ```\n   */\n  map<B>(f: (a: A) => B): IO<B> {\n    return new IOFlatMap(this, (a: A) => IO.now(f(a)))\n  }\n\n  /**\n   * Memoizes (caches) the result of the source `IO` and reuses it on\n   * subsequent invocations of `run`.\n   *\n   * The resulting task will be idempotent, meaning that\n   * evaluating the resulting task multiple times will have the\n   * same effect as evaluating it once.\n   *\n   * @see {@link IO.memoizeOnSuccess} for a version that only caches\n   *     successful results.\n   */\n  memoize(): IO<A> {\n    switch (this._funADType) {\n      case \"pure\":\n        return this\n      case \"always\":\n        const always = (this as any) as IOAlways<A>\n        return new IOOnce(always.thunk, false)\n      case \"memoize\":\n        const mem = (this as any) as IOMemoize<A>\n        if (!mem.onlySuccess) return mem\n        return new IOMemoize(this, false)\n      default: // flatMap | async\n        return new IOMemoize(this, false)\n    }\n  }\n\n  /**\n   * Memoizes (caches) the successful result of the source task\n   * and reuses it on subsequent invocations of `run`.\n   * Thrown exceptions are not cached.\n   *\n   * The resulting task will be idempotent, but only if the\n   * result is successful.\n   *\n   * @see {@link IO.memoize} for a version that caches both successful\n   *     results and failures\n   */\n  memoizeOnSuccess(): IO<A> {\n    switch (this._funADType) {\n      case \"pure\":\n      case \"once\":\n      case \"memoize\":\n        return this\n      case \"always\":\n        const always = (this as any) as IOAlways<A>\n        return new IOOnce(always.thunk, true)\n      default: // flatMap | async\n        return new IOMemoize(this, true)\n    }\n  }\n\n  /**\n   * Creates a new `IO` that will mirror the source on success,\n   * but on failure it will try to recover and yield a successful\n   * result by applying the given function `f` to the thrown error.\n   *\n   * This function is the equivalent of a `try/catch` statement,\n   * or the equivalent of {@link IO.map .map} for errors.\n   *\n   * ```typescript\n   * io.recover(err => {\n   *   console.error(err)\n   *   fallback\n   * })\n   * ```\n   */\n  recover<AA>(f: (e: Throwable) => AA): IO<A | AA> {\n    return this.recoverWith(a => IO.now(f(a)))\n  }\n\n  /**\n   * Creates a new `IO` that will mirror the source on success,\n   * but on failure it will try to recover and yield a successful\n   * result by applying the given function `f` to the thrown error.\n   *\n   * This function is the equivalent of a `try/catch` statement,\n   * or the equivalent of {@link IO.flatMap .flatMap} for errors.\n   *\n   * Note that because of `IO`'s laziness, this can describe retry\n   * loop:\n   *\n   * ```typescript\n   * function retryOnFailure<A>(times: number, io: IO<A>): IO<A> {\n   *   return source.recoverWith(err => {\n   *     // No more retries left? Re-throw error:\n   *     if (times <= 0) return IO.raise(err)\n   *     // Recursive call, yes we can!\n   *     return retryOnFailure(times - 1, io)\n   *       // Adding 500 ms delay for good measure\n   *       .delayExecution(500)\n   *   })\n   * }\n   * ```\n   */\n  recoverWith<AA>(f: (e: Throwable) => IO<AA>): IO<A | AA> {\n    return this.transformWith(f, IO.now as any)\n  }\n\n  /**\n   * Returns an `IO` that mirrors the source in case the result of\n   * the source is signaled within the required `after` duration\n   * on evaluation, otherwise it fails with a `TimeoutError`,\n   * cancelling the source.\n   *\n   * ```typescript\n   * const fa = IO.of(() => 1).delayResult(10000)\n   *\n   * // Will fail with a TimeoutError on run()\n   * fa.timeout(1000)\n   * ```\n   *\n   * @param after is the duration to wait until it triggers\n   *        the timeout error\n   */\n  timeout(after: number | Duration): IO<A> {\n    const fb = IO.raise(new TimeoutError(Duration.of(after).toString()))\n    return this.timeoutTo(after, fb)\n  }\n\n  /**\n   * Returns an `IO` value that mirrors the source in case the result\n   * of the source is signaled within the required `after` duration\n   * when evaluated (with `run()`), otherwise it triggers the\n   * execution of the given `fallback` after the duration has passed,\n   * cancelling the source.\n   *\n   * This is literally the implementation of {@link IO.timeout}:\n   *\n   * ```typescript\n   * const fa = IO.of(() => 1).delayResult(10000)\n   *\n   * fa.timeoutTo(1000, IO.raise(new TimeoutError()))\n   * ```\n   *\n   * @param after is the duration to wait until it triggers the `fallback`\n   * @param fallback is a fallback `IO` to timeout to\n   */\n  timeoutTo<AA>(after: number | Duration, fallback: IO<AA>): IO<A | AA> {\n    const other = IO.delayedTick(after).flatMap(_ => fallback)\n    const lst: IO<A | AA>[] = [this, other]\n    return IO.firstCompletedOf(lst)\n  }\n\n  /**\n   * Creates a new `IO` by applying the 'success' function to the\n   * successful result of the source, or the 'error' function to the\n   * potential errors that might happen.\n   *\n   * This function is similar with {@link IO.map .map}, except that\n   * it can also transform errors and not just successful results.\n   *\n   * @param success is a function for transforming a successful result\n   * @param failure is a function for transforming failures\n   */\n  transform<R>(failure: (e: Throwable) => R, success: (a: A) => R): IO<R> {\n    return this.transformWith(\n      e => IO.now(failure(e)),\n      a => IO.now(success(a))\n    )\n  }\n\n  /**\n   * Creates a new `IO` by applying the 'success' function to the\n   * successful result of the source, or the 'error' function to the\n   * potential errors that might happen.\n   *\n   * This function is similar with {@link IO.flatMap .flatMap},\n   * except that it can also transform errors and not just successful\n   * results.\n   *\n   * @param success is a function for transforming a successful result\n   * @param failure is a function for transforming failures\n   */\n  transformWith<R>(failure: (e: Throwable) => IO<R>, success: (a: A) => IO<R>): IO<R> {\n    return new IOFlatMap(this, success, failure)\n  }\n\n  /**\n   * Identifies the `IO` reference type, useful for debugging and\n   * for pattern matching in the implementation.\n   *\n   * @hidden\n   */\n  readonly _funADType: \"pure\" | \"always\" | \"once\" | \"flatMap\" | \"async\" | \"memoize\"\n\n  // Implements HK<F, A>\n  /** @hidden */ readonly _funKindF: IO<any>\n  /** @hidden */ readonly _funKindA: A\n\n  // Implements Constructor<T>\n  /** @hidden */ static readonly _funErasure: IO<any>\n\n  /**\n   * Promote a `thunk` function to an `IO`, catching exceptions in\n   * the process.\n   *\n   * Note that since `IO` is not memoized by global, this will\n   * recompute the value each time the `IO` is executed.\n   *\n   * ```typescript\n   * const io = IO.always(() => { console.log(\"Hello!\") })\n   *\n   * io.run()\n   * //=> Hello!\n   * io.run()\n   * //=> Hello!\n   * io.run()\n   * //=> Hello!\n   * ```\n   */\n  static always<A>(thunk: () => A): IO<A> {\n    return new IOAlways(thunk)\n  }\n\n  /**\n   * Create a `IO` from an asynchronous computation, which takes\n   * the form of a function with which we can register a callback.\n   *\n   * This can be used to translate from a callback-based API to a\n   * straightforward monadic version.\n   */\n  static async<A>(register: (ec: Scheduler, cb: (a: Try<A>) => void) => ICancelable | void): IO<A> {\n    return IO.asyncUnsafe<A>((ctx, cb) => {\n      const ec = ctx.scheduler\n      const conn = ctx.connection\n\n      // Forcing a light asynchronous boundary, otherwise\n      // stack overflows are possible\n      ec.trampoline(() => {\n        // Wrapping the callback in a safe implementation that\n        // provides idempotency guarantees and that pops from\n        // the given `StackedCancelable` at the right time\n        const safe = ioSafeCallback(ec, conn, cb)\n        try {\n          const ref = register(ec, safe)\n          // This `push` can be executed after `register`, even the\n          // `safe` callback gets executed immediately, because of\n          // the light async boundary in `ioSafeCallback`\n          conn.push(ref || Cancelable.empty())\n        } catch (e) {\n          safe(Failure(e))\n        }\n      })\n    })\n  }\n\n  /**\n   * Constructs a lazy [[IO]] instance whose result will be computed\n   * asynchronously.\n   *\n   * **WARNING:** Unsafe to use directly, only use if you know\n   * what you're doing. For building `IO` instances safely\n   * see {@link IO.async}.\n   *\n   * Rules of usage:\n   *\n   *  - the received `StackedCancelable` can be used to store\n   *    cancelable references that will be executed upon cancel;\n   *    every `push` must happen at the beginning, before any\n   *    execution happens and `pop` must happen afterwards\n   *    when the processing is finished, before signaling the\n   *    result\n   *  - before execution, an asynchronous boundary is recommended,\n   *    to avoid stack overflow errors, but can happen using the\n   *    scheduler's facilities for trampolined execution\n   *  - on signaling the result (`Success` or `Failure`),\n   *    another async boundary is necessary, but can also\n   *    happen with the scheduler's facilities for trampolined\n   *    execution (e.g. `Scheduler.trampoline`)\n   *\n   * **WARNING:** note that not only is this builder unsafe, but also\n   * unstable, as the {@link IORegister} callback type is exposing\n   * volatile internal implementation details. This builder is meant\n   * to create optimized asynchronous tasks, but for normal usage\n   * prefer {@link IO.async}.\n   */\n  static asyncUnsafe<A>(register: IORegister<A>): IO<A> {\n    return new IOAsync(register)\n  }\n\n  /**\n   * Promote a `thunk` function generating `IO` results to an `IO`\n   * of the same type.\n   *\n   * Alias for {@link IO.suspend}.\n   */\n  static defer<A>(thunk: () => IO<A>): IO<A> {\n    return IO.unit().flatMap(_ => thunk())\n  }\n\n  /**\n   * Defers the creation of an `IO` by using the provided function,\n   * which has the ability to inject a needed `Scheduler`.\n   *\n   * Example:\n   *\n   * ```typescript\n   * function measureLatency<A>(source: IO<A>): IO<[A, Long]> {\n   *   return IO.deferAction<[A, Long]>(s => {\n   *     // We have our Scheduler, which can inject time, we\n   *     // can use it for side-effectful operations\n   *     const start = s.currentTimeMillis()\n   *\n   *     return source.map(a => {\n   *       const finish = s.currentTimeMillis()\n   *       return [a, finish - start]\n   *     })\n   *   })\n   * }\n   * ```\n   *\n   * @param f is the function that's going to be called when the\n   *        resulting `IO` gets evaluated\n   */\n  static deferAction<A>(f: (ec: Scheduler) => IO<A>): IO<A> {\n    return IO.asyncUnsafe<A>((ctx, cb) => {\n      const ec = ctx.scheduler\n      let ioa: IO<A>\n      try { ioa = f(ec) } catch (e) { ioa = IO.raise(e) }\n      ec.trampoline(() => IO.unsafeStart(ioa, ctx, cb))\n    })\n  }\n\n  /**\n   * Given a `thunk` that produces `Future` values, suspends it\n   * in the `IO` context, evaluating it on demand whenever the\n   * resulting `IO` gets evaluated.\n   *\n   * See {@link IO.fromFuture} for the strict version.\n   */\n  static deferFuture<A>(thunk: () => Future<A>): IO<A> {\n    return IO.suspend(() => IO.fromFuture(thunk()))\n  }\n\n  /**\n   * Wraps calls that generate `Future` results into `IO`, provided\n   * a callback with an injected `Scheduler`.\n   *\n   * This builder helps with wrapping `Future`-enabled APIs that need\n   * a `Scheduler` to work.\n   *\n   * @param f is the function that's going to be executed when the task\n   *        gets evaluated, generating the wrapped `Future`\n   */\n  static deferFutureAction<A>(f: (ec: Scheduler) => Future<A>): IO<A> {\n    return IO.deferAction(ec => IO.fromFuture(f(ec)))\n  }\n\n  /**\n   * Returns an `IO` that on evaluation will complete after the\n   * given `delay`.\n   *\n   * This can be used to do delayed execution. For example:\n   *\n   * ```typescript\n   * IO.delayedTick(1000).flatMap(_ =>\n   *   IO.of(() => console.info(\"Hello!\"))\n   * )\n   * ```\n   *\n   * @param delay is the duration to wait before signaling the tick\n   */\n  static delayedTick<A>(delay: number | Duration): IO<void> {\n    return IO.asyncUnsafe<void>((ctx, cb) => {\n      const conn = ctx.connection\n      const task = ctx.scheduler.scheduleOnce(delay, () => {\n        conn.pop()\n        cb(Try.unit())\n      })\n      conn.push(task)\n    })\n  }\n\n  /**\n   * Creates a race condition between multiple `IO` values, on\n   * evaluation returning the result of the first one that completes,\n   * cancelling the rest.\n   *\n   * ```typescript\n   * const failure = IO.raise(new TimeoutError()).delayResult(2000)\n   *\n   * // Will yield 1\n   * const fa1 = IO.of(() => 1).delayResult(1000)\n   * IO.firstCompletedOf([fa1, failure])\n   *\n   * // Will yield a TimeoutError\n   * const fa2 = IO.of(() => 1).delayResult(10000)\n   * IO.firstCompletedOf([fa2, failure])\n   * ```\n   *\n   * @param list is the list of `IO` values for which the\n   *        race is started\n   *\n   * @return a new `IO` that will evaluate to the result of the first\n   *         in the list to complete, the rest being cancelled\n   */\n  static firstCompletedOf<A>(list: IO<A>[] | Iterable<IO<A>>): IO<A> {\n    return ioListToFutureProcess(list, Future.firstCompletedOf)\n  }\n\n  /**\n   * Converts any strict `Future` value into an {@link IO}.\n   *\n   * Note that this builder does not suspend any side effects, since\n   * the given parameter is strict (and not a function) and because\n   * `Future` has strict behavior.\n   *\n   * See {@link IO.deferFuture} for an alternative that evaluates\n   * lazy thunks that produce future results.\n   */\n  static fromFuture<A>(fa: Future<A>): IO<A> {\n    if (!fa.value().isEmpty())\n      return IO.fromTry<A>(fa.value().get() as any)\n\n    return IO.asyncUnsafe<A>((ctx, cb) => {\n      ctx.connection.push(fa)\n      fa.onComplete(result => {\n        ctx.connection.pop()\n        cb(result as any)\n      })\n    })\n  }\n\n  /**\n   * Returns a `IO` reference that will signal the result of the\n   * given `Try<A>` reference upon evaluation.\n   */\n  static fromTry<A>(a: Try<A>): IO<A> { return new IOPure(a) }\n\n  /**\n   * Mirrors the given source `IO`, but before execution trigger\n   * an asynchronous boundary (usually by means of `setTimeout` on\n   * top of JavaScript, depending on the provided `Scheduler`\n   * implementation).\n   *\n   * If a `Scheduler` is not explicitly provided, the implementation\n   * ends up using the one provided in {@link IO.run}.\n   *\n   * Note that {@link IO.executeForked} is the method version of this\n   * function (e.g. `io.executeForked() == IO.fork(this)`).\n   *\n   * ```typescript\n   * IO.of(() => fs.readFileSync(path))\n   *   .executeForked()\n   * ```\n   *\n   * Also see {@link IO.shift} and {@link IO.asyncBoundary}.\n   *\n   * @param fa is the task that will get executed asynchronously\n   *\n   * @param ec is the `Scheduler` used for triggering the async\n   *        boundary, or if not provided it will default to the\n   *        scheduler passed on evaluation in {@link IO.run}\n   */\n  static fork<A>(fa: IO<A>, ec?: Scheduler): IO<A> {\n    return IO.shift(ec).flatMap(_ => fa)\n  }\n\n  /**\n   * Maps 2 `IO` values by the mapping function, returning a new\n   * `IO` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link IO.sequence} operation and as such\n   * on cancellation or failure all pending tasks get cancelled.\n   *\n   * ```typescript\n   * const fa1 = IO.of(() => 1)\n   * const fa2 = IO.of(() => 2)\n   *\n   *\n   * // Yields Success(3)\n   * IO.map2(fa1, fa2, (a, b) => a + b)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * IO.map2(fa1, IO.raise(\"error\"),\n   *   (a, b) => a + b\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map2`.\n   */\n  static map2<A1, A2, R>(\n    fa1: IO<A1>, fa2: IO<A2>,\n    f: (a1: A1, a2: A2) => R): IO<R> {\n\n    const fl: IO<any[]> = IO.sequence([fa1, fa2] as any[])\n    return fl.map(lst => f(lst[0], lst[1]))\n  }\n\n  /**\n   * Maps 3 `IO` values by the mapping function, returning a new\n   * `IO` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link IO.sequence} operation and as such\n   * on cancellation or failure all pending tasks get cancelled.\n   *\n   * ```typescript\n   * const fa1 = IO.of(() => 1)\n   * const fa2 = IO.of(() => 2)\n   * const fa3 = IO.of(() => 3)\n   *\n   *\n   * // Yields Success(6)\n   * IO.map3(fa1, fa2, fa3, (a, b, c) => a + b + c)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * IO.map3(\n   *   fa1, fa2, IO.raise(\"error\"),\n   *   (a, b, c) => a + b + c\n   * )\n   * ```\n   */\n  static map3<A1, A2, A3, R>(\n    fa1: IO<A1>, fa2: IO<A2>, fa3: IO<A3>,\n    f: (a1: A1, a2: A2, a3: A3) => R): IO<R> {\n\n    const fl: IO<any[]> = IO.sequence([fa1, fa2, fa3] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2]))\n  }\n\n  /**\n   * Maps 4 `IO` values by the mapping function, returning a new\n   * `IO` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link IO.sequence} operation and as such\n   * on cancellation or failure all pending tasks get cancelled.\n   *\n   * ```typescript\n   * const fa1 = IO.of(() => 1)\n   * const fa2 = IO.of(() => 2)\n   * const fa3 = IO.of(() => 3)\n   * const fa4 = IO.of(() => 4)\n   *\n   * // Yields Success(10)\n   * IO.map4(fa1, fa2, fa3, fa4, (a, b, c, d) => a + b + c + d)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * IO.map4(\n   *   fa1, fa2, fa3, IO.raise(\"error\"),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   * ```\n   */\n  static map4<A1, A2, A3, A4, R>(\n    fa1: IO<A1>, fa2: IO<A2>, fa3: IO<A3>, fa4: IO<A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R): IO<R> {\n\n    const fl: IO<any[]> = IO.sequence([fa1, fa2, fa3, fa4] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3]))\n  }\n\n  /**\n   * Maps 5 `IO` values by the mapping function, returning a new\n   * `IO` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link IO.sequence} operation and as such\n   * on cancellation or failure all pending tasks get cancelled.\n   *\n   * ```typescript\n   * const fa1 = IO.of(() => 1)\n   * const fa2 = IO.of(() => 2)\n   * const fa3 = IO.of(() => 3)\n   * const fa4 = IO.of(() => 4)\n   * const fa5 = IO.of(() => 5)\n   *\n   * // Yields Success(15)\n   * IO.map5(fa1, fa2, fa3, fa4, fa5,\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * IO.map5(\n   *   fa1, fa2, fa3, fa4, IO.raise(\"error\"),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   * ```\n   */\n  static map5<A1, A2, A3, A4, A5, R>(\n    fa1: IO<A1>, fa2: IO<A2>, fa3: IO<A3>, fa4: IO<A4>, fa5: IO<A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R): IO<R> {\n\n    const fl: IO<any[]> = IO.sequence([fa1, fa2, fa3, fa4, fa5] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3], lst[4]))\n  }\n\n  /**\n   * Maps 6 `IO` values by the mapping function, returning a new\n   * `IO` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link IO.sequence} operation and as such\n   * on cancellation or failure all pending tasks get cancelled.\n   *\n   * ```typescript\n   * const fa1 = IO.of(() => 1)\n   * const fa2 = IO.of(() => 2)\n   * const fa3 = IO.of(() => 3)\n   * const fa4 = IO.of(() => 4)\n   * const fa5 = IO.of(() => 5)\n   * const fa6 = IO.of(() => 6)\n   *\n   * // Yields Success(21)\n   * IO.map6(\n   *   fa1, fa2, fa3, fa4, fa5, fa6,\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * IO.map6(\n   *   fa1, fa2, fa3, fa4, fa5, IO.raise(\"error\"),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   * ```\n   */\n  static map6<A1, A2, A3, A4, A5, A6, R>(\n    fa1: IO<A1>, fa2: IO<A2>, fa3: IO<A3>, fa4: IO<A4>, fa5: IO<A5>, fa6: IO<A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R): IO<R> {\n\n    const fl: IO<any[]> = IO.sequence([fa1, fa2, fa3, fa4, fa5, fa6] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3], lst[4], lst[5]))\n  }\n\n  /**\n   * Returns an `IO` that on execution is always successful,\n   * emitting the given strict value.\n   */\n  static now<A>(value: A): IO<A> { return new IOPure(Success(value)) }\n\n  /**\n   * Alias for {@link IO.always}.\n   */\n  static of<A>(thunk: () => A): IO<A> {\n    return IO.always(thunk)\n  }\n\n  /**\n   * Promote a `thunk` function to a `Coeval` that is memoized on the\n   * first evaluation, the result being then available on subsequent\n   * evaluations.\n   *\n   * Note this is equivalent with:\n   *\n   * ```typescript\n   * IO.always(thunk).memoize()\n   * ```\n   */\n  static once<A>(thunk: () => A): IO<A> {\n    return new IOOnce(thunk, false)\n  }\n\n  /**\n   * Maps 2 `IO` values evaluated nondeterministically, returning a new\n   * `IO` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link IO.gather} operation. As such\n   * the `IO` operations are potentially executed in parallel\n   * (if the operations are asynchronous) and on cancellation or\n   * failure all pending tasks get cancelled.\n   *\n   * ```typescript\n   * const fa1 = IO.of(() => 1)\n   * const fa2 = IO.of(() => 2)\n   *\n   *\n   * // Yields Success(3)\n   * IO.parMap2(fa1, fa2, (a, b) => a + b)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * IO.parMap2(fa1, IO.raise(\"error\"),\n   *   (a, b) => a + b\n   * )\n   * ```\n   */\n  static parMap2<A1, A2, R>(\n    fa1: IO<A1>, fa2: IO<A2>,\n    f: (a1: A1, a2: A2) => R): IO<R> {\n\n    const fl: IO<any[]> = IO.gather([fa1, fa2] as any[])\n    return fl.map(lst => f(lst[0], lst[1]))\n  }\n\n  /**\n   * Maps 3 `IO` values evaluated nondeterministically, returning a new\n   * `IO` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link IO.gather} operation. As such\n   * the `IO` operations are potentially executed in parallel\n   * (if the operations are asynchronous) and on cancellation or\n   * failure all pending tasks get cancelled.\n   *\n   * ```typescript\n   * const fa1 = IO.of(() => 1)\n   * const fa2 = IO.of(() => 2)\n   * const fa3 = IO.of(() => 3)\n   *\n   *\n   * // Yields Success(6)\n   * IO.parMap3(fa1, fa2, fa3, (a, b, c) => a + b + c)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * IO.parMap3(\n   *   fa1, fa2, IO.raise(\"error\"),\n   *   (a, b, c) => a + b + c\n   * )\n   * ```\n   */\n  static parMap3<A1, A2, A3, R>(\n    fa1: IO<A1>, fa2: IO<A2>, fa3: IO<A3>,\n    f: (a1: A1, a2: A2, a3: A3) => R): IO<R> {\n\n    const fl: IO<any[]> = IO.gather([fa1, fa2, fa3] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2]))\n  }\n\n  /**\n   * Maps 4 `IO` values evaluated nondeterministically, returning a new\n   * `IO` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link IO.gather} operation. As such\n   * the `IO` operations are potentially executed in parallel\n   * (if the operations are asynchronous) and on cancellation or\n   * failure all pending tasks get cancelled.\n   *\n   * ```typescript\n   * const fa1 = IO.of(() => 1)\n   * const fa2 = IO.of(() => 2)\n   * const fa3 = IO.of(() => 3)\n   * const fa4 = IO.of(() => 4)\n   *\n   * // Yields Success(10)\n   * IO.parMap4(fa1, fa2, fa3, fa4, (a, b, c, d) => a + b + c + d)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * IO.parMap4(\n   *   fa1, fa2, fa3, IO.raise(\"error\"),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   * ```\n   */\n  static parMap4<A1, A2, A3, A4, R>(\n    fa1: IO<A1>, fa2: IO<A2>, fa3: IO<A3>, fa4: IO<A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R): IO<R> {\n\n    const fl: IO<any[]> = IO.gather([fa1, fa2, fa3, fa4] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3]))\n  }\n\n  /**\n   * Maps 5 `IO` values evaluated nondeterministically, returning a new\n   * `IO` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link IO.gather} operation. As such\n   * the `IO` operations are potentially executed in parallel\n   * (if the operations are asynchronous) and on cancellation or\n   * failure all pending tasks get cancelled.\n   *\n   * ```typescript\n   * const fa1 = IO.of(() => 1)\n   * const fa2 = IO.of(() => 2)\n   * const fa3 = IO.of(() => 3)\n   * const fa4 = IO.of(() => 4)\n   * const fa5 = IO.of(() => 5)\n   *\n   * // Yields Success(15)\n   * IO.parMap5(fa1, fa2, fa3, fa4, fa5,\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * IO.parMap5(\n   *   fa1, fa2, fa3, fa4, IO.raise(\"error\"),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   * ```\n   */\n  static parMap5<A1, A2, A3, A4, A5, R>(\n    fa1: IO<A1>, fa2: IO<A2>, fa3: IO<A3>, fa4: IO<A4>, fa5: IO<A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R): IO<R> {\n\n    const fl: IO<any[]> = IO.gather([fa1, fa2, fa3, fa4, fa5] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3], lst[4]))\n  }\n\n  /**\n   * Maps 6 `IO` values evaluated nondeterministically, returning a new\n   * `IO` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link IO.gather} operation. As such\n   * the `IO` operations are potentially executed in parallel\n   * (if the operations are asynchronous) and on cancellation or\n   * failure all pending tasks get cancelled.\n   *\n   * ```typescript\n   * const fa1 = IO.of(() => 1)\n   * const fa2 = IO.of(() => 2)\n   * const fa3 = IO.of(() => 3)\n   * const fa4 = IO.of(() => 4)\n   * const fa5 = IO.of(() => 5)\n   * const fa6 = IO.of(() => 6)\n   *\n   * // Yields Success(21)\n   * IO.parMap6(\n   *   fa1, fa2, fa3, fa4, fa5, fa6,\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * IO.parMap6(\n   *   fa1, fa2, fa3, fa4, fa5, IO.raise(\"error\"),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   * ```\n   */\n  static parMap6<A1, A2, A3, A4, A5, A6, R>(\n    fa1: IO<A1>, fa2: IO<A2>, fa3: IO<A3>, fa4: IO<A4>, fa5: IO<A5>, fa6: IO<A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R): IO<R> {\n\n    const fl: IO<any[]> = IO.gather([fa1, fa2, fa3, fa4, fa5, fa6] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3], lst[4], lst[5]))\n  }\n\n  /**\n   * Lifts a value into the `IO` context.\n   *\n   * Alias for {@link IO.now}.\n   */\n  static pure<A>(value: A): IO<A> { return IO.now(value) }\n\n  /**\n   * Returns an `IO` that on execution is always finishing in error\n   * emitting the specified exception.\n   */\n  static raise<A = never>(e: Throwable): IO<A> { return new IOPure(Failure(e)) }\n\n  /**\n   * Transforms a list of `IO` values into an `IO` of a list,\n   * ordering both results and side effects.\n   *\n   * This operation would be the equivalent of `Promise.all` or of\n   * `Future.sequence`, however because of the laziness of `IO`\n   * the given values are processed in order.\n   *\n   * Sequencing means that on evaluation the tasks won't get processed\n   * in parallel. If parallelism is desired, see {@link IO.gather}.\n   *\n   * Sample:\n   *\n   * ```typescript\n   * const io1 = IO.of(() => 1)\n   * const io2 = IO.of(() => 2)\n   * const io3 = IO.of(() => 3)\n   *\n   * // Yields [1, 2, 3]\n   * const all: IO<number[]> = IO.sequence([f1, f2, f3])\n   * ```\n   */\n  static sequence<A>(list: IO<A>[] | Iterable<IO<A>>): IO<A[]> {\n    return ioSequence(list)\n  }\n\n  /**\n   * Nondeterministically gather results from the given collection of\n   * tasks, returning a task that will signal the same type of\n   * collection of results once all tasks are finished.\n   *\n   * This function is the nondeterministic analogue of `sequence`\n   * and should behave identically to `sequence` so long as there is\n   * no interaction between the effects being gathered. However,\n   * unlike `sequence`, which decides on a total order of effects,\n   * the effects in a `gather` are unordered with respect to each\n   * other.\n   *\n   * In other words `gather` can execute `IO` tasks in parallel,\n   * whereas {@link IO.sequence} forces an execution order.\n   *\n   * Although the effects are unordered, the order of results matches\n   * the order of the input sequence.\n   *\n   * ```typescript\n   * const io1 = IO.of(() => 1)\n   * const io2 = IO.of(() => 2)\n   * const io3 = IO.of(() => 3)\n   *\n   * // Yields [1, 2, 3]\n   * const all: IO<number[]> = IO.gather([f1, f2, f3])\n   * ```\n   */\n  static gather<A>(list: IO<A>[] | Iterable<IO<A>>): IO<A[]> {\n    return ioListToFutureProcess(list, Future.sequence)\n  }\n\n  /**\n   * Shifts the bind continuation of the `IO` onto the specified\n   * scheduler, for triggering asynchronous execution.\n   *\n   * Asynchronous actions cannot be shifted, since they are scheduled\n   * rather than run. Also, no effort is made to re-shift synchronous\n   * actions which *follow* asynchronous actions within a bind chain;\n   * those actions will remain on the continuation call stack inherited\n   * from their preceding async action.  The only computations which\n   * are shifted are those which are defined as synchronous actions and\n   * are contiguous in the bind chain *following* the `shift`.\n   *\n   * For example this sample forces an asynchronous boundary\n   * (which usually means that the continuation is scheduled\n   * for asynchronous execution with `setTimeout`) before the\n   * file will be read synchronously:\n   *\n   * ```typescript\n   * IO.shift().flatMap(_ => fs.readFileSync(path))\n   * ```\n   *\n   * On the other hand in this example the asynchronous boundary\n   * is inserted *after* the file has been read:\n   *\n   * ```typescript\n   * IO.of(() => fs.readFileSync(path)).flatMap(content =>\n   *   IO.shift().map(_ => content))\n   * ```\n   *\n   * The definition of {@link IO.async} is literally:\n   *\n   * ```typescript\n   * source.flatMap(a => IO.shift(ec).map(_ => a))\n   * ```\n   *\n   * And the definition of {@link IO.fork} is:\n   *\n   * ```typescript\n   * IO.shift(ec).flatMap(_ => source)\n   * ```\n   *\n   * @param ec is the `Scheduler` used for triggering the async\n   *        boundary, or if not provided it will default to the\n   *        scheduler passed on evaluation in {@link IO.run}\n   */\n  static shift(ec?: Scheduler): IO<void> {\n    if (!ec) return ioShiftDefaultRef\n    return ioShift(ec)\n  }\n\n  /**\n   * Promote a `thunk` function generating `IO` results to an `IO`\n   * of the same type.\n   */\n  static suspend<A>(thunk: () => IO<A>): IO<A> {\n    return IO.unit().flatMap(_ => thunk())\n  }\n\n  /**\n   * Keeps calling `f` until a `Right(b)` is returned.\n   *\n   * Based on Phil Freeman's\n   * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.\n   *\n   * Described in `FlatMap.tailRecM`.\n   */\n  static tailRecM<A, B>(a: A, f: (a: A) => IO<Either<A, B>>): IO<B> {\n    try {\n      return f(a).flatMap(either => {\n        if (either.isRight()) {\n          return IO.now(either.get())\n        } else {\n          // Recursive call\n          return IO.tailRecM(either.swap().get(), f)\n        }\n      })\n    } catch (e) {\n      return IO.raise(e)\n    }\n  }\n\n  /**\n   * Shorthand for `now(undefined as void)`, always returning\n   * the same reference as optimization.\n   */\n  static unit(): IO<void> {\n    return ioUnitRef\n  }\n\n  /**\n   * Unsafe utility - starts the execution of an `IO`.\n   *\n   * This function allows for specifying a custom {@link IOContext}\n   * when evaluating the `IO` reference.\n   *\n   * DO NOT use directly, as it is UNSAFE to use, unless you know\n   * what you're doing. Prefer {@link IO.run} instead.\n   */\n  static unsafeStart<A>(source: IO<A>, context: IOContext, cb: (r: Try<A>) => void): void | ICancelable {\n    return ioGenericRunLoop(source, context.scheduler, context, cb, null, null, null)\n  }\n}\n\n/**\n * `Pure` is an internal `IO` state that wraps any strict\n * value in an `IO` reference. Returned by {@link IO.now}\n * and {@link IO.raise}.\n *\n * @private\n */\nclass IOPure<A> extends IO<A> {\n  readonly _funADType: \"pure\" = \"pure\"\n\n  /**\n   * @param value is the value that's going to be returned\n   * when `get()` is called.\n   */\n  constructor(public value: Try<A>) { super() }\n}\n\n/**\n * Reusable reference, to use in {@link IO.unit}.\n *\n * @private\n */\nconst ioUnitRef: IOPure<void> = new IOPure(Try.unit())\n\n/**\n * `Once` is an internal `IO` state that executes the given `thunk`\n * only once, upon calling `get()` and then memoize its result for\n * subsequent invocations.\n *\n * Returned by [[IO.once]].\n *\n * @private\n */\nclass IOOnce<A> extends IO<A> {\n  readonly _funADType: \"once\" = \"once\"\n\n  private _thunk: () => A\n  public cache: Try<A>\n  public onlyOnSuccess: boolean\n\n  constructor(thunk: () => A, onlyOnSuccess: boolean) {\n    super()\n    this._thunk = thunk\n    this.onlyOnSuccess = onlyOnSuccess\n  }\n\n  memoize(): IO<A> {\n    if (this.onlyOnSuccess && this._thunk)\n      return new IOOnce(this._thunk, false)\n    else\n      return this\n  }\n\n  runTry(): Try<A> {\n    if (this._thunk) {\n      const result = Try.of(this._thunk)\n      if (result.isSuccess() || !this.onlyOnSuccess) {\n        // GC purposes\n        delete this._thunk\n        delete this.onlyOnSuccess\n        this.cache = result\n      }\n      return result\n    }\n    return this.cache\n  }\n}\n\n/**\n * `Always` is an internal `IO` state that executes the given `thunk`\n * every time the call to `get()` happens. Returned by [[IO.always]].\n *\n * @private\n */\nclass IOAlways<A> extends IO<A> {\n  readonly _funADType: \"always\" = \"always\"\n\n  constructor(public thunk: () => A) { super() }\n}\n\n/**\n * `FlatMap` is an internal `IO` state that represents a\n * [[IO.flatMap .flatMap]], [[IO.map .map]], [[IO.transform .transform]]\n * or a [[IO.transformWith .transformWith]] operation, all of them\n * being expressed with this state.\n *\n * @private\n */\nclass IOFlatMap<A, B> extends IO<B> {\n  readonly _funADType: \"flatMap\" = \"flatMap\"\n\n  constructor(\n    public readonly source: IO<A>,\n    public readonly f: ((a: A) => IO<B>),\n    public readonly g?: ((e: Throwable) => IO<B>)) { super() }\n}\n\n/**\n * Type alias representing registration callbacks for tasks\n * created with `asyncUnsafe`, that are going to get executed\n * when the asynchronous task gets evaluated.\n */\nexport type IORegister<A> =\n  (context: IOContext, callback: (result: Try<A>) => void) => void\n\n/**\n * Constructs a lazy [[IO]] instance whose result will\n * be computed asynchronously.\n *\n * Unsafe to build directly, only use if you know what you're doing.\n * For building `Async` instances safely, see {@link IO.async}.\n *\n * @private\n * @hidden\n */\nclass IOAsync<A> extends IO<A> {\n  readonly _funADType: \"async\" = \"async\"\n\n  constructor(public readonly register: IORegister<A>) { super() }\n}\n\nclass IOMemoize<A> extends IO<A> {\n  readonly _funADType: \"memoize\" = \"memoize\"\n\n  public result: Try<A> | Future<A> | null\n  public source?: IO<A>\n  public readonly onlySuccess: boolean\n\n  constructor(source: IO<A>, onlySuccess: boolean) {\n    super()\n    this.source = source\n    this.result = null\n    this.onlySuccess = onlySuccess\n  }\n}\n\n/**\n * The `Context` under which {@link IO} is supposed to be executed.\n *\n * This definition is of interest only when creating\n * tasks with {@link IO.asyncUnsafe}, which exposes internals and\n * is considered unsafe to use.\n *\n * @final\n */\nexport class IOContext {\n  /**\n   * The `Scheduler` in charge of evaluating asynchronous boundaries\n   * on `run`.\n   */\n  public readonly scheduler: Scheduler\n\n  /**\n   * Is the `StackedCancelable` that accumulates cancelable\n   * actions, to be triggered if cancellation happens.\n   */\n  public readonly connection: StackedCancelable\n\n  /**\n   * Options passed to the run-loop implementation, determining\n   * its behavior. See {@link IOOptions} for the available\n   * options.\n   */\n  public readonly options: IOOptions\n\n  constructor(\n    scheduler: Scheduler,\n    connection: StackedCancelable = new StackedCancelable(),\n    options: IOOptions = { autoCancelableRunLoops: false }) {\n\n    this.scheduler = scheduler\n    this.options = options\n    this.connection = connection\n\n    // Enables auto-cancelable run-loops\n    if (options.autoCancelableRunLoops)\n      this.shouldCancel = () => connection.isCanceled()\n  }\n\n  /**\n   * Resets the stored `frameIndex`.\n   *\n   * Calling this method inside the logic of a {@link IO.asyncUnsafe}\n   * lets the run-loop know that an async boundary happened. This\n   * works in tandem with the logic for `ExecutionModel.batched(n)`,\n   * for better detection of synchronous cycles, to avoid introducing\n   * forced async boundaries where not needed.\n   */\n  markAsyncBoundary(): void {\n    this.scheduler.batchIndex = 0\n  }\n\n  /**\n   * Returns `true` in case the run-loop should be canceled,\n   * but this can only happen if `autoCancelableRunLoops` is\n   * set to `true`.\n   */\n  shouldCancel(): boolean { return false }\n}\n\n/**\n * Set of options for customizing IO's behavior.\n *\n * @param autoCancelableRunLoops should be set to `true` in\n *        case you want `flatMap` driven loops to be\n *        auto-cancelable. Defaults to `false` because of\n *        safety concerns.\n */\nexport type IOOptions = {\n  autoCancelableRunLoops: boolean\n}\n\n/** @hidden */\nfunction ioShift(ec?: Scheduler): IO<void> {\n  return IO.asyncUnsafe<void>((ctx, cb) => {\n    (ec || ctx.scheduler).executeAsync(() => cb(Try.unit()))\n  })\n}\n\n/** @hidden */\nconst ioShiftDefaultRef: IO<void> = ioShift()\n\n/** @hidden */\ntype Current = IO<any>\n/** @hidden */\ntype Bind = ((a: any) => IO<any>)\n/** @hidden */\ntype BindT = Bind | [Bind, Bind]\n/** @hidden */\ntype CallStack = Array<BindT>\n\n/** @hidden */\nfunction _ioPopNextBind(bFirst: BindT | null, bRest: CallStack | null): Bind | null {\n  let f: Bind | [Bind, Bind] | null | undefined = undefined\n  if (bFirst) f = bFirst\n  else if (bRest && bRest.length > 0) f = bRest.pop()\n  if (f) return typeof f === \"function\" ? f : f[0]\n  return null\n}\n\n/** @hidden */\nfunction _ioFindErrorHandler(bFirst: BindT | null, bRest: CallStack | null): Bind | null {\n  let cursor: any = bFirst\n  do {\n    if (cursor && typeof cursor !== \"function\") return cursor[1]\n    cursor = bRest ? bRest.pop() : null\n  } while (cursor)\n\n  return null\n}\n\n/**\n * We need to build a callback on each cycle involving an `IOAsync`\n * state. This class builds a mutable callback to reuse on each\n * cycle in order to reduce GC pressure.\n *\n * @hidden\n * @final\n */\nclass RestartCallback {\n  private canCall = false\n  private bFirst: BindT | null = null\n  private bRest: CallStack | null = null\n\n  public readonly asFunction: (result: Try<any>) => void\n\n  constructor(\n    private context: IOContext,\n    private callback: (r: Try<any>) => void) {\n\n    this.asFunction = this.signal.bind(this)\n  }\n\n  prepare(bFirst: BindT | null, bRest: CallStack | null) {\n    this.bFirst = bFirst\n    this.bRest = bRest\n    this.canCall = true\n  }\n\n  signal(result: Try<any>): void {\n    if (this.canCall) {\n      this.canCall = false\n      ioGenericRunLoop(\n        new IOPure(result),\n        this.context.scheduler,\n        this.context,\n        this.callback,\n        this,\n        this.bFirst,\n        this.bRest\n      )\n    } else if (result.isFailure()) {\n      this.context.scheduler.reportFailure(result.failed().get())\n    }\n  }\n}\n\n/** @hidden */\nfunction ioExecuteAsync(\n  register: IORegister<any>,\n  context: IOContext,\n  cb: (result: Try<any>) => void,\n  rcb: RestartCallback | null,\n  bFirst: BindT | null,\n  bRest: CallStack | null,\n  frameIndex: number) {\n\n  if (!context.shouldCancel()) {\n    context.scheduler.batchIndex = frameIndex\n\n    const restart = rcb || new RestartCallback(context, cb)\n    restart.prepare(bFirst, bRest)\n    register(context, restart.asFunction)\n  }\n}\n\n/** @hidden */\nfunction ioRestartAsync(\n  start: IO<any>,\n  context: IOContext,\n  cb: (result: Try<any>) => void,\n  rcb: RestartCallback | null,\n  bFirstInit: BindT | null,\n  bRestInit: CallStack | null): void {\n\n  if (!context.shouldCancel())\n    context.scheduler.executeAsync(() => {\n      ioGenericRunLoop(start, context.scheduler, context, cb, rcb, bFirstInit, bRestInit)\n    })\n}\n\n/** @hidden */\nfunction ioGenericRunLoop(\n  start: IO<any>,\n  scheduler: Scheduler,\n  context: IOContext | null,\n  cb: (result: Try<any>) => void,\n  rcb: RestartCallback | null,\n  bFirstInit: BindT | null,\n  bRestInit: CallStack | null): ICancelable | void {\n\n  let current: Current | Try<any> = start\n  let bFirst: BindT | null = bFirstInit\n  let bRest: CallStack | null = bRestInit\n\n  const modulus = scheduler.executionModel.recommendedBatchSize - 1\n  let frameIndex = scheduler.batchIndex\n\n  while (true) {\n    if (current instanceof Try) {\n      if (current.isSuccess()) {\n        const bind = _ioPopNextBind(bFirst, bRest)\n        if (!bind) {\n          scheduler.batchIndex = frameIndex\n          return cb(current)\n        }\n\n        try {\n          current = bind(current.get())\n        } catch (e) {\n          current = Try.failure(e)\n        }\n      } else {\n        const bind = _ioFindErrorHandler(bFirst, bRest)\n        if (!bind) {\n          scheduler.batchIndex = frameIndex\n          return cb(current)\n        }\n\n        try {\n          current = bind(current.failed().get())\n        } catch (e) {\n          current = Try.failure(e)\n        }\n      }\n\n      bFirst = null\n      const nextIndex = (frameIndex + 1) & modulus\n      // Should we force an asynchronous boundary?\n      if (nextIndex) {\n        frameIndex = nextIndex\n      } else {\n        const ctx = context || new IOContext(scheduler)\n        /* istanbul ignore next */\n        const boxed = current instanceof Try ? new IOPure(current) : current\n        ioRestartAsync(boxed, ctx, cb, rcb, bFirst, bRest)\n        return ctx.connection\n      }\n    }\n    else switch (current._funADType) {\n      case \"pure\":\n        current = (current as IOPure<any>).value\n        break\n\n      case \"always\":\n        current = Try.of((current as IOAlways<any>).thunk)\n        break\n\n      case \"once\":\n        current = (current as IOOnce<any>).runTry()\n        break\n\n      case \"flatMap\":\n        const flatM: IOFlatMap<any, any> = current as any\n        if (bFirst) {\n          if (!bRest) bRest = []\n          bRest.push(bFirst)\n        }\n\n        bFirst = !flatM.g ? flatM.f : [flatM.f, flatM.g]\n        current = flatM.source\n        break\n\n      case \"async\":\n        const async: IOAsync<any> = current as any\n        const ctx = context || new IOContext(scheduler)\n        ioExecuteAsync(async.register, ctx, cb, rcb, bFirst, bRest, frameIndex)\n        return ctx.connection\n\n      case \"memoize\":\n        const mem: IOMemoize<any> = current as any\n        return ioStartMemoize(mem, scheduler, context, cb, bFirst, bRest, frameIndex)\n    }\n  }\n}\n\n/** @hidden */\nfunction ioToFutureGoAsync(\n  start: IO<any>,\n  scheduler: Scheduler,\n  bFirst: BindT | null,\n  bRest: CallStack | null,\n  forcedAsync: boolean): Future<any> {\n\n  return Future.create<any>(cb => {\n    const ctx = new IOContext(scheduler)\n    if (forcedAsync)\n      ioRestartAsync(start as any, ctx, cb as any, null, bFirst, bRest)\n    else\n      ioGenericRunLoop(start as any, scheduler, ctx, cb as any, null, bFirst, bRest)\n\n    return ctx.connection\n  })\n}\n\n/** @hidden */\nfunction taskToFutureRunLoop(\n  start: IO<any>,\n  scheduler: Scheduler): Future<any> {\n\n  let current: Current | Try<any> = start\n  let bFirst: BindT | null = null\n  let bRest: CallStack | null = null\n\n  const modulus = scheduler.executionModel.recommendedBatchSize - 1\n  let frameIndex = scheduler.batchIndex\n\n  while (true) {\n    if (current instanceof Try) {\n      if (current.isSuccess()) {\n        const bind = _ioPopNextBind(bFirst, bRest)\n        if (!bind) {\n          scheduler.batchIndex = frameIndex\n          return Future.pure(current.get())\n        }\n\n        try {\n          current = bind(current.get())\n        } catch (e) {\n          current = new IOPure(Try.failure(e))\n        }\n      } else {\n        const err = current.failed().get()\n        const bind = _ioFindErrorHandler(bFirst, bRest)\n        if (!bind) {\n          scheduler.batchIndex = frameIndex\n          return Future.raise(err)\n        }\n\n        try {\n          current = bind(err)\n        } catch (e) {\n          current = new IOPure(Try.failure(e))\n        }\n      }\n\n      bFirst = null\n      const nextIndex = (frameIndex + 1) & modulus\n      // Should we force an asynchronous boundary?\n      if (nextIndex) {\n        frameIndex = nextIndex\n      } else {\n        return ioToFutureGoAsync(current, scheduler, bFirst, bRest, true)\n      }\n    }\n    else switch (current._funADType) {\n      case \"pure\":\n        current = (current as IOPure<any>).value\n        break\n\n      case \"always\":\n        current = Try.of((current as IOAlways<any>).thunk)\n        break\n\n      case \"once\":\n        current = (current as IOOnce<any>).runTry()\n        break\n\n      case \"flatMap\":\n        const flatM: IOFlatMap<any, any> = current as any\n        if (bFirst) {\n          if (!bRest) bRest = []\n          bRest.push(bFirst)\n        }\n\n        bFirst = !flatM.g ? flatM.f : [flatM.f, flatM.g]\n        current = flatM.source\n        break\n\n      case \"async\":\n      case \"memoize\":\n        return ioToFutureGoAsync(current, scheduler, bFirst, bRest, false)\n    }\n  }\n}\n\n/**\n * Internal utility used in the implementation of `IO.async`.\n *\n * @hidden\n */\nfunction ioSafeCallback<A>(\n  ec: Scheduler,\n  conn: StackedCancelable,\n  cb: (r: Try<A>) => void): ((r: Try<A>) => void) {\n\n  let called = false\n  return (r: Try<A>) => {\n    if (!called) {\n      called = true\n      // Inserting a light async boundary, otherwise we can have\n      // stack overflow issues, but also ordering issues with\n      // StackedCancelable.push in IO.async!\n      ec.trampoline(() => {\n        conn.pop()\n        cb(r)\n      })\n    } else if (r.isFailure()) {\n      ec.reportFailure(r.failed().get())\n    }\n  }\n}\n\n/** @hidden */\nfunction ioStartMemoize<A>(\n  fa: IOMemoize<A>,\n  ec: Scheduler,\n  context: IOContext | null,\n  cb: (r: Try<A>) => void,\n  bFirstInit: BindT | null,\n  bRestInit: CallStack | null,\n  frameIndex: number): ICancelable | void {\n\n  // Storing the current frameIndex because invoking this\n  // function effectively ends the current run-loop\n  ec.batchIndex = frameIndex\n  // The state that we'll use for subscribing listeners below\n  let state: Try<A> | Future<A>\n\n  // The first evaluation has to trigger the initial run-loop that\n  // will eventually set our completed state\n  if (fa.result) {\n    state = fa.result\n  } else {\n    // NOTE this isn't using the passed `IOContext`, or the bindings\n    // stack because it would be wrong. This has to be executed\n    // independently, within its own context.\n    const f = ioToFutureGoAsync(fa.source as any, ec, null, null, false)\n\n    if (f.value().isEmpty()) {\n      fa.result = f\n      state = f\n\n      f.onComplete(r => {\n        if (r.isSuccess() || !fa.onlySuccess) {\n          // Caching result for subsequent listeners\n          fa.result = r as any\n          // GC purposes\n          delete fa.source\n        } else {\n          // Reverting the state to the original IO reference, such\n          // that it can be retried again\n          fa.result = null\n        }\n      })\n    } else {\n      state = (f.value().get() as any) as Try<any>\n      // Not storing the state on memoizeOnSuccess if it's a failure\n      if (state.isSuccess() || !fa.onlySuccess)\n        fa.result = state as any\n    }\n  }\n\n  // We have the IOMemoize in an already completed state,\n  // so running with it\n  const io: IO<A> = state instanceof Try\n    ? new IOPure(state)\n    : IO.fromFuture(state)\n\n  ioGenericRunLoop(io, ec, context, cb, null, bFirstInit, bRestInit)\n}\n\n/**\n * Implementation for `IO.sequence`.\n * @hidden\n */\nfunction ioSequence<A>(list: IO<A>[] | Iterable<IO<A>>): IO<A[]> {\n  return IO.of(() => iteratorOf(list))\n    .flatMap(cursor => ioSequenceLoop([], cursor))\n}\n\n/**\n * Recursive loop that goes through the given `cursor`, element by\n * element, gathering the results of all generated `IO` elements.\n *\n * @hidden\n */\nfunction ioSequenceLoop<A>(acc: A[], cursor: IteratorLike<IO<A>>): IO<A[]> {\n  while (true) {\n    const elem = cursor.next()\n    const isDone = elem.done\n\n    if (elem.value) {\n      const io: IO<A> = elem.value\n      return io.flatMap(a => {\n        acc.push(a)\n        if (isDone) return IO.pure(acc)\n        return ioSequenceLoop(acc, cursor)\n      })\n    } else {\n      /* istanbul ignore else */\n      if (isDone) return IO.pure(acc)\n    }\n  }\n}\n\n/** @hidden */\nfunction ioListToFutureProcess<A, B>(list: IO<A>[] | Iterable<IO<A>>, f: (list: Future<A>[], ec: Scheduler) => Future<B>): IO<B> {\n  return IO.asyncUnsafe<B>((ctx, cb) => {\n    ctx.scheduler.trampoline(() => {\n      let streamErrors = true\n      try {\n        const futures: Future<A>[] = []\n        const array: IO<A>[] = execInternals.iterableToArray(list)\n        streamErrors = false\n\n        for (let i = 0; i < array.length; i++) {\n          const io = array[i]\n          const f = io.run(ctx.scheduler) as Future<A>\n          futures.push(f)\n        }\n\n        const all = f(futures, ctx.scheduler)\n        ctx.connection.push(all)\n        all.onComplete(ioSafeCallback(ctx.scheduler, ctx.connection, cb) as any)\n      } catch (e) {\n        /* istanbul ignore else */\n        if (streamErrors) cb(Failure(e))\n        else ctx.scheduler.reportFailure(e)\n      }\n    })\n  })\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IllegalArgumentError, NotImplementedError } from \"funfix-core\"\n\n/**\n * Given a type `T` representing instances of a class `C`, the type\n * `Constructor<T>` is the type of the class `C`.\n *\n * This type emulates\n * [Class<T> from Flow]{@link https://flow.org/en/docs/types/utilities/#classt-a-classtoc-idtoc-class-hreftoc-classa}.\n *\n * Note that in TypeScript constructors can also be `protected` or `private`\n * and unfortunately specifying `{ new(): T }` is thus insufficient.\n * Which is why, for classes without a public constructor, we have to\n * specify a `_funErasure` (static) member as a property, to help the compiler\n * infer type `T`.\n *\n * Example:\n *\n * ```typescript\n * class NumBox { constructor(public num: number) {} }\n * class GenBox<A> { constructor(public a: A) {} }\n *\n * function getDefault<F>(ref: Constructor<F>): Option<F> {\n *   if ((ref as any)._default) return Some(ref._default)\n *   return None\n * }\n *\n * (NumBox as any)._default = new NumBox(10)\n * (GenBox as any)._default = new GenBox(\"value\")\n *\n * const r1: Option<NumBox> = getDefault(NumBox)\n * const r2: Option<GenBox<any>> = getDefault(GenBox)\n * ```\n *\n * And for classes with a private constructor:\n *\n * ```typescript\n * class PrivateBox<A> {\n *   private constructor(public a: A) {}\n *\n *   static _funErasure: PrivateBox<any> // leaving undefined\n * }\n *\n * const F = PrivateBox as any\n * F._default = new F(\"hello\")\n *\n * const r: Option<PrivateBox<any>> = getDefault(NumBox)\n * ```\n */\nexport type Constructor<T> =\n  { new(...args: any[]): T } | { readonly _funErasure: T }\n\n/**\n * The `TypeClass` interface is to be implemented by type class\n * definitions, exposing IDs needed for discovery management.\n *\n * Only of interest to type class authors.\n */\nexport type TypeClass<F> = Constructor<F> & {\n  readonly _funTypeId: string\n  readonly _funSupertypeIds: string[]\n}\n\n/**\n * Lightweight encoding for higher kinded types.\n *\n * Inspired by the\n * [Lightweight higher-kinded polymorphism]{@link https://www.cl.cam.ac.uk/~jdy22/papers/lightweight-higher-kinded-polymorphism.pdf}\n * paper.\n *\n */\nexport interface HK<F, A> {\n  /** Trick for achieving nominal typing. */\n  readonly _funKindF: F\n\n  /** Trick for achieving nominal typing. */\n  readonly _funKindA: A\n}\n\n/**\n * Data type for expressing equivalence in type class laws.\n *\n * @final\n */\nexport class Equiv<A> {\n  private constructor(\n    public readonly lh: A,\n    public readonly rh: A) {}\n\n  static of<A>(lh: A, rh: A): Equiv<A> {\n    return new Equiv(lh, rh)\n  }\n}\n\n/**\n * Given a {@link TypeClass} definition in `tc`, register an `instance`\n * for the given {@link Constructor} specified by `c` that implements the\n * given type class.\n *\n * Example:\n *\n * ```typescript\n * registerTypeClassInstance(Functor)(Box, new BoxFunctorInstance())\n * ```\n *\n * Data types can have only one implementation for a given type class.\n * Multiple implementations are not allowed, therefore registration needs\n * to happen at most once. If registration happens multiple times for\n * instances of the same data type and type class, then an exception is\n * going to be raised:\n *\n * ```typescript\n * // Ok\n * registerTypeClassInstance(Functor)(Box, new FunctorInstance1())\n *\n * // IllegalArgumentError: Type class coherence issue,\n * // Functor<Box> is already defined!\n * registerTypeClassInstance(Functor)(Box, new FunctorInstance1())\n * ```\n *\n * Note that type classes can have super types. So for example registering\n * a `Monad` instance will also register a `Functor` instance, along with\n * `Applicative`. The registration of supertypes however does not trigger\n * coherence errors. In this example, if you try registering a `Monad`,\n * but a `Functor` was already registered, then that the given `Monad`\n * will simply not be registered as a `Functor` for that data type.\n *\n * This is legal:\n *\n * ```typescript\n * // Ok\n * registerTypeClassInstance(Functor)(Box, new FunctorInstance())\n *\n * // Ok, even though a Monad is also a Functor\n * registerTypeClassInstance(Functor)(Box, new MonadInstance())\n * ```\n *\n * @throws `IllegalArgumentError` in case such a type class instance\n * was already specified, thus leading to a coherence issue.\n */\nexport function registerTypeClassInstance<F>(tc: TypeClass<F>):\n  <T>(c: Constructor<T>, instance: F) => void {\n\n  return <T>(c: Constructor<T>, instance: F) => {\n    const obj = c as any\n    const types: {[id: string]: any} = (obj[\"_funTypes\"] || {})\n    obj[\"_funTypes\"] = types\n\n    const existing = types[tc._funTypeId]\n    if (existing) {\n      // If trying to register the same instance, then ignore\n      if (existing === instance) return\n      // Coherence issue\n      const name = existing.constructor.name\n      throw new IllegalArgumentError(\n        \"Type class coherence issue, \" +\n        `${name}<${(c as any).name}> is already defined!`\n      )\n    }\n\n    types[tc._funTypeId] = instance\n    for (const id of tc._funSupertypeIds) {\n      if (!types[id]) types[id] = instance\n    }\n  }\n}\n\n/**\n * Given a {@link TypeClass} instance and a {@link Constructor} reference,\n * returns its associated type class implementation if it exists, or throws\n * a `NotImplementedError` in case there's no such association.\n *\n * ```typescript\n * import { Option, Functor, getTypeClass } from \"funfix\"\n *\n * const F: Functor<Option<any>> = getTypeClass(Functor, Option)\n * ```\n */\nexport function getTypeClassInstance<F>(tc: TypeClass<F>):\n  <T>(c: Constructor<T>) => F {\n\n  return <T>(c: Constructor<T>) => {\n    const obj = c as any\n    const types: {[id: string]: any} = obj[\"_funTypes\"] || {}\n    const instance = types[tc._funTypeId]\n    if (instance) return instance as any\n    throw new NotImplementedError(`${(tc as any).name}<${obj.name}>`)\n  }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Constructor, getTypeClassInstance } from \"./kinds\"\nimport { is } from \"funfix-core\"\n\n/**\n * The `Eq` is a type class used to determine equality between 2\n * instances of the same type. Any 2 instances `x` and `y` are equal\n * if `eqv(x, y)` is `true`. Moreover, `eqv` should form an\n * equivalence relation.\n *\n * Example:\n *\n * ```typescript\n * const F = eqOf(Option)\n *\n * F.eqv(Some(1), Some(1)) // true\n * F.eqv(Some(1), None)    // false\n * ```\n *\n * MUST obey the laws defined in {@link EqLaws}.\n *\n * CREDITS: this type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class Eq<A> {\n  abstract eqv(lh: A, rh: A): boolean\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"eq\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = []\n  /** @hidden */\n  static readonly _funErasure: Eq<any>\n\n  /**\n   * Tests equality for two values of type `A` by using the type's\n   * registered `Eq` instance, falling back to the universal equality\n   * defined by `is` and `IEquals` (in `funfix-core`) in case no such\n   * `Eq<A>` is implemented.\n   */\n  static testEq<A>(lh: A, rh: A): boolean {\n    if (!lh) return is(lh, rh)\n    const types: {[id: string]: any} = (lh as any).constructor[\"_funTypes\"] || {}\n    const instance = types[Eq._funTypeId]\n    if (instance) return instance.eqv(lh, rh)\n    // Fallback to IEquals or reference equality\n    return is(lh, rh)\n  }\n}\n\n/**\n * Type class laws defined for {@link Eq}.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class EqLaws<A> {\n  /**\n   * The {@link Eq} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: Eq<A>\n\n  /**\n   * Equality is reflexive, i.e.\n   * ```\n   * a == a\n   * ```\n   */\n  reflexive(a: A): boolean {\n    return this.F.eqv(a, a)\n  }\n\n  /**\n   * Equality is symmetric, i.e.\n   * ```\n   * x == y <-> y == x\n   * ```\n   */\n  symmetric(x: A, y: A): boolean {\n    return this.F.eqv(x, y) === this.F.eqv(y, x)\n  }\n\n  /**\n   * Equality is transitive, i.e.\n   * ```\n   * x == y && y == z -> x == z\n   * ```\n   */\n  transitive(x: A, y: A, z: A): boolean {\n    return !(this.F.eqv(x, y) && this.F.eqv(y, z)) || this.F.eqv(x, z)\n  }\n}\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link Eq} instance if it exists, or throws a `NotImplementedError`\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, Eq, eqOf } from \"funfix\"\n *\n * const F: Eq<Option<any>> = eqOf(Option)\n * ```\n */\nexport const eqOf: <F>(c: Constructor<F>) => Eq<F> =\n  getTypeClassInstance(Eq)\n\n/**\n * Given an {@link Eq} instance, returns the {@link EqLaws}\n * associated with it.\n */\nexport function eqLawsOf<A>(instance: Eq<A>): EqLaws<A> {\n  return new (class extends EqLaws<A> { public readonly F = instance })()\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { id } from \"funfix-core\"\nimport { HK, Equiv, Constructor, getTypeClassInstance } from \"./kinds\"\n\n/**\n * The `Functor` is a type class providing the `map` operation that\n * allows lifting an `f` function into the functor context and\n * applying it.\n *\n * The name is short for \"covariant functor\".\n *\n * Example:\n *\n * ```typescript\n * const F = functorOf(Option)\n *\n * F.map(Some(1), x => x + 1) // Some(2)\n * ```\n *\n * MUST obey the laws defined in {@link FunctorLaws}.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import { HK, Functor, registerTypeClassInstance } from \"funfix\"\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: T) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note these can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * // Type alias defined for readability\n * type BoxK<T> = HK<Box<any>, T>\n *\n * // Actual implementation\n * class BoxFunctor implements Functor<Box<any>> {\n *   map<A, B>(fa: BoxK<A>, f: (a: A) => B): Box<B> {\n *     const a = (fa as Box<A>).value\n *     return new Box(f(a))\n *   }\n * }\n *\n * // Registering global Functor instance for Box\n * registerTypeClassInstance(Functor)(Box, new BoxFunctor())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class Functor<F> {\n  /**\n   * Given a mapping function, transforms the source.\n   *\n   * The `map` operation must follow these laws:\n   *\n   * - `fa.map(id) <-> fa`\n   * - `fa.map(f).map(g) <-> fa.map(x => g(f(x)))`\n   */\n  abstract map<A, B>(fa: HK<F, A>, f: (a: A) => B): HK<F, B>\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"functor\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = []\n  /** @hidden */\n  static readonly _funErasure: Functor<any>\n}\n\n/**\n * Type class laws defined for {@link Functor}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class FunctorLaws<F> {\n  /**\n   * The {@link Functor} designated instance for `F`,\n   * to be tested.\n   */\n  abstract readonly F: Functor<F>\n\n  /**\n   * ```typescript\n   * fa.map(id) <-> fa\n   * ```\n   */\n  covariantIdentity<A>(fa: HK<F, A>): Equiv<HK<F, A>> {\n    return Equiv.of(this.F.map(fa, id), fa)\n  }\n\n  /**\n   * ```typescript\n   * fa.map(f).map(g) <-> fa.map(x => g(f(x)))\n   * ```\n   */\n  covariantComposition<A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C): Equiv<HK<F, C>> {\n    return Equiv.of(\n      this.F.map(this.F.map(fa, f), g),\n      this.F.map(fa, x => g(f(x)))\n    )\n  }\n}\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link Functor} instance if it exists, or throws a `NotImplementedError`\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, Functor, functorOf } from \"funfix\"\n *\n * const F: Functor<Option<any>> = functorOf(Option)\n * ```\n */\nexport const functorOf: <F>(c: Constructor<F>) => Functor<F> =\n  getTypeClassInstance(Functor)\n\n/**\n * Given an {@link Functor} instance, returns the {@link FunctorLaws}\n * associated with it.\n */\nexport function functorLawsOf<F>(instance: Functor<F>): FunctorLaws<F> {\n  return new (class extends FunctorLaws<F> { public readonly F = instance })()\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HK, Equiv, Constructor, getTypeClassInstance } from \"./kinds\"\nimport { Functor, FunctorLaws } from \"./functor\"\nimport { Either, Right, Left, applyMixins } from \"funfix-core\"\n\n/**\n * The `Apply` type class, a weaker version of {@link Applicative},\n * exposing `ap` (apply), but not `pure`.\n *\n * This type class is exposed in addition to `Applicative` because\n * there are data types for which we can't implement `pure`, but\n * that could still benefit from an `ap` definition. For example\n * in case of a `Map<K, ?>` we couldn't define `pure` for it\n * because we don't have a `K` key.\n *\n * MUST obey the laws defined in {@link ApplyLaws}.\n *\n * Note that having an `Apply` instance implies that a\n * {@link Functor} implementation is also available, which is why\n * `Apply` is a subtype of `Functor`.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK, Apply,\n *   registerTypeClassInstance,\n *   applyMixins\n * } from \"funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: T) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note these can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxApply implements Apply<Box<any>> {\n *   map<A, B>(fa: BoxK<A>, f: (a: A) => B): Box<B> {\n *     const a = (fa as Box<A>).value\n *     return new Box(f(a))\n *   }\n *\n *   ap<A, B>(fa: BoxK<A>, ff: BoxK<(a: A) => B>): Box<B> {\n *     const a = (fa as Box<A>).value\n *     const f = (ff as Box<(a: A) => B>).value\n *     return new Box(f(a))\n *   }\n *\n *   // Mixed-in, as these have default implementations\n *   map2: <A, B, Z>(fa: BoxK<A>, fb: BoxK<B>, f: (a: A, b: B) => Z) => Box<Z>\n *   product: <A, B> (fa: BoxK<A>, fb: BoxK<B>) => Box<[A, B]>\n * }\n *\n * // Call needed in order to implement `map2` and `product` using\n * // the default implementations defined by `Apply`, because\n * // we are using `implements` instead of `extends` above and\n * // because in this sample we want the default implementations,\n * // but note that you can always provide your own definitions\n * applyMixins(BoxApply, [Apply])\n *\n * // Registering global Apply instance for Box, needed in order\n * // for the `applyOf(Box)` calls to work\n * registerTypeClassInstance(Apply)(Box, new BoxApply())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class Apply<F> implements Functor<F> {\n  /**\n   * Given a value and a function in the `Apply` context,\n   * applies the function to the value.\n   */\n  abstract ap<A, B>(fa: HK<F, A>, ff: HK<F, (a: A) => B>): HK<F, B>\n\n  /** Inherited from {@link Functor.map}. */\n  abstract map<A, B>(fa: HK<F, A>, f: (a: A) => B): HK<F, B>\n\n  /**\n   * Applies the pure (binary) function `f` to the effectful values\n   * `fa` and `fb`.\n   *\n   * `map2` can be seen as a binary version of {@link Functor.map}.\n   */\n  map2<A, B, Z>(fa: HK<F, A>, fb: HK<F, B>, f: (a: A, b: B) => Z): HK<F, Z> {\n    return this.ap(fb, this.map(fa, a => (b: B) => f(a, b)))\n  }\n\n  /**\n   * Captures the idea of composing independent effectful values.\n   *\n   * It is of particular interest when taken together with [[Functor]].\n   * Where [[Functor]] captures the idea of applying a unary pure\n   * function to an effectful value, calling `product` with `map`\n   * allows one to apply a function of arbitrary arity to multiple\n   * independent effectful values.\n   *\n   * This operation is equivalent with:\n   *\n   * ```typescript\n   * map2(fa, fb, (a, b) => [a, b])\n   * ```\n   */\n  product<A, B>(fa: HK<F, A>, fb: HK<F, B>): HK<F, [A, B]> {\n    return this.map2(fa, fb, (a: A, b: B) => [a, b] as [A, B])\n  }\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"apply\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = [\"functor\"]\n  /** @hidden */\n  static readonly _funErasure: Apply<any>\n}\n\napplyMixins(Apply, [Functor])\n\n/**\n * Type class laws defined for {@link Apply}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class ApplyLaws<F> implements FunctorLaws<F> {\n  /**\n   * The {@link Apply} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: Apply<F>\n\n  applyComposition<A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>): Equiv<HK<F, C>> {\n    const F = this.F\n    const compose = (f: (b: B) => C) => (\n      (g: (a: A) => B) => (a: A) => f(g(a))\n    )\n\n    return Equiv.of(\n      F.ap(F.ap(fa, fab), fbc),\n      F.ap(fa, F.ap(fab, F.map(fbc, compose)))\n    )\n  }\n\n  applyProductConsistency<A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.ap(fa, f),\n      F.map(F.product(f, fa), p => { const [f, a] = p; return f(a) })\n    )\n  }\n\n  applyMap2Consistency<A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.ap(fa, f),\n      F.map2(f, fa, (f, a) => f(a))\n    )\n  }\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n}\n\napplyMixins(ApplyLaws, [FunctorLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link Apply} instance if it exists, or throws a `NotImplementedError`\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, Apply, applyOf } from \"funfix\"\n *\n * const F: Apply<Option<any>> = applyOf(Option)\n * ```\n */\nexport const applyOf: <F>(c: Constructor<F>) => Apply<F> =\n  getTypeClassInstance(Apply)\n\n/**\n * Given an {@link Apply} instance, returns the {@link ApplyLaws}\n * associated with it.\n */\nexport function applyLawsOf<F>(instance: Apply<F>): ApplyLaws<F> {\n  return new (class extends ApplyLaws<F> { public readonly F = instance })()\n}\n\n/**\n * `Applicative` functor type class.\n *\n * Allows application of a function in an Applicative context to a\n * value in an `Applicative` context.\n *\n * References:\n *\n * - [The Essence of the Iterator Pattern]{@link https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf}\n * - [Applicative programming with effects]{@link http://staff.city.ac.uk/~ross/papers/Applicative.pdf}\n *\n * Example:\n *\n * ```typescript\n * const F = applicativeOf(Option)\n *\n * F.ap(F.pure(1), F.pure((x: number) => x + 1)) // Some(2)\n * ```\n *\n * Note that having an `Applicative` instance implies\n * {@link Functor} and {@link Apply} implementations are also\n * available, which is why `Applicative` is a subtype of\n * `Functor` and `Apply`.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK, Applicative,\n *   registerTypeClassInstance,\n *   applyMixins\n * } from \"funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: T) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note they can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxApplicative implements Applicative<Box<any>> {\n *   pure<A>(a: A): Box<A> { return new Box(a) }\n *\n *   ap<A, B>(fa: BoxK<A>, ff: BoxK<(a: A) => B>): Box<B> {\n *     const a = (fa as Box<A>).value\n *     const f = (ff as Box<(a: A) => B>).value\n *     return new Box(f(a))\n *   }\n *\n *   // Mixed-in, as these have default implementations\n *   map: <A, B>(fa: BoxK<A>, f: (a: A) => B) => Box<B>\n *   map2: <A, B, Z>(fa: BoxK<A>, fb: BoxK<B>, f: (a: A, b: B) => Z) => Box<Z>\n *   product: <A, B> (fa: BoxK<A>, fb: BoxK<B>) => Box<[A, B]>\n *   unit: () => Box<void>\n * }\n *\n * // Call needed in order to implement `map`, `map2`, `product` and `unit`,\n * // using the default implementations defined by `Applicative`, because\n * // we are using `implements` instead of `extends` above and\n * // because in this sample we want the default implementations,\n * // but note that you can always provide your own\n * applyMixins(BoxApplicative, [Applicative])\n *\n * // Registering global Applicative instance for Box, needed in order\n * // for the `functorOf(Box)`, `applyOf(Box)` and `applicativeOf(Box)`\n * // calls to work\n * registerTypeClassInstance(Applicative)(Box, new BoxApplicative())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class Applicative<F> implements Apply<F> {\n  /**\n   * Lifts a strict value `A` into the `F<A>` context.\n   */\n  abstract pure<A>(a: A): HK<F, A>\n\n  /** Inherited from {@link Apply.ap}. */\n  abstract ap<A, B>(fa: HK<F, A>, ff: HK<F, (a: A) => B>): HK<F, B>\n\n  /**\n   * Shorthand for `pure<void>(undefined)`, provided for convenience\n   * and because implementations can override the default for\n   * optimization purposes.\n   */\n  unit(): HK<F, void> {\n    return this.pure(undefined)\n  }\n\n  /** Inherited from {@link Functor.map}. */\n  map<A, B>(fa: HK<F, A>, f: (a: A) => B): HK<F, B> {\n    return this.ap(fa, this.pure(f))\n  }\n\n  /** Mixed-in from {@link Apply.map2}. */\n  map2: <A, B, Z>(fa: HK<F, A>, fb: HK<F, B>, f: (a: A, b: B) => Z) => HK<F, Z>\n  /** Mixed-in from {@link Apply.product}. */\n  product: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => HK<F, [A, B]>\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"applicative\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = [\"functor\", \"apply\"]\n  /** @hidden */\n  static readonly _funErasure: Applicative<any>\n}\n\napplyMixins(Applicative, [Apply])\n\n/**\n * Type class laws defined for {@link Applicative}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class ApplicativeLaws<F> implements ApplyLaws<F> {\n  /**\n   * The {@link Applicative} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: Applicative<F>\n\n  applicativeIdentity<A>(fa: HK<F, A>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(\n      F.ap(fa, F.pure((a: A) => a)),\n      fa\n    )\n  }\n\n  applicativeHomomorphism<A, B>(a: A, f: (a: A) => B): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.ap(F.pure(a), F.pure(f)),\n      F.pure(f(a))\n    )\n  }\n\n  applicativeInterchange<A, B>(a: A, ff: HK<F, (a: A) => B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.ap(F.pure(a), ff),\n      F.ap(ff, F.pure((f: (a: A) => B) => f(a)))\n    )\n  }\n\n  applicativeMap<A, B>(fa: HK<F, A>, f: (a: A) => B): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.map(fa, f),\n      F.ap(fa, F.pure(f))\n    )\n  }\n\n  applicativeComposition<A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>): Equiv<HK<F, C>> {\n    const F = this.F\n    const compose = (f: (b: B) => C) => (\n      (g: (a: A) => B) => (a: A) => f(g(a))\n    )\n\n    return Equiv.of(\n      F.ap(fa, F.ap(fab, F.ap(fbc, F.pure(compose)))),\n      F.ap(F.ap(fa, fab), fbc)\n    )\n  }\n\n  applicativeUnit<A>(a: A): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(F.map(F.unit(), _ => a), F.pure(a))\n  }\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n\n  /** Mixed-in from {@link ApplyLaws.applyComposition}. */\n  applyComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link ApplyLaws.applyProductConsistency}. */\n  applyProductConsistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplyLaws.applyMap2Consistency}. */\n  applyMap2Consistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n}\n\napplyMixins(ApplicativeLaws, [ApplyLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link Applicative} instance if it exists, or throws a `NotImplementedError`\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, Applicative, applicativeOf } from \"funfix\"\n *\n * const F: Applicative<Option<any>> = applicativeOf(Option)\n * ```\n */\nexport const applicativeOf: <F>(c: Constructor<F>) => Applicative<F> =\n  getTypeClassInstance(Applicative)\n\n/**\n * Given an {@link Applicative} instance, returns the {@link ApplicativeLaws}\n * associated with it.\n */\nexport function applicativeLawsOf<F>(instance: Applicative<F>): ApplicativeLaws<F> {\n  return new (class extends ApplicativeLaws<F> { public readonly F = instance })()\n}\n\n/**\n * The `ApplicativeError` type class is a {@link Applicative} that\n * also allows you to raise and or handle an error value.\n *\n * This type class allows one to abstract over error-handling\n * applicative types.\n *\n * MUST follow the law defined in {@link ApplicativeErrorLaws}.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK,\n *   ApplicativeError,\n *   registerTypeClassInstance,\n *   applyMixins,\n *   Try\n * } from \"funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: Try<T>) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note they can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxApplicativeError implements ApplicativeError<Box<any>, any> {\n *   pure<A>(a: A): Box<A> { return new Box(Try.success(a)) }\n *\n *   ap<A, B>(fa: BoxK<A>, ff: BoxK<(a: A) => B>): Box<B> {\n *     const ta = (fa as Box<A>).value\n *     const tf = (ff as Box<(a: A) => B>).value\n *     return new Box(Try.map2(ta, tf, (a, f) => f(a)))\n *   }\n *\n *   raise<A>(e: any): HK<Box<any>, A> {\n *     return new Box(Try.failure(e))\n *   }\n *\n *   recoverWith<A>(fa: BoxK<A>, f: (e: any) => BoxK<A>): HK<Box<any>, A> {\n *     return new Box((fa as Box<A>).value.recoverWith(e => (f(e) as Box<A>).value))\n *   }\n *\n *   // Mixed-in, as these have default implementations\n *   map: <A, B>(fa: BoxK<A>, f: (a: A) => B) => Box<B>\n *   map2: <A, B, Z>(fa: BoxK<A>, fb: BoxK<B>, f: (a: A, b: B) => Z) => Box<Z>\n *   product: <A, B> (fa: BoxK<A>, fb: BoxK<B>) => Box<[A, B]>\n *   unit: () => Box<void>\n *   recover: <A>(fa: HK<Box<any>, A>, f: (e: any) => A) => HK<Box<any>, A>\n *   attempt: <A>(fa: HK<Box<any>, A>) => HK<Box<any>, Either<any, A>>\n * }\n *\n * // Call needed in order to implement `map`, `map2`, `product`, etc.\n * // using the default implementations defined by `ApplicativeError`,\n * // because we are using `implements` instead of `extends` above and\n * // because in this sample we want the default implementations,\n * // but note that you can always provide your own\n * applyMixins(BoxApplicativeError, [ApplicativeError])\n *\n * // Registering global ApplicativeError instance for Box, needed in order\n * // for the `functorOf(Box)`, `applyOf(Box)`, `applicativeOf(Box)`\n * // and `applicativeErrorOf(Box)` calls to work\n * registerTypeClassInstance(ApplicativeError)(Box, new BoxApplicativeError())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class ApplicativeError<F, E> implements Applicative<F> {\n  /**\n   * Lift an error into the `F` context.\n   */\n  abstract raise<A>(e: E): HK<F, A>\n\n  /**\n   * Handle any error, potentially recovering from it, by mapping it to an\n   * `F<A>` value.\n   *\n   * @see {@link recover} to handle any error by simply mapping it to an `A`\n   * value instead of an `F<A>`.\n   */\n  abstract recoverWith<A>(fa: HK<F, A>, f: (e: E) => HK<F, A>): HK<F, A>\n\n  /**\n   * Handle any error by mapping it to an `A` value.\n   *\n   * @see {@link recoverWith} to map to an `F[A]` value instead of\n   * simply an `A` value.\n   */\n  recover<A>(fa: HK<F, A>, f: (e: E) => A): HK<F, A> {\n    const F = this\n    return F.recoverWith(fa, e => F.pure(f(e)))\n  }\n\n  /**\n   * Handle errors by turning them into `Either` values.\n   *\n   * If there is no error, then a `Right` value will be returned.\n   * All non-fatal errors should be handled by this method.\n   */\n  attempt<A>(fa: HK<F, A>): HK<F, Either<E, A>> {\n    const F = this\n    return F.recover(\n      F.map(fa, a => Either.right<E, A>(a)),\n      Left)\n  }\n\n  /** Inherited from {@link Applicative.pure}. */\n  abstract pure<A>(a: A): HK<F, A>\n\n  /** Inherited from {@link Applicative.ap}. */\n  abstract ap<A, B>(fa: HK<F, A>, ff: HK<F, (a: A) => B>): HK<F, B>\n\n  /** Mixed-in from {@link Applicative.unit}. */\n  unit: () => HK<F, void>\n  /** Mixed-in from {@link Applicative.map}. */\n  map: <A, B>(fa: HK<F, A>, f: (a: A) => B) => HK<F, B>\n  /** Mixed-in from {@link Apply.map2}. */\n  map2: <A, B, Z>(fa: HK<F, A>, fb: HK<F, B>, f: (a: A, b: B) => Z) => HK<F, Z>\n  /** Mixed-in from {@link Apply.product}. */\n  product: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => HK<F, [A, B]>\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"applicativeError\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = [\"functor\", \"apply\", \"applicative\"]\n  /** @hidden */\n  static readonly _funErasure: ApplicativeError<any, any>\n}\n\napplyMixins(ApplicativeError, [Applicative])\n\n/**\n * Type class laws defined for {@link ApplicativeError}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class ApplicativeErrorLaws<F, E> implements ApplicativeLaws<F> {\n  /**\n   * The {@link Applicative} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: ApplicativeError<F, E>\n\n  applicativeErrorRecoverWith<A>(e: E, f: (e: E) => HK<F, A>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(F.recoverWith(F.raise<A>(e), f), f(e))\n  }\n\n  applicativeErrorRecover<A>(e: E, f: (e: E) => A): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(F.recover(F.raise<A>(e), f), F.pure(f(e)))\n  }\n\n  recoverWithPure<A>(a: A, f: (e: E) => HK<F, A>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(F.recoverWith(F.pure(a), f), F.pure(a))\n  }\n\n  recoverPure<A>(a: A, f: (e: E) => A): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(F.recover(F.pure(a), f), F.pure(a))\n  }\n\n  raiseErrorAttempt(e: E): Equiv<HK<F, Either<E, void>>> {\n    const F = this.F\n    return Equiv.of(F.attempt(F.raise<void>(e)), F.pure(Left(e)))\n  }\n\n  pureAttempt<A>(a: A): Equiv<HK<F, Either<E, A>>> {\n    const F = this.F\n    return Equiv.of(F.attempt(F.pure(a)), F.pure(Right(a)))\n  }\n\n  /** Mixed-in from {@link ApplicativeLaws.applicativeIdentity}. */\n  applicativeIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeHomomorphism}. */\n  applicativeHomomorphism: <A, B>(a: A, f: (a: A) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeInterchange}. */\n  applicativeInterchange: <A, B>(a: A, ff: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeMap}. */\n  applicativeMap: <A, B>(fa: HK<F, A>, f: (a: A) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeComposition}. */\n  applicativeComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeUnit}. */\n  applicativeUnit: <A>(a: A) => Equiv<HK<F, A>>\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n\n  /** Mixed-in from {@link ApplyLaws.applyComposition}. */\n  applyComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link ApplyLaws.applyProductConsistency}. */\n  applyProductConsistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplyLaws.applyMap2Consistency}. */\n  applyMap2Consistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n}\n\napplyMixins(ApplicativeErrorLaws, [ApplicativeLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link ApplicativeError} instance if it exists, or throws a `NotImplementedError`\n * in case there's no such association.\n *\n * ```typescript\n * import { Eval, ApplicativeError, applicativeErrorOf } from \"funfix\"\n *\n * const F: ApplicativeError<Option<any>> = applicativeErrorOf(Eval)\n * ```\n */\nexport const applicativeErrorOf: <F, E>(c: Constructor<F>) => ApplicativeError<F, E> =\n  getTypeClassInstance(ApplicativeError)\n\n/**\n * Given an {@link ApplicativeError} instance, returns the\n * {@link ApplicativeErrorLaws} associated with it.\n */\nexport function applicativeErrorLawsOf<F,E>(instance: ApplicativeError<F,E>): ApplicativeErrorLaws<F,E> {\n  return new (class extends ApplicativeErrorLaws<F,E> { public readonly F = instance })()\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Either, Right, Left, applyMixins } from \"funfix-core\"\nimport { HK, Equiv, Constructor, getTypeClassInstance } from \"./kinds\"\nimport {\n  Apply,\n  ApplyLaws,\n  Applicative,\n  ApplicativeLaws,\n  ApplicativeError,\n  ApplicativeErrorLaws\n} from \"./applicative\"\n\n/**\n * The `FlatMap` type class is a lightweight {@link Monad}.\n *\n * It exposes [flatMap]{@link FlatMap.flatMap}, which allows to have a\n * value in a context (`F<A>`) and then feed that into a function that\n * takes a normal value and returns a value in a context\n * (`A => F<B>`).\n *\n * One motivation for separating this out from `Monad` is that there are\n * situations where we can implement `flatMap` but not `pure`. For example,\n * we can implement `map` or `flatMap` that transforms the values of a\n * `Map<K, ?>` type, but we can't implement `pure` (because we wouldn't\n * know what key to use when instantiating the new `Map`).\n *\n * Must obey the laws defined in {@link FlatMapLaws}.\n *\n * Note that having an `Monad` instance implies\n * {@link Functor} and {@link Apply} implementations are also available,\n * as `FlatMap` is a subtype of these.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK, FlatMap, Either,\n *   registerTypeClassInstance,\n *   applyMixins\n * } from \"../src/funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: T) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note they can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxFlatMap implements FlatMap<Box<any>> {\n *   map<A, B>(fa: BoxK<A>, f: (a: A) => B): Box<B> {\n *     return new Box(f((fa as Box<A>).value))\n *   }\n *\n *   flatMap<A, B>(fa: BoxK<A>, f: (a: A) => BoxK<B>): Box<B> {\n *     return f((fa as Box<A>).value) as Box<B>\n *   }\n *\n *   tailRecM<A, B>(a: A, f: (a: A) => BoxK<Either<A, B>>): Box<B> {\n *     let cursor = a\n *     while (true) {\n *       const box = f(cursor) as Box<Either<A, B>>\n *       const v = box.value\n *       if (v.isRight()) return new Box(v.get())\n *       cursor = v.swap().get()\n *     }\n *   }\n *\n *   // Mixed-in, as these have default implementations\n *   map2: <A, B, Z>(fa: BoxK<A>, fb: BoxK<B>, f: (a: A, b: B) => Z) => Box<Z>\n *   ap: <A, B>(fa: BoxK<A>, ff: BoxK<(a: A) => B>) => Box<B>\n *   product: <A, B> (fa: BoxK<A>, fb: BoxK<B>) => Box<[A, B]>\n *   unit: () => Box<void>\n *   followedBy: <A, B>(fa: BoxK<A>, fb: BoxK<B>) => Box<B>\n *   followedByL: <A, B>(fa: BoxK<A>, fb: () => BoxK<B>) => Box<B>\n *   forEffect: <A, B>(fa: BoxK<A>, fb: BoxK<B>) => Box<A>\n *   forEffectL: <A, B>(fa: BoxK<A>, fb: () => BoxK<B>) => Box<A>\n * }\n *\n * // Call needed in order to implement `map`, `map2`, `product`, etc.\n * // using the default implementations defined by `FlatMap`, because\n * // we are using `implements` instead of `extends` above and\n * // because in this sample we want the default implementations,\n * // but note that you can always provide your own\n * applyMixins(BoxFlatMap, [FlatMap])\n *\n * // Registering global Functor instance for Box, needed in order\n * // for the `functorOf(Box)`, `applyOf(Box)`, `applicativeOf(Box)`\n * // and `flatMapOf(Box)` calls to work\n * registerTypeClassInstance(FlatMap)(Box, new BoxFunctor())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class FlatMap<F> implements Apply<F> {\n  abstract flatMap<A, B>(fa: HK<F, A>, f: (a: A) => HK<F, B>): HK<F, B>\n\n  /** Inherited from {@link Functor.map}. */\n  abstract map<A, B>(fa: HK<F, A>, f: (a: A) => B): HK<F, B>\n\n  /**\n   * Keeps calling `f` until a `Right(b)` is returned.\n   *\n   * Based on Phil Freeman's\n   * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.\n   *\n   * Implementations of this method should use constant stack space relative to `f`.\n   */\n  abstract tailRecM<A, B>(a: A, f: (a: A) => HK<F, Either<A, B>>): HK<F, B>\n\n  /**\n   * Sequentially compose two actions, discarding any value produced\n   * by the first.\n   *\n   * See [followedByL]{@link FlatMap.followedByL} for a lazy version.\n   */\n  followedBy<A, B>(fa: HK<F, A>, fb: HK<F, B>): HK<F, B> {\n    return this.flatMap(fa, _ => fb)\n  }\n\n  /**\n   * Sequentially compose two actions, discarding any value produced\n   * by the first.\n   *\n   * See [followedBy]{@link FlatMap.followedBy} for the strict version.\n   */\n  followedByL<A, B>(fa: HK<F, A>, fb: () => HK<F, B>): HK<F, B> {\n    return this.flatMap(fa, _ => fb())\n  }\n\n  /**\n   * Sequentially compose two actions, discarding any value\n   * produced by the second.\n   *\n   * See [forEffectL]{@link FlatMap.forEffectL} for the lazy version.\n   */\n  forEffect<A, B>(fa: HK<F, A>, fb: HK<F, B>): HK<F, A> {\n    return this.flatMap(fa, a => this.map(fb, _ => a))\n  }\n\n  /**\n   * Sequentially compose two actions, discarding any value\n   * produced by the second.\n   *\n   * See [forEffect]{@link FlatMap.forEffect} for the strict version.\n   */\n  forEffectL<A, B>(fa: HK<F, A>, fb: () => HK<F, B>): HK<F, A> {\n    return this.flatMap(fa, a => this.map(fb(), _ => a))\n  }\n\n  /** Inherited from {@link Apply.ap}. */\n  ap<A, B>(fa: HK<F, A>, ff: HK<F, (a: A) => B>): HK<F, B> {\n    return this.flatMap(fa, a => this.map(ff, f => f(a)))\n  }\n\n  /** Inherited from {@link Apply.map2}. */\n  map2<A, B, Z>(fa: HK<F, A>, fb: HK<F, B>, f: (a: A, b: B) => Z): HK<F, Z> {\n    return this.flatMap(fa, a => this.map(fb, b => f(a, b)))\n  }\n\n  /** Inherited from {@link Apply.product}. */\n  product<A, B>(fa: HK<F, A>, fb: HK<F, B>): HK<F, [A, B]> {\n    return this.flatMap(fa, a => this.map(fb, b => [a, b] as [A, B]))\n  }\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"flatMap\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = [\"functor\", \"apply\"]\n  /** @hidden */\n  static readonly _funErasure: FlatMap<any>\n}\n\n/**\n * Type class laws defined for {@link FlatMap}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class FlatMapLaws<F> implements ApplyLaws<F> {\n  /**\n   * The {@link Apply} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: FlatMap<F>\n\n  /**\n   * ```typescript\n   *  fa.flatMap(f).flatMap(g) <-> fa.flatMap(a => f(a).flatMap(g))\n   *  ```\n   */\n  flatMapAssociativity<A, B, C>(fa: HK<F, A>, f: (a: A) => HK<F, B>, g: (b: B) => HK<F, C>): Equiv<HK<F, C>> {\n    const F = this.F\n    return Equiv.of(\n      F.flatMap(F.flatMap(fa, f), g),\n      F.flatMap(fa, a => F.flatMap(f(a), g))\n    )\n  }\n\n  /**\n   * ```typescript\n   * fab.ap(fa) <-> fab.flatMap(f => fa.map(f))\n   * ```\n   */\n  flatMapConsistentApply<A, B>(fa: HK<F, A>, fab: HK<F, (a: A) => B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.ap(fa, fab),\n      F.flatMap(fab, f => F.map(fa, f))\n    )\n  }\n\n  /**\n   * ```typescript\n   * fa.followedBy(fb) <-> fa.flatMap(_ => fb)\n   * ```\n   */\n  followedByConsistency<A, B>(fa: HK<F, A>, fb: HK<F, B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.followedBy(fa, fb),\n      F.flatMap(fa, _ => fb)\n    )\n  }\n\n  /**\n   * ```typescript\n   * fa.followedBy(() => fb) <-> fa.flatMap(_ => fb)\n   * ```\n   */\n  followedByLConsistency<A, B>(fa: HK<F, A>, fb: HK<F, B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.followedByL(fa, () => fb),\n      F.flatMap(fa, _ => fb)\n    )\n  }\n\n  /**\n   * ```typescript\n   * fa.forEffect(fb) <-> fa.flatMap(a => fb.map(_ => a))\n   * ```\n   */\n  forEffectConsistency<A, B>(fa: HK<F, A>, fb: HK<F, B>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(\n      F.forEffect(fa, fb),\n      F.flatMap(fa, a => F.map(fb, _ => a))\n    )\n  }\n\n  /**\n   * ```typescript\n   * fa.forEffectL(() => fb) <-> fa.flatMap(a => fb.map(_ => a))\n   * ```\n   */\n  forEffectLConsistency<A, B>(fa: HK<F, A>, fb: HK<F, B>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(\n      F.forEffectL(fa, () => fb),\n      F.flatMap(fa, a => F.map(fb, _ => a))\n    )\n  }\n\n  tailRecMConsistentFlatMap<A>(a: A, f: (a: A) => HK<F, A>): Equiv<HK<F, A>> {\n    const F = this.F\n    const bounce = (n: number) => {\n      return F.tailRecM([a, n] as [A, number], x => {\n        const [a0, i] = x\n        return i > 0\n          ? F.map(f(a0), a1 => Left([a1, i - 1] as [A, number]))\n          : F.map(f(a0), Right)\n      })\n    }\n\n    /*\n     * The law is for n >= 1\n     * bounce(n) == bounce(n - 1).flatMap(f)\n     *\n     * Many monads blow up if n gets too large here (for instance List, becomes\n     * multiplicative, so the memory is exponential in n).\n     */\n    return Equiv.of(bounce(1), F.flatMap(bounce(0), f))\n  }\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n  /** Mixed in from {@link ApplyLaws.applyComposition}. */\n  applyComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed in from {@link ApplyLaws.applyProductConsistency}. */\n  applyProductConsistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed in from {@link ApplyLaws.applyMap2Consistency}. */\n  applyMap2Consistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n}\n\napplyMixins(FlatMapLaws, [ApplyLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link FlatMap} instance if it exists, or throws a `NotImplementedError`\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, FlatMap, flatMapOf } from \"funfix\"\n *\n * const F: FlatMap<Option<any>> = flatMapOf(Option)\n * ```\n */\nexport const flatMapOf: <F>(c: Constructor<F>) => FlatMap<F> =\n  getTypeClassInstance(FlatMap)\n\n/**\n * Given an {@link FlatMap} instance, returns the {@link FlatMapLaws}\n * associated with it.\n */\nexport function flatMapLawsOf<F>(instance: FlatMap<F>): FlatMapLaws<F> {\n  return new (class extends FlatMapLaws<F> { public readonly F = instance })()\n}\n\n/**\n * The `Monad` type class.\n *\n * Allows composition of dependent effectful functions.\n *\n * A `Monad` instance is defined by two operations:\n *\n * - `pure` from {@link Applicative}, which lifts an `A` value\n *    in the `F<A>` context\n * - `flatMap`, which allows us to have a value in a context (`F<A>`)\n *    and then feed that into a function that takes a normal value and\n *    returns a value in a context (`A => F<B>`)\n *\n * See [Monads for functional programming]{@link http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf},\n * by Philip Wadler.\n *\n * Must obey the laws defined in {@link MonadLaws}.\n *\n * Note that having an `Applicative` instance implies\n * {@link Functor}, {@link Apply}, {@link Applicative} and {@link FlatMap}\n * implementations are also available, as `Monad` is a subtype\n * of these type classes.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK, Monad, Either,\n *   registerTypeClassInstance,\n *   applyMixins\n * } from \"../src/funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: T) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note they can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxMonad implements Monad<Box<any>> {\n *   pure<A>(a: A): Box<A> { return new Box(a) }\n *\n *   flatMap<A, B>(fa: BoxK<A>, f: (a: A) => BoxK<B>): Box<B> {\n *     return f((fa as Box<A>).value) as Box<B>\n *   }\n *\n *   tailRecM<A, B>(a: A, f: (a: A) => BoxK<Either<A, B>>): Box<B> {\n *     let cursor = a\n *     while (true) {\n *       const box = f(cursor) as Box<Either<A, B>>\n *       const v = box.value\n *       if (v.isRight()) return new Box(v.get())\n *       cursor = v.swap().get()\n *     }\n *   }\n *\n *   // Mixed-in, as these have default implementations\n *   map: <A, B>(fa: BoxK<A>, f: (a: A) => B) => Box<B>\n *   map2: <A, B, Z>(fa: BoxK<A>, fb: BoxK<B>, f: (a: A, b: B) => Z) => Box<Z>\n *   ap: <A, B>(fa: BoxK<A>, ff: BoxK<(a: A) => B>) => Box<B>\n *   product: <A, B> (fa: BoxK<A>, fb: BoxK<B>) => Box<[A, B]>\n *   unit: () => Box<void>\n *   followedBy: <A, B>(fa: BoxK<A>, fb: BoxK<B>) => Box<B>\n *   followedByL: <A, B>(fa: BoxK<A>, fb: () => BoxK<B>) => Box<B>\n *   forEffect: <A, B>(fa: BoxK<A>, fb: BoxK<B>) => Box<A>\n *   forEffectL: <A, B>(fa: BoxK<A>, fb: () => BoxK<B>) => Box<A>\n * }\n *\n * // Call needed in order to implement `map`, `map2`, `product`, etc.\n * // using the default implementations defined by `Monad`, because\n * // we are using `implements` instead of `extends` above and\n * // because in this sample we want the default implementations,\n * // but note that you can always provide your own\n * applyMixins(BoxMonad, [Monad])\n *\n * // Registering global Monad instance for Box, needed in order\n * // for the `functorOf(Box)`, `applyOf(Box)`, `applicativeOf(Box)`,\n * // `flatMapOf(Box)` and `monadOf(Box)` calls to work\n * registerTypeClassInstance(Monad)(Box, new BoxFunctor())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class Monad<F> implements FlatMap<F>, Applicative<F> {\n  /** Inherited from {@link Applicative.pure}. */\n  abstract pure<A>(a: A): HK<F, A>\n\n  /** Inherited from {@link FlatMap.flatMap}. */\n  abstract flatMap<A, B>(fa: HK<F, A>, f: (a: A) => HK<F, B>): HK<F, B>\n\n  /** Inherited from {@link FlatMap.tailRecM}. */\n  abstract tailRecM<A, B>(a: A, f: (a: A) => HK<F, Either<A, B>>): HK<F, B>\n\n  /** Inherited from {@link Apply.ap}. */\n  ap<A, B>(fa: HK<F, A>, ff: HK<F, (a: A) => B>): HK<F, B> {\n    return this.flatMap(fa, a => this.map(ff, f => f(a)))\n  }\n\n  /** Inherited from {@link Functor.map}. */\n  map<A, B>(fa: HK<F, A>, f: (a: A) => B): HK<F, B> {\n    return this.flatMap(fa, a => this.pure(f(a)))\n  }\n\n  /** Inherited from {@link Apply.map2}. */\n  map2<A, B, Z>(fa: HK<F, A>, fb: HK<F, B>, f: (a: A, b: B) => Z): HK<F, Z> {\n    const F = this\n    return F.flatMap(fa, a => F.map(fb, b => f(a, b)))\n  }\n\n  /** Inherited from {@link Apply.product}. */\n  product<A, B>(fa: HK<F, A>, fb: HK<F, B>): HK<F, [A, B]> {\n    const F = this\n    return F.flatMap(fa, a => F.map(fb, b => [a, b] as [A, B]))\n  }\n\n  /** Mixed-in from {@link Applicative.unit}. */\n  unit: () => HK<F, void>\n  /** Mixed-in from {@link FlatMap.followedBy}. */\n  followedBy: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => HK<F, B>\n  /** Mixed-in from {@link FlatMap.followedByL}. */\n  followedByL: <A, B>(fa: HK<F, A>, fb: () => HK<F, B>) => HK<F, B>\n  /** Mixed-in from {@link FlatMap.forEffect}. */\n  forEffect: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => HK<F, A>\n  /** Mixed-in from {@link FlatMap.forEffectL}. */\n  forEffectL: <A, B>(fa: HK<F, A>, fb: () => HK<F, B>) => HK<F, A>\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"monad\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = [\"functor\", \"apply\", \"applicative\", \"flatMap\"]\n  /** @hidden */\n  static readonly _funErasure: Monad<any>\n}\n\napplyMixins(Monad, [Applicative, FlatMap])\n\n/**\n * Type class laws defined for {@link Monad}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class MonadLaws<F> implements ApplicativeLaws<F>, FlatMapLaws<F> {\n  /**\n   * The {@link Monad} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: Monad<F>\n\n  monadLeftIdentity<A, B>(a: A, f: (a: A) => HK<F, B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(F.flatMap(F.pure(a), f), f(a))\n  }\n\n  monadRightIdentity<A, B>(fa: HK<F, A>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(F.flatMap(fa, F.pure), fa)\n  }\n\n  mapFlatMapCoherence<A, B>(fa: HK<F, A>, f: (a: A) => B): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(F.flatMap(fa, a => F.pure(f(a))), F.map(fa, f))\n  }\n\n  tailRecMStackSafety(): Equiv<HK<F, number>> {\n    const F = this.F\n    const n = 10000\n    const res = F.tailRecM(0, i => F.pure(i < n ? Left(i + 1) : Right(i)))\n    return Equiv.of(res, F.pure(n))\n  }\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n\n  /** Mixed-in from {@link ApplyLaws.applyComposition}. */\n  applyComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link ApplyLaws.applyProductConsistency}. */\n  applyProductConsistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplyLaws.applyMap2Consistency}. */\n  applyMap2Consistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n\n  /** Mixed-in from {@link ApplicativeLaws.applyComposition}. */\n  applicativeIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeHomomorphism}. */\n  applicativeHomomorphism: <A, B>(a: A, f: (a: A) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeInterchange}. */\n  applicativeInterchange: <A, B>(a: A, ff: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeMap}. */\n  applicativeMap: <A, B>(fa: HK<F, A>, f: (a: A) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeComposition}. */\n  applicativeComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeUnit}. */\n  applicativeUnit: <A>(a: A) => Equiv<HK<F, A>>\n\n  /** Mixed-in from {@link FlatMapLaws.flatMapAssociativity}. */\n  flatMapAssociativity: <A, B, C>(fa: HK<F, A>, f: (a: A) => HK<F, B>, g: (b: B) => HK<F, C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link FlatMapLaws.flatMapConsistentApply}. */\n  flatMapConsistentApply: <A, B>(fa: HK<F, A>, fab: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link FlatMapLaws.followedByConsistency}. */\n  followedByConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link FlatMapLaws.followedByLConsistency}. */\n  followedByLConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link FlatMapLaws.forEffectConsistency}. */\n  forEffectConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FlatMapLaws.forEffectLConsistency}. */\n  forEffectLConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FlatMapLaws.tailRecMConsistentFlatMap}. */\n  tailRecMConsistentFlatMap: <A>(a: A, f: (a: A) => HK<F, A>) => Equiv<HK<F, A>>\n}\n\napplyMixins(MonadLaws, [ApplicativeLaws, FlatMapLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link Monad} instance if it exists, or throws a `NotImplementedError`\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, Monad, monadOf } from \"funfix\"\n *\n * const F: Monad<Option<any>> = monadOf(Option)\n * ```\n */\nexport const monadOf: <F>(c: Constructor<F>) => Monad<F> =\n  getTypeClassInstance(Monad)\n\n/**\n * Given an {@link Monad} instance, returns the {@link MonadLaws}\n * associated with it.\n */\nexport function monadLawsOf<F>(instance: Monad<F>): MonadLaws<F> {\n  return new (class extends MonadLaws<F> { public readonly F = instance })()\n}\n\n/**\n * The `MonadError` type class is a {@link Applicative} that\n * also allows you to raise and or handle an error value.\n *\n * This type class allows one to abstract over error-handling\n * applicative types.\n *\n * MUST follow the law defined in {@link MonadErrorLaws}.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK,\n *   MonadError,\n *   registerTypeClassInstance,\n *   applyMixins,\n *   Try\n * } from \"funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: Try<T>) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note they can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxMonadError implements MonadError<Box<any>, any> {\n *   pure<A>(a: A): Box<A> { return new Box(Try.success(a)) }\n *\n *   flatMap<A, B>(fa: BoxK<A>, f: (a: A) => BoxK<B>): Box<B> {\n *     throw new NotImplementedError(\"Provide implementation\")\n *   }\n *\n *   tailRecM<A, B>(a: A, f: (a: A) => BoxK<Either<A, B>>): Box<B> {\n *     throw new NotImplementedError(\"Provide implementation\")\n *   }\n *\n *   raise<A>(e: any): HK<Box<any>, A> {\n *     return new Box(Try.failure(e))\n *   }\n *\n *   recoverWith<A>(fa: BoxK<A>, f: (e: any) => BoxK<A>): HK<Box<any>, A> {\n *     return new Box((fa as Box<A>).value.recoverWith(e => (f(e) as Box<A>).value))\n *   }\n *\n *   // Mixed in\n *   map: <A, B>(fa: BoxK<A>, f: (a: A) => B) => Box<B>\n *   map2: <A, B, Z>(fa: BoxK<A>, fb: BoxK<B>, f: (a: A, b: B) => Z) => Box<Z>\n *   ap: <A, B>(fa: BoxK<A>, ff: BoxK<(a: A) => B>) => Box<B>\n *   product: <A, B> (fa: BoxK<A>, fb: BoxK<B>) => Box<[A, B]>\n *   unit: () => Box<void>\n *   followedBy: <A, B>(fa: BoxK<A>, fb: BoxK<B>) => Box<B>\n *   followedByL: <A, B>(fa: BoxK<A>, fb: () => BoxK<B>) => Box<B>\n *   forEffect: <A, B>(fa: BoxK<A>, fb: BoxK<B>) => Box<A>\n *   forEffectL: <A, B>(fa: BoxK<A>, fb: () => BoxK<B>) => Box<A>\n *   recover: <A>(fa: HK<Box<any>, A>, f: (e: any) => A) => HK<Box<any>, A>\n *   attempt: <A>(fa: HK<Box<any>, A>) => HK<Box<any>, Either<any, A>>\n * }\n *\n * // Call needed in order to implement `map`, `map2`, `product`, etc.\n * // using the default implementations defined by `MonadError`,\n * // because we are using `implements` instead of `extends` above and\n * // because in this sample we want the default implementations,\n * // but note that you can always provide your own\n * applyMixins(BoxMonadError, [MonadError])\n *\n * // Registering global MonadError instance for Box, needed in order\n * // for the `functorOf(Box)`, `applyOf(Box)`, `applicativeOf(Box)`\n * // and `monadErrorOf(Box)` calls to work\n * registerTypeClassInstance(MonadError)(Box, new BoxMonadError())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class MonadError<F, E> implements ApplicativeError<F, E>, Monad<F> {\n  /** Inherited from {@link Applicative.pure}. */\n  abstract pure<A>(a: A): HK<F, A>\n\n  /** Inherited from {@link ApplicativeError.raise}. */\n  abstract raise<A>(e: E): HK<F, A>\n\n  /** Inherited from {@link FlatMap.flatMap}. */\n  abstract flatMap<A, B>(fa: HK<F, A>, f: (a: A) => HK<F, B>): HK<F, B>\n\n  /** Inherited from {@link FlatMap.tailRecM}. */\n  abstract tailRecM<A, B>(a: A, f: (a: A) => HK<F, Either<A, B>>): HK<F, B>\n\n  /** Inherited from {@link ApplicativeError.recoverWith}. */\n  abstract recoverWith<A>(fa: HK<F, A>, f: (e: E) => HK<F, A>): HK<F, A>\n\n  /** Mixed-in from {@link ApplicativeError.recover}. */\n  recover: <A>(fa: HK<F, A>, f: (e: E) => A) => HK<F, A>\n  /** Mixed-in from {@link ApplicativeError.attempt}. */\n  attempt: <A>(fa: HK<F, A>) => HK<F, Either<E, A>>\n\n  /** Mixed-in from {@link Applicative.unit}. */\n  unit: () => HK<F, void>\n  /** Mixed-in from {@link Applicative.map}. */\n  map: <A, B>(fa: HK<F, A>, f: (a: A) => B) => HK<F, B>\n  /** Mixed-in from {@link Apply.map2}. */\n  map2: <A, B, Z>(fa: HK<F, A>, fb: HK<F, B>, f: (a: A, b: B) => Z) => HK<F, Z>\n  /** Mixed-in from {@link Apply.product}. */\n  product: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => HK<F, [A, B]>\n  /** Mixed-in from {@link FlatMap.followedBy}. */\n  followedBy: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => HK<F, B>\n  /** Mixed-in from {@link FlatMap.followedByL}. */\n  followedByL: <A, B>(fa: HK<F, A>, fb: () => HK<F, B>) => HK<F, B>\n  /** Mixed-in from {@link FlatMap.forEffect}. */\n  forEffect: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => HK<F, A>\n  /** Mixed-in from {@link FlatMap.forEffectL}. */\n  forEffectL: <A, B>(fa: HK<F, A>, fb: () => HK<F, B>) => HK<F, A>\n  /** Mixed-in from {@link Monad.ap}. */\n  ap: <A, B>(fa: HK<F, A>, ff: HK<F, (a: A) => B>) => HK<F, B>\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"monadError\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] =\n    [\"functor\", \"apply\", \"applicative\", \"monad\", \"applicativeError\"]\n\n  /** @hidden */\n  static readonly _funErasure: MonadError<any, any>\n}\n\napplyMixins(MonadError, [Monad, ApplicativeError])\n\n/**\n * Type class laws defined for {@link MonadError}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class MonadErrorLaws<F, E> implements ApplicativeErrorLaws<F, E>, MonadLaws<F> {\n  /**\n   * The {@link MonadError} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: MonadError<F, E>\n\n  monadErrorLeftZero<A, B>(e: E, f: (a: A) => HK<F, B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(F.flatMap(F.raise<A>(e), f), F.raise<B>(e))\n  }\n\n  /** Mixed-in from {@link ApplicativeErrorLaws.applicativeErrorRecoverWith}. */\n  applicativeErrorRecoverWith: <A>(e: E, f: (e: E) => HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link ApplicativeErrorLaws.applicativeErrorRecover}. */\n  applicativeErrorRecover: <A>(e: E, f: (e: E) => A) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link ApplicativeErrorLaws.recoverWithPure}. */\n  recoverWithPure: <A>(a: A, f: (e: E) => HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link ApplicativeErrorLaws.recoverPure}. */\n  recoverPure: <A>(a: A, f: (e: E) => A) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link ApplicativeErrorLaws.raiseErrorAttempt}. */\n  raiseErrorAttempt: (e: E) => Equiv<HK<F, Either<E, void>>>\n  /** Mixed-in from {@link ApplicativeErrorLaws.pureAttempt}. */\n  pureAttempt: <A>(a: A) => Equiv<HK<F, Either<E, A>>>\n\n  /** Mixed-in from {@link MonadLaws.monadLeftIdentity}. */\n  monadLeftIdentity: <A, B>(a: A, f: (a: A) => HK<F, B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link MonadLaws.monadRightIdentity}. */\n  monadRightIdentity: <A, B>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link MonadLaws.mapFlatMapCoherence}. */\n  mapFlatMapCoherence: <A, B>(fa: HK<F, A>, f: (a: A) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link MonadLaws.tailRecMStackSafety}. */\n  tailRecMStackSafety: () => Equiv<HK<F, number>>\n\n  /** Mixed-in from {@link FlatMapLaws.flatMapAssociativity}. */\n  flatMapAssociativity: <A, B, C>(fa: HK<F, A>, f: (a: A) => HK<F, B>, g: (b: B) => HK<F, C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link FlatMapLaws.flatMapConsistentApply}. */\n  flatMapConsistentApply: <A, B>(fa: HK<F, A>, fab: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link FlatMapLaws.followedByConsistency}. */\n  followedByConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link FlatMapLaws.followedByLConsistency}. */\n  followedByLConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link FlatMapLaws.forEffectConsistency}. */\n  forEffectConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FlatMapLaws.forEffectLConsistency}. */\n  forEffectLConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FlatMapLaws.tailRecMConsistentFlatMap}. */\n  tailRecMConsistentFlatMap: <A>(a: A, f: (a: A) => HK<F, A>) => Equiv<HK<F, A>>\n\n  /** Mixed-in from {@link ApplicativeLaws.applicativeIdentity}. */\n  applicativeIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeHomomorphism}. */\n  applicativeHomomorphism: <A, B>(a: A, f: (a: A) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeInterchange}. */\n  applicativeInterchange: <A, B>(a: A, ff: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeMap}. */\n  applicativeMap: <A, B>(fa: HK<F, A>, f: (a: A) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeComposition}. */\n  applicativeComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeUnit}. */\n  applicativeUnit: <A>(a: A) => Equiv<HK<F, A>>\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n\n  /** Mixed-in from {@link ApplyLaws.applyComposition}. */\n  applyComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link ApplyLaws.applyProductConsistency}. */\n  applyProductConsistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplyLaws.applyMap2Consistency}. */\n  applyMap2Consistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n}\n\napplyMixins(MonadErrorLaws, [MonadLaws, ApplicativeErrorLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link MonadError} instance if it exists, or throws a `NotImplementedError`\n * in case there's no such association.\n *\n * ```typescript\n * import { IO, MonadError, monadErrorOf } from \"funfix\"\n *\n * const F: MonadError<IO<any>> = monadErrorOf(IO)\n * ```\n */\nexport const monadErrorOf: <F, E>(c: Constructor<F>) => MonadError<F, E> =\n  getTypeClassInstance(MonadError)\n\n/**\n * Given an {@link MonadError} instance, returns the\n * {@link MonadErrorLaws} associated with it.\n */\nexport function monadErrorLawsOf<F,E>(instance: MonadError<F,E>): MonadErrorLaws<F,E> {\n  return new (class extends MonadErrorLaws<F,E> { public readonly F = instance })()\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HK, Equiv, Constructor, getTypeClassInstance } from \"./kinds\"\nimport { Functor, FunctorLaws } from \"./functor\"\nimport { applyMixins, id } from \"funfix-core\"\n\n/**\n * The `CoflatMap` type class, a weaker version of {@link Comonad},\n * exposing `coflatMap`, but not `extract`.\n *\n * This type class is exposed in addition to `Comonad` because\n * there are data types for which we can't implement `extract`, but\n * that could still benefit from an `coflatMap` definition.\n *\n * MUST obey the laws defined in {@link CoflatMapLaws}.\n *\n * Note that having a `CoflatMap` instance implies that a\n * {@link Functor} implementation is also available, which is why\n * `CoflatMap` is a subtype of `Functor`.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK, CoflatMap,\n *   registerTypeClassInstance,\n *   applyMixins\n * } from \"funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: T) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note these can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxCoflatMap implements CoflatMap<Box<any>> {\n *   map<A, B>(fa: BoxK<A>, f: (a: A) => B): Box<B> {\n *     const a = (fa as Box<A>).value\n *     return new Box(f(a))\n *   }\n *\n *   coflatMap<A, B>(fa: BoxK<A>, ff: (a: BoxK<A>) => B): BoxK<B> {\n *     return new Box(Success(ff(fa)))\n *   }\n *\n *   coflatten<A>(fa: BoxK<A>): BoxK<BoxK<A>> {\n *     return new Box(Success(fa))\n *   }\n * }\n *\n * // At the moment of writing, this call is not needed, but it is\n * // recommended anyway to future-proof the code ;-)\n * applyMixins(BoxCoflatMap, [CoflatMap])\n *\n * // Registering global CoflatMap instance for Box, needed in order\n * // for the `coflatMapOf(Box)` calls to work\n * registerTypeClassInstance(CoflatMap)(Box, new BoxCoflatMap())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class CoflatMap<F> implements Functor<F> {\n  /**\n   * `coflatMap` is the dual of `flatMap` on {@link FlatMap}.\n   *\n   * It applies a value in a context to a function that takes a\n   * value in a context and returns a normal value.\n   */\n  abstract coflatMap<A, B>(fa: HK<F, A>, ff: (a: HK<F, A>) => B): HK<F, B>\n\n  /**\n   * `coflatten` is the dual of `flatten` on {@link FlatMap}.\n   *\n   * Whereas `flatten` removes a layer of `F`, coflatten adds a\n   * layer of `F`.\n   */\n  abstract coflatten<A>(fa: HK<F, A>): HK<F, HK<F, A>>\n\n  /** Inherited from {@link Functor.map}. */\n  map: <A, B>(fa: HK<F, A>, f: (a: A) => B) => HK<F, B>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"coflatMap\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = [\"functor\"]\n  /** @hidden */\n  static readonly _funErasure: CoflatMap<any>\n}\n\napplyMixins(CoflatMap, [Functor])\n\n/**\n * Type class laws defined for {@link CoflatMap}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of\n * extending it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class CoflatMapLaws<F> implements FunctorLaws<F> {\n  /**\n   * The {@link CoflatMap} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: CoflatMap<F>\n\n  /**\n   * ```\n   *  fa.coflatMap(f).coflatMap(g) <-> fa.coflatMap(x => g(x.coflatMap(f)))\n   * ```\n   */\n  coflatMapAssociativity<A, B, C>(fa: HK<F, A>, f: (a: HK<F, A>) => B, g: (b: HK<F, B>) => C): Equiv<HK<F, C>> {\n    const F = this.F\n    return Equiv.of(\n      F.coflatMap(F.coflatMap(fa, f), g),\n      F.coflatMap(fa, a => g(F.coflatMap(a, f)))\n    )\n  }\n\n  /**\n   * ```\n   * fa.coflatten.coflatten <-> fa.coflatten.map(_.coflatten)\n   * ```\n   */\n  coflattenThroughMap<A>(fa: HK<F, A>): Equiv<HK<F, HK<F, HK<F, A>>>> {\n    const F = this.F\n    return Equiv.of(\n      F.coflatten(F.coflatten(fa)),\n      F.map(F.coflatten(fa), F.coflatten)\n    )\n  }\n\n  /**\n   * ```\n   * fa.coflatMap(f) <-> fa.coflatten.map(f)\n   * ```\n   */\n  coflattenCoherence<A, B>(fa: HK<F, A>, f: (a: HK<F, A>) => B): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.coflatMap(fa, f),\n      F.map(F.coflatten(fa), f)\n    )\n  }\n\n  /**\n   * ```\n   * fa.coflatten <-> fa.coflatMap(identity)\n   * ```\n   */\n  coflatMapIdentity<A>(fa: HK<F, A>): Equiv<HK<F, HK<F, A>>> {\n    const F = this.F\n    return Equiv.of(\n      F.coflatten(fa),\n      F.coflatMap(fa, id)\n    )\n  }\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n}\n\napplyMixins(CoflatMapLaws, [FunctorLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link CoflatMap} instance if it exists, or throws a `NotImplementedError`\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, CoflatMap, coflatMapOf } from \"funfix\"\n *\n * const F: CoflatMap<Option<any>> = coflatMapOf(Option)\n * ```\n */\nexport const coflatMapOf: <F>(c: Constructor<F>) => CoflatMap<F> =\n  getTypeClassInstance(CoflatMap)\n\n/**\n * Given an {@link CoflatMap} instance, returns the {@link CoflatMapLaws}\n * associated with it.\n */\nexport function coflatMapLawsOf<F>(instance: CoflatMap<F>): CoflatMapLaws<F> {\n  return new (class extends CoflatMapLaws<F> { public readonly F = instance })()\n}\n\n/**\n * `Comonad` is the dual of {@link Monad}.\n *\n * Whereas Monads allow for the composition of effectful functions,\n * Comonads allow for composition of functions that extract the\n * value from their context.\n *\n * Example:\n *\n * ```typescript\n * const F = comonadOf(Eval)\n *\n * F.extract(Eval.of(() => 2)) // 2\n * ```\n *\n * Note that having an `Comonad` instance implies {@link Functor} and\n * {@link CoflatMap} implementations are also available, which is why\n * `Comonad` is a subtype of `Functor` and `CoflatMap`.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK, Comonad,\n *   registerTypeClassInstance,\n *   applyMixins\n * } from \"funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: T) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note they can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxComonad implements Comonad<Box<any>> {\n *   map<A, B>(fa: BoxK<A>, f: (a: A) => B): BoxK<B> {\n *     const a = (fa as Box<A>).value\n *     return new Box(f(a))\n *   }\n *\n *   coflatMap<A, B>(fa: BoxK<A>, ff: (a: BoxK<A>) => B): BoxK<B> {\n *     return new Box(ff(fa))\n *   }\n *\n *   coflatten<A>(fa: BoxK<A>): BoxK<BoxK<A>> {\n *     return new Box(fa)\n *   }\n *\n *   extract<A>(fa: BoxK<A>): A {\n *     return (fa as Box<A>).value\n *   }\n * }\n *\n * // At the moment of writing, this call is not needed, but it is\n * // recommended anyway to future-proof the code ;-)\n * applyMixins(BoxComonad, [Comonad])\n *\n * // Registering global Comonad instance for Box, needed in order\n * // for the `functorOf(Box)`, `coflatMapOf(Box)` and `comonadOf(Box)`\n * // calls to work\n * registerTypeClassInstance(Comonad)(Box, new BoxComonad())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class Comonad<F> implements CoflatMap<F> {\n  /**\n   * `extract` is the dual of `pure` on {@link Monad}\n   * (via {@link Applicative}) and extracts the value from\n   * its context.\n   *\n   * Example:\n   *\n   * ```typescript\n   * const cm = comonadOf(Eval)\n   *\n   * cm.extract(Eval.of(() => 10)) //=> 10\n   * ```\n   */\n  abstract extract<A>(fa: HK<F, A>): A\n\n  /** Inherited from {@link Functor.map}. */\n  map: <A, B>(fa: HK<F, A>, f: (a: A) => B) => HK<F, B>\n  /** Inherited from {@link CoflatMap.coflatMap}. */\n  coflatMap: <A, B>(fa: HK<F, A>, ff: (a: HK<F, A>) => B) => HK<F, B>\n  /** Inherited from {@link CoflatMap.coflatten}. */\n  coflatten: <A>(fa: HK<F, A>) => HK<F, HK<F, A>>\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"comonad\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = [\"functor\", \"coflatMap\"]\n  /** @hidden */\n  static readonly _funErasure: Comonad<any>\n}\n\napplyMixins(Comonad, [CoflatMap])\n\n/**\n * Type class laws defined for {@link Comonad}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class ComonadLaws<F> implements CoflatMapLaws<F> {\n  /**\n   * The {@link Comonad} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: Comonad<F>\n\n  /**\n   * ```\n   * fa.coflatten.extract <-> fa\n   * ```\n   */\n  extractCoflattenIdentity<A>(fa: HK<F, A>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(\n      F.extract(F.coflatten(fa)),\n      fa\n    )\n  }\n\n  /**\n   * ```\n   * fa.coflatten.map(_.extract) <-> fa\n   * ```\n   */\n  mapCoflattenIdentity<A>(fa: HK<F, A>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(\n      F.map(F.coflatten(fa), F.extract),\n      fa\n    )\n  }\n\n  /**\n   * ```\n   * fa.map(f) <-> fa.coflatMap(fa0 => f(fa0.extract))\n   * ```\n   */\n  mapCoflatMapCoherence<A, B>(fa: HK<F, A>, f: (a: A) => B): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.map(fa, f),\n      F.coflatMap(fa, fa0 => f(F.extract(fa0)))\n    )\n  }\n\n  /**\n   * ```\n   * fa.coflatMap(_.extract) <-> fa\n   * ```\n   */\n  comonadLeftIdentity<A>(fa: HK<F, A>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(\n      F.coflatMap(fa, F.extract),\n      fa\n    )\n  }\n\n  /**\n   * ```\n   * fa.coflatMap(f).extract <-> f(fa)\n   * ```\n   */\n  comonadRightIdentity<A, B>(fa: HK<F, A>, f: (a: HK<F, A>) => B): Equiv<B> {\n    const F = this.F\n    return Equiv.of(\n      F.extract(F.coflatMap(fa, f)),\n      f(fa)\n    )\n  }\n\n  /** Mixed-in from {@link CoflatMapLaws.coflatMapAssociativity}. */\n  coflatMapAssociativity: <A, B, C>(fa: HK<F, A>, f: (a: HK<F, A>) => B, g: (b: HK<F, B>) => C) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link CoflatMapLaws.coflattenThroughMap}. */\n  coflattenThroughMap: <A>(fa: HK<F, A>) => Equiv<HK<F, HK<F, HK<F, A>>>>\n  /** Mixed-in from {@link CoflatMapLaws.coflattenCoherence}. */\n  coflattenCoherence: <A, B>(fa: HK<F, A>, f: (a: HK<F, A>) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link CoflatMapLaws.coflatMapIdentity}. */\n  coflatMapIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, HK<F, A>>>\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n}\n\napplyMixins(ComonadLaws, [CoflatMapLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link Comonad} instance if it exists, or throws a `NotImplementedError`\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, Comonad, comonadOf } from \"funfix\"\n *\n * const F: Comonad<Option<any>> = comonadOf(Option)\n * ```\n */\nexport const comonadOf: <F>(c: Constructor<F>) => Comonad<F> =\n  getTypeClassInstance(Comonad)\n\n/**\n * Given an {@link Comonad} instance, returns the {@link ComonadLaws}\n * associated with it.\n */\nexport function comonadLawsOf<F>(instance: Comonad<F>): ComonadLaws<F> {\n  return new (class extends ComonadLaws<F> { public readonly F = instance })()\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Try, Success, Option, Some, Either, Right, applyMixins, Throwable } from \"funfix-core\"\nimport { Eval, IO } from \"funfix-effect\"\nimport { Future } from \"funfix-exec\"\nimport { HK, registerTypeClassInstance } from \"./kinds\"\nimport { Monad, MonadError } from \"./monad\"\nimport { Comonad, CoflatMap } from \"./comonad\"\nimport { Eq } from \"./eq\"\n\n/**\n * Alias used for encoding higher-kinded types when implementing\n * type class instances.\n */\nexport type OptionK<A> = HK<Option<any>, A>\n\n/**\n * Type class instances provided by default for `Option`.\n */\nexport class OptionInstances implements Monad<Option<any>>, Eq<Option<any>>, CoflatMap<Option<any>> {\n  // tslint:disable-next-line:variable-name\n  private __unit: Option<void> = Some(undefined)\n\n  eqv(lh: Option<any>, rh: Option<any>): boolean {\n    if (lh === rh) return true\n    if (lh.isEmpty()) return rh.isEmpty()\n    if (rh.isEmpty()) return false\n    return Eq.testEq(lh.get(), rh.get())\n  }\n\n  pure<A>(a: A): Option<A> {\n    return Some(a)\n  }\n\n  unit(): Option<void> {\n    return this.__unit\n  }\n\n  ap<A, B>(fa: OptionK<A>, ff: OptionK<(a: A) => B>): Option<B> {\n    return Option.map2(fa as Option<A>, ff as Option<(a: A) => B>, (a, f) => f(a))\n  }\n\n  map<A, B>(fa: OptionK<A>, f: (a: A) => B): Option<B> {\n    return (fa as Option<A>).map(f)\n  }\n\n  map2<A, B, Z>(fa: OptionK<A>, fb: OptionK<B>, f: (a: A, b: B) => Z): Option<Z> {\n    return Option.map2(fa as Option<A>, fb as Option<B>, f)\n  }\n\n  product<A, B>(fa: OptionK<A>, fb: OptionK<B>): Option<[A, B]> {\n    return Option.map2(fa as Option<A>, fb as Option<B>, (a, b) => [a, b] as [A, B])\n  }\n\n  flatMap<A, B>(fa: OptionK<A>, f: (a: A) => OptionK<B>): Option<B> {\n    return (fa as any).flatMap(f)\n  }\n\n  tailRecM<A, B>(a: A, f: (a: A) => OptionK<Either<A, B>>): Option<B> {\n    return Option.tailRecM(a, f as any) as any\n  }\n\n  coflatMap<A, B>(fa: OptionK<A>, ff: (a: OptionK<A>) => B): Option<B> {\n    return Some(ff(fa))\n  }\n\n  coflatten<A>(fa: OptionK<A>): Option<Option<A>> {\n    return Some(fa as Option<A>)\n  }\n\n  // Mixed-in\n  followedBy: <A, B>(fa: OptionK<A>, fb: OptionK<B>) => Option<B>\n  followedByL: <A, B>(fa: OptionK<A>, fb: () => OptionK<B>) => Option<B>\n  forEffect: <A, B>(fa: OptionK<A>, fb: OptionK<B>) => Option<A>\n  forEffectL: <A, B>(fa: OptionK<A>, fb: () => OptionK<B>) => Option<A>\n\n  static readonly global: OptionInstances =\n    new OptionInstances()\n}\n\n// Mixins the default implementations\napplyMixins(OptionInstances, [Monad])\n\n// Registering `OptionInstances` as global instances for Option\nregisterTypeClassInstance(Eq)(Option, OptionInstances.global)\nregisterTypeClassInstance(Monad)(Option, OptionInstances.global)\nregisterTypeClassInstance(CoflatMap)(Option, OptionInstances.global)\n\n/**\n * Alias used for encoding higher-kinded types when implementing\n * type class instances.\n */\nexport type TryK<A> = HK<Try<any>, A>\n\n/**\n * Type class instances provided by default for `Option`.\n */\nexport class TryInstances\n  implements MonadError<Try<any>, Throwable>, Eq<Try<any>>, CoflatMap<Try<any>> {\n\n  eqv(lh: Try<any>, rh: Try<any>): boolean {\n    if (lh === rh) return true\n    if (lh.isSuccess()) {\n      if (rh.isFailure()) return false\n      return Eq.testEq(lh.get(), rh.get())\n    } else {\n      if (rh.isSuccess()) return false\n      return Eq.testEq(lh.failed().get(), rh.failed().get())\n    }\n  }\n\n  pure<A>(a: A): Try<A> {\n    return Success(a)\n  }\n\n  unit(): Try<void> {\n    return Try.unit()\n  }\n\n  ap<A, B>(fa: TryK<A>, ff: TryK<(a: A) => B>): Try<B> {\n    return Try.map2(fa as Try<A>, ff as Try<(a: A) => B>, (a, f) => f(a))\n  }\n\n  map<A, B>(fa: TryK<A>, f: (a: A) => B): Try<B> {\n    return (fa as Try<A>).map(f)\n  }\n\n  map2<A, B, Z>(fa: TryK<A>, fb: TryK<B>, f: (a: A, b: B) => Z): Try<Z> {\n    return Try.map2(fa as Try<A>, fb as Try<B>, f)\n  }\n\n  product<A, B>(fa: TryK<A>, fb: TryK<B>): Try<[A, B]> {\n    return Try.map2(fa as Try<A>, fb as Try<B>, (a, b) => [a, b] as [A, B])\n  }\n\n  flatMap<A, B>(fa: TryK<A>, f: (a: A) => TryK<B>): Try<B> {\n    return (fa as any).flatMap(f)\n  }\n\n  tailRecM<A, B>(a: A, f: (a: A) => TryK<Either<A, B>>): Try<B> {\n    return Try.tailRecM(a, f as any) as any\n  }\n\n  raise<A>(e: any): Try<A> {\n    return Try.failure<A>(e)\n  }\n\n  attempt<A>(fa: TryK<A>): Try<Either<Throwable, A>> {\n    return Try.success((fa as Try<A>).fold(\n      e => Either.left<Throwable, A>(e),\n      Either.right\n    ))\n  }\n\n  recoverWith<A>(fa: TryK<A>, f: (e: Throwable) => TryK<A>): Try<A> {\n    return (fa as Try<A>).recoverWith(f as ((e: Throwable) => Try<A>))\n  }\n\n  recover<A>(fa: TryK<A>, f: (e: Throwable) => A): Try<A> {\n    return (fa as Try<A>).recover(f as ((e: Throwable) => A))\n  }\n\n  coflatMap<A, B>(fa: TryK<A>, ff: (a: TryK<A>) => B): Try<B> {\n    return Success(ff(fa))\n  }\n\n  coflatten<A>(fa: TryK<A>): Try<Try<A>> {\n    return Success(fa as Try<A>)\n  }\n\n  // Mixed-in\n  followedBy: <A, B>(fa: TryK<A>, fb: TryK<B>) => Try<B>\n  followedByL: <A, B>(fa: TryK<A>, fb: () => TryK<B>) => Try<B>\n  forEffect: <A, B>(fa: TryK<A>, fb: TryK<B>) => Try<A>\n  forEffectL: <A, B>(fa: TryK<A>, fb: () => TryK<B>) => Try<A>\n\n  static global: TryInstances =\n    new TryInstances()\n}\n\n// Mixins the default implementations\napplyMixins(TryInstances, [MonadError])\n\n// Registering `TryInstances` as global instances for Try\nregisterTypeClassInstance(Eq)(Try, TryInstances.global)\nregisterTypeClassInstance(MonadError)(Try, TryInstances.global)\nregisterTypeClassInstance(CoflatMap)(Try, TryInstances.global)\n\n/**\n * Alias used for encoding higher-kinded types when implementing\n * type class instances.\n */\nexport type EitherK<L, R> = HK<Either<L, any>, R>\n\n/**\n * Type class instances provided by default for `Either`.\n */\nexport class EitherInstances<L>\n  implements Monad<Either<L, any>>, Eq<Either<L, any>>, CoflatMap<Either<L, any>> {\n  // tslint:disable-next-line:variable-name\n  private __unit: Either<L, void> = Right(undefined)\n\n  eqv(lh: Either<L, any>, rh: Either<L, any>): boolean {\n    if (lh === rh) return true\n    if (lh.isRight()) {\n      if (rh.isLeft()) return false\n      return Eq.testEq(lh.get(), rh.get())\n    } else {\n      if (rh.isRight()) return false\n      return Eq.testEq(lh.swap().get(), rh.swap().get())\n    }\n  }\n\n  pure<A>(a: A): Either<L, A> {\n    return Right(a)\n  }\n\n  unit(): Either<L, void> {\n    return this.__unit\n  }\n\n  ap<A, B>(fa: EitherK<L, A>, ff: EitherK<L, (a: A) => B>): Either<L, B> {\n    const faE = (fa as any) as Either<L, A>\n    const ffE = (ff as any) as Either<L, (a: A) => B>\n    return Either.map2(faE, ffE, (a, f) => f(a))\n  }\n\n  map<A, B>(fa: EitherK<L, A>, f: (a: A) => B): Either<L, B> {\n    return ((fa as any) as Either<L, A>).map(f)\n  }\n\n  map2<A, B, Z>(fa: EitherK<L, A>, fb: EitherK<L, B>, f: (a: A, b: B) => Z): Either<L, Z> {\n    return Either.map2((fa as any) as Either<L, A>, (fb as any) as Either<L, B>, f)\n  }\n\n  product<A, B>(fa: EitherK<L, A>, fb: EitherK<L, B>): Either<L, [A, B]> {\n    return Either.map2(\n      (fa as any) as Either<L, A>,\n      (fb as any) as Either<L, B>,\n      (a, b) => [a, b] as [A, B])\n  }\n\n  flatMap<A, B>(fa: HK<Either<L, any>, A>, f: (a: A) => HK<Either<L, any>, B>): HK<Either<L, any>, B> {\n    return (fa as any).flatMap(f)\n  }\n\n  tailRecM<A, B>(a: A, f: (a: A) => HK<Either<L, any>, Either<A, B>>): HK<Either<L, any>, B> {\n    return Either.tailRecM(a, f as any) as any\n  }\n\n  coflatMap<A, B>(fa: EitherK<L, A>, ff: (a: EitherK<L, A>) => B): Either<L, B> {\n    return Right(ff(fa))\n  }\n\n  coflatten<A>(fa: EitherK<L, A>): Either<L, Either<L, A>> {\n    return Right(fa as Either<L, A>)\n  }\n\n  // Mixed-in\n  followedBy: <A, B>(fa: EitherK<L, A>, fb: EitherK<L, B>) => Either<L, B>\n  followedByL: <A, B>(fa: EitherK<L, A>, fb: () => EitherK<L, B>) => Either<L, B>\n  forEffect: <A, B>(fa: EitherK<L, A>, fb: EitherK<L, B>) => Either<L, A>\n  forEffectL: <A, B>(fa: EitherK<L, A>, fb: () => EitherK<L, B>) => Either<L, A>\n\n  static global: EitherInstances<any> =\n    new EitherInstances()\n}\n\n// Mixins the default implementations\napplyMixins(EitherInstances, [Monad])\n// Registering `TryInstances` as global instances for Try\nregisterTypeClassInstance(Eq)(Either, EitherInstances.global)\nregisterTypeClassInstance(Monad)(Either, EitherInstances.global)\nregisterTypeClassInstance(CoflatMap)(Either, EitherInstances.global)\n\n/**\n * Alias used for encoding higher-kinded types when implementing\n * type class instances.\n */\nexport type EvalK<A> = HK<Eval<any>, A>\n\n/**\n * Type class instances provided by default for `Eval`.\n */\nexport class EvalInstances implements Monad<Eval<any>>, Comonad<Eval<any>> {\n  pure<A>(a: A): Eval<A> {\n    return Eval.now(a)\n  }\n\n  flatMap<A, B>(fa: EvalK<A>, f: (a: A) => EvalK<B>): Eval<B> {\n    return (fa as any).flatMap(f)\n  }\n\n  tailRecM<A, B>(a: A, f: (a: A) => EvalK<Either<A, B>>): Eval<B> {\n    return Eval.tailRecM(a, f as any) as any\n  }\n\n  ap<A, B>(fa: EvalK<A>, ff: EvalK<(a: A) => B>): Eval<B> {\n    return (fa as Eval<A>).flatMap(a =>\n      (ff as Eval<(a: A) => B>).map(f => f(a))\n    )\n  }\n\n  map<A, B>(fa: EvalK<A>, f: (a: A) => B): Eval<B> {\n    return (fa as Eval<A>).map(f)\n  }\n\n  unit(): Eval<void> {\n    return Eval.unit()\n  }\n\n  coflatMap<A, B>(fa: EvalK<A>, ff: (a: EvalK<A>) => B): Eval<B> {\n    return Eval.now(ff(fa))\n  }\n\n  coflatten<A>(fa: EvalK<A>): Eval<Eval<A>> {\n    return Eval.now(fa as Eval<A>)\n  }\n\n  extract<A>(fa: EvalK<A>): A {\n    return (fa as Eval<A>).get()\n  }\n\n  // Mixed-in\n  map2: <A, B, Z>(fa: EvalK<A>, fb: EvalK<B>, f: (a: A, b: B) => Z) => Eval<Z>\n  product: <A, B>(fa: EvalK<A>, fb: EvalK<B>) => EvalK<[A, B]>\n  followedBy: <A, B>(fa: EvalK<A>, fb: EvalK<B>) => Eval<B>\n  followedByL: <A, B>(fa: EvalK<A>, fb: () => EvalK<B>) => Eval<B>\n  forEffect: <A, B>(fa: EvalK<A>, fb: EvalK<B>) => Eval<A>\n  forEffectL: <A, B>(fa: EvalK<A>, fb: () => EvalK<B>) => Eval<A>\n\n  static global: EvalInstances =\n    new EvalInstances()\n}\n\n// Mixins the default implementations\napplyMixins(EvalInstances, [Monad, Comonad])\n// Registering `EvalInstances` as global instances for `Eval`\nregisterTypeClassInstance(Monad)(Eval, EvalInstances.global)\nregisterTypeClassInstance(Comonad)(Eval, EvalInstances.global)\n\n/**\n * Alias used for encoding higher-kinded types when implementing\n * type class instances.\n */\nexport type FutureK<A> = HK<Future<any>, A>\n\n/**\n * Type class instances provided by default for `Future`.\n */\nexport class FutureInstances implements MonadError<Future<any>, Throwable>, CoflatMap<Future<any>> {\n  pure<A>(a: A): Future<A> {\n    return Future.pure(a)\n  }\n\n  flatMap<A, B>(fa: FutureK<A>, f: (a: A) => FutureK<B>): Future<B> {\n    return (fa as any).flatMap(f)\n  }\n\n  tailRecM<A, B>(a: A, f: (a: A) => FutureK<Either<A, B>>): Future<B> {\n    return Future.tailRecM(a, f as any) as any\n  }\n\n  ap<A, B>(fa: FutureK<A>, ff: FutureK<(a: A) => B>): Future<B> {\n    return (fa as Future<A>).flatMap(a =>\n      (ff as Future<(a: A) => B>).map(f => f(a))\n    )\n  }\n\n  map<A, B>(fa: FutureK<A>, f: (a: A) => B): Future<B> {\n    return (fa as Future<A>).map(f)\n  }\n\n  unit(): Future<void> {\n    return Future.unit()\n  }\n\n  raise<A>(e: Throwable): Future<A> {\n    return Future.raise(e)\n  }\n\n  attempt<A>(fa: FutureK<A>): Future<Either<Throwable, A>> {\n    return (fa as Future<A>).attempt() as any\n  }\n\n  recoverWith<A>(fa: FutureK<A>, f: (e: Throwable) => FutureK<A>): Future<A> {\n    return (fa as Future<A>).recoverWith(f as ((e: any) => Future<A>))\n  }\n\n  recover<A>(fa: FutureK<A>, f: (e: Throwable) => A): Future<A> {\n    return (fa as Future<A>).recover(f as ((e: any) => A))\n  }\n\n  map2<A, B, Z>(fa: FutureK<A>, fb: FutureK<B>, f: (a: A, b: B) => Z): Future<Z> {\n    return Future.map2(fa as any, fb as any, f as any) as any\n  }\n\n  coflatMap<A, B>(fa: FutureK<A>, ff: (a: FutureK<A>) => B): Future<B> {\n    return Future.pure(ff(fa))\n  }\n\n  coflatten<A>(fa: FutureK<A>): Future<Future<A>> {\n    return Future.pure(fa as Future<A>)\n  }\n\n  // Mixed-in\n  product: <A, B>(fa: FutureK<A>, fb: FutureK<B>) => FutureK<[A, B]>\n  followedBy: <A, B>(fa: FutureK<A>, fb: FutureK<B>) => Future<B>\n  followedByL: <A, B>(fa: FutureK<A>, fb: () => FutureK<B>) => Future<B>\n  forEffect: <A, B>(fa: FutureK<A>, fb: FutureK<B>) => Future<A>\n  forEffectL: <A, B>(fa: FutureK<A>, fb: () => FutureK<B>) => Future<A>\n\n  static global: FutureInstances =\n    new FutureInstances()\n}\n\n// Mixins the default implementations\napplyMixins(FutureInstances, [MonadError, CoflatMap])\n// Registering `FutureInstances` as global instances for `Future`\nregisterTypeClassInstance(MonadError)(Future, FutureInstances.global)\nregisterTypeClassInstance(CoflatMap)(Future, FutureInstances.global)\n\n/**\n * Alias used for encoding higher-kinded types when implementing\n * type class instances.\n */\nexport type IOK<A> = HK<IO<any>, A>\n\n/**\n * Type class instances provided by default for `IO`.\n */\nexport class IOInstances implements MonadError<IO<any>, Throwable>, CoflatMap<IO<any>> {\n  pure<A>(a: A): IO<A> {\n    return IO.pure(a)\n  }\n\n  flatMap<A, B>(fa: IOK<A>, f: (a: A) => IOK<B>): IO<B> {\n    return (fa as any).flatMap(f)\n  }\n\n  tailRecM<A, B>(a: A, f: (a: A) => IOK<Either<A, B>>): IO<B> {\n    return IO.tailRecM(a, f as any) as any\n  }\n\n  ap<A, B>(fa: IOK<A>, ff: IOK<(a: A) => B>): IO<B> {\n    return (fa as IO<A>).flatMap(a =>\n      (ff as IO<(a: A) => B>).map(f => f(a))\n    )\n  }\n\n  map<A, B>(fa: IOK<A>, f: (a: A) => B): IO<B> {\n    return (fa as IO<A>).map(f)\n  }\n\n  unit(): IO<void> {\n    return IO.unit()\n  }\n\n  raise<A>(e: Throwable): IO<A> {\n    return IO.raise(e)\n  }\n\n  attempt<A>(fa: IOK<A>): IO<Either<Throwable, A>> {\n    return (fa as IO<A>).attempt() as any\n  }\n\n  recoverWith<A>(fa: IOK<A>, f: (e: Throwable) => IOK<A>): IO<A> {\n    return (fa as IO<A>).recoverWith(f as ((e: any) => IO<A>))\n  }\n\n  recover<A>(fa: IOK<A>, f: (e: Throwable) => A): IO<A> {\n    return (fa as IO<A>).recover(f as ((e: any) => A))\n  }\n\n  map2<A, B, Z>(fa: IOK<A>, fb: IOK<B>, f: (a: A, b: B) => Z): IO<Z> {\n    return IO.map2(fa as any, fb as any, f as any) as any\n  }\n\n  followedBy<A, B>(fa: IOK<A>, fb: IOK<B>): IO<B> {\n    return (fa as any).followedBy(fb)\n  }\n\n  followedByL<A, B>(fa: IOK<A>, fb: () => IOK<B>): IO<B> {\n    return (fa as any).followedBy(IO.suspend(fb as any))\n  }\n\n  forEffect<A, B>(fa: IOK<A>, fb: IOK<B>): IO<A> {\n    return (fa as any).forEffect(fb)\n  }\n\n  forEffectL<A, B>(fa: IOK<A>, fb: () => IOK<B>): IO<A> {\n    return (fa as any).forEffect(IO.suspend(fb as any))\n  }\n\n  product<A, B>(fa: IOK<A>, fb: IOK<B>): IO<[A, B]> {\n    return IO.map2(fa as any, fb as any, (a, b) => [a, b]) as any\n  }\n\n  coflatMap<A, B>(fa: IOK<A>, ff: (a: IOK<A>) => B): IO<B> {\n    return IO.pure(ff(fa))\n  }\n\n  coflatten<A>(fa: IOK<A>): IO<IO<A>> {\n    return IO.pure(fa as IO<A>)\n  }\n\n  static global: IOInstances =\n    new IOInstances()\n}\n\n// Mixins the default implementations\napplyMixins(IOInstances, [MonadError, CoflatMap])\n// Registering `IOInstances` as global instances for `IO`\nregisterTypeClassInstance(MonadError)(IO, IOInstances.global)\nregisterTypeClassInstance(CoflatMap)(IO, IOInstances.global)\n"],"names":["ref","equals","hashCode","lh","rh","valueOf","lh2","rh2","isValueObject","is","v","hashCodeOfString","String","str","hash","length","i","character","charCodeAt","a","derivedCtor","baseCtors","forEach","getOwnPropertyNames","baseCtor","prototype","name","errors","reasons","slice","e","message","Error","errorsRef","self","constructor","CompositeError","__proto__","DummyError","NoSuchElementError","IllegalInheritanceError","IllegalStateError","IllegalArgumentError","NotImplementedError","TimeoutError","_leftRef","_rightRef","_isRight","elem","std","p","zero","Left","f","left","right","fallback","thunk","Right","cb","Option","some","none","other","value","fa1","fa2","isLeft","fa3","fa4","fa5","fa6","cursor","result","get","isRight","swap","Either","isEmpty","_isEmpty","undefined","_ref","None","Some","of","flatMap","that","nonEmpty","l","r","F","emptyOptionRef","_success","_failure","_isSuccess","_successRef","_failureRef","Failure","Success","failure","success","Try","tryUnitRef","isFailure","WrapFn","Empty","refs","CollectionCancelable","c","cancel","push","Cancelable","DummyCancelable","BoolWrapFn","BoolEmpty","AlreadyCanceledRef","_refs","cancelAll","BoolCancelable","canceled","AlreadyCanceledBoolCancelable","AlreadyCanceledAssignCancelableRef","MultiAssignCancelable","empty","AlreadyCanceledAssignCancelable","initial","_underlying","_canceled","SerialCancelable","_wasAssigned","SingleAssignCancelable","update","pop","StackedCancelable","_chained","isCanceled","keepSearching","ref2","prev","ChainedCancelable","label","toUpperCase","C0","C1","C2","C3","C4","C5","C6","MIN","MAX","trunc","Math","x","isNaN","NaN","floor","ceil","d","m","over","duration","unit","toNanos","TimeUnit","NANOSECONDS","Nanoseconds","toMicros","MICROSECONDS","Microseconds","toMillis","MILLISECONDS","Milliseconds","toSeconds","SECONDS","Seconds","toMinutes","MINUTES","Minutes","toHours","HOURS","Hours","toDays","DAYS","Days","isFinite","convert","Duration","Infinity","negInf","inf","d1","d2","ord","convertTo","plus","negate","s","o","n","cmp","millis","fn","setL","_previous","bindL","oldFn","oldPrev","ta","DynamicRef","array","minIndex","maxIndex","index","current","next","search","values","Object","toString","call","Symbol","iterator","arr","item","done","lnOf2","log","maxPowerOf2","nr","bit","log2","em","executionModel","type","executeBatched","executeAsync","trampoline","modulus","recommendedBatchSize","batchIndex","initialDelay","delay","runnable","loop","delayNow","scheduleOnce","task","period","delayNowMs","periodMs","startAt","currentTimeMillis","elapsedMs","nextDelayMs","max","Scheduler","globalSchedulerRef","batchSize","nextPowerOf2","ExecutionModel","batched","reporter","_isActive","_queue","_reporter","runLoop","canUseSetImmediate","global","reportFailure","_trampoline","Trampoline","_useSetImmediate","setImmediate","safeRunnable","setTimeout","execute","error","Date","now","ms","clearTimeout","GlobalScheduler","synchronous","bind","_stateRef","TestSchedulerState","updateTasks","_state","triggeredFailures","tasks","clock","state","scheduleAt","insertAt","tasksSearch","splice","filtered","ec2","TestScheduler","toExecute","jumpMs","executed","peek","random","nextTaskJump","add","min","arrayBSearchInsertPos","transformWith","Future","pure","_scheduler","transform","raise","onFulfilled","onRejected","ec","promiseThen","Promise","resolve","reject","onComplete","_","fold","delayedTick","err","map","after","fb","timeoutTo","lst","firstCompletedOf","FutureMaker","tryComplete","future","PureFuture","register","cRef","complete","ecAny","create","tailRecM","withScheduler","then","list","futureFirstCompletedOf","parallelism","futureTraverse","futureSequence","fl","sequence","_value","genericTransformWith","id","compressedRoot","xs","target","chainTo","_cancelable","AsyncFuture","cancelable","AsyncFutureState","scheduler","defer","tryA","fbb","cNext","clear","alt","fromPromise","skip","futures","futureIterableToArray","futureCancelAll","isDone","finishedCount","finalArray","fi","fa","isSuccess","failed","iterable","iterableToArray","futureTraverseLoop","batch","b","emptyIteratorRef","evalRunLoop","FlatMap","Eval","_funADType","Once","forEachL","always","Now","evalUnitRef","Always","Suspend","suspend","either","evalSequence","JSON","stringify","_thunk","_cache","_isError","source","bFirst","bRest","start","_popNextBind","fm","iteratorOf","evalSequenceLoop","acc","io","taskToFutureRunLoop","ioGenericRunLoop","IO","shift","callback","asyncUnsafe","ctx","conn","connection","run","unsafeStart","ioSafeCallback","fork","withExecutionModel","ctx2","IOContext","options","set","IOFlatMap","IOOnce","mem","onlySuccess","IOMemoize","recoverWith","IOAlways","safe","IOAsync","ioa","fromFuture","deferAction","ioListToFutureProcess","fromTry","IOPure","gather","ioSequence","ioShiftDefaultRef","ioShift","ioUnitRef","context","onlyOnSuccess","cache","g","autoCancelableRunLoops","shouldCancel","asFunction","signal","canCall","rcb","frameIndex","restart","RestartCallback","prepare","bFirstInit","bRestInit","_ioPopNextBind","_ioFindErrorHandler","nextIndex","boxed","runTry","flatM","async","ioStartMemoize","forcedAsync","ioRestartAsync","ioToFutureGoAsync","called","ioSequenceLoop","streamErrors","execInternals","all","Equiv","tc","instance","obj","types","existing","_funTypeId","_funSupertypeIds","Eq","eqv","y","z","eqOf","getTypeClassInstance","EqLaws","Functor","functorOf","FunctorLaws","ap","map2","Apply","applyMixins","fab","fbc","compose","product","ApplyLaws","applyOf","Applicative","ff","ApplicativeLaws","applicativeOf","recover","ApplicativeError","attempt","ApplicativeErrorLaws","applicativeErrorOf","followedBy","followedByL","forEffect","forEffectL","bounce","a0","a1","FlatMapLaws","flatMapOf","Monad","res","MonadLaws","monadOf","MonadError","MonadErrorLaws","monadErrorOf","CoflatMap","coflatMap","coflatten","CoflatMapLaws","coflatMapOf","Comonad","extract","fa0","ComonadLaws","comonadOf","testEq","__unit","OptionInstances","registerTypeClassInstance","TryInstances","faE","ffE","EitherInstances","EvalInstances","FutureInstances","IOInstances"],"mappings":"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"}