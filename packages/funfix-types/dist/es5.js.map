{"version":3,"file":"es5.js","sources":["../src/kinds.ts","../src/eq.ts","../src/functor.ts","../src/applicative.ts","../src/monad.ts","../src/comonad.ts","../src/instances.ts"],"sourcesContent":["/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IllegalArgumentError, NotImplementedError } from \"funfix-core\"\n\n/**\n * Given a type `T` representing instances of a class `C`, the type\n * `Constructor<T>` is the type of the class `C`.\n *\n * This type emulates\n * [Class<T> from Flow]{@link https://flow.org/en/docs/types/utilities/#classt-a-classtoc-idtoc-class-hreftoc-classa}.\n *\n * Note that in TypeScript constructors can also be `protected` or `private`\n * and unfortunately specifying `{ new(): T }` is thus insufficient.\n * Which is why, for classes without a public constructor, we have to\n * specify a `_funErasure` (static) member as a property, to help the compiler\n * infer type `T`.\n *\n * Example:\n *\n * ```typescript\n * class NumBox { constructor(public num: number) {} }\n * class GenBox<A> { constructor(public a: A) {} }\n *\n * function getDefault<F>(ref: Constructor<F>): Option<F> {\n *   if ((ref as any)._default) return Some(ref._default)\n *   return None\n * }\n *\n * (NumBox as any)._default = new NumBox(10)\n * (GenBox as any)._default = new GenBox(\"value\")\n *\n * const r1: Option<NumBox> = getDefault(NumBox)\n * const r2: Option<GenBox<any>> = getDefault(GenBox)\n * ```\n *\n * And for classes with a private constructor:\n *\n * ```typescript\n * class PrivateBox<A> {\n *   private constructor(public a: A) {}\n *\n *   static _funErasure: PrivateBox<any> // leaving undefined\n * }\n *\n * const F = PrivateBox as any\n * F._default = new F(\"hello\")\n *\n * const r: Option<PrivateBox<any>> = getDefault(NumBox)\n * ```\n */\nexport type Constructor<T> =\n  { new(...args: any[]): T } | { readonly _funErasure: T }\n\n/**\n * The `TypeClass` interface is to be implemented by type class\n * definitions, exposing IDs needed for discovery management.\n *\n * Only of interest to type class authors.\n */\nexport type TypeClass<F> = Constructor<F> & {\n  readonly _funTypeId: string\n  readonly _funSupertypeIds: string[]\n}\n\n/**\n * Lightweight encoding for higher kinded types.\n *\n * Inspired by the\n * [Lightweight higher-kinded polymorphism]{@link https://www.cl.cam.ac.uk/~jdy22/papers/lightweight-higher-kinded-polymorphism.pdf}\n * paper.\n *\n */\nexport interface HK<F, A> {\n  /** Trick for achieving nominal typing. */\n  readonly _funKindF: F\n\n  /** Trick for achieving nominal typing. */\n  readonly _funKindA: A\n}\n\n/**\n * Data type for expressing equivalence in type class laws.\n *\n * @final\n */\nexport class Equiv<A> {\n  private constructor(\n    public readonly lh: A,\n    public readonly rh: A) {}\n\n  static of<A>(lh: A, rh: A): Equiv<A> {\n    return new Equiv(lh, rh)\n  }\n}\n\n/**\n * Given a {@link TypeClass} definition in `tc`, register an `instance`\n * for the given {@link Constructor} specified by `c` that implements the\n * given type class.\n *\n * Example:\n *\n * ```typescript\n * registerTypeClassInstance(Functor)(Box, new BoxFunctorInstance())\n * ```\n *\n * Data types can have only one implementation for a given type class.\n * Multiple implementations are not allowed, therefore registration needs\n * to happen at most once. If registration happens multiple times for\n * instances of the same data type and type class, then an exception is\n * going to be raised:\n *\n * ```typescript\n * // Ok\n * registerTypeClassInstance(Functor)(Box, new FunctorInstance1())\n *\n * // IllegalArgumentError: Type class coherence issue,\n * // Functor<Box> is already defined!\n * registerTypeClassInstance(Functor)(Box, new FunctorInstance1())\n * ```\n *\n * Note that type classes can have super types. So for example registering\n * a `Monad` instance will also register a `Functor` instance, along with\n * `Applicative`. The registration of supertypes however does not trigger\n * coherence errors. In this example, if you try registering a `Monad`,\n * but a `Functor` was already registered, then that the given `Monad`\n * will simply not be registered as a `Functor` for that data type.\n *\n * This is legal:\n *\n * ```typescript\n * // Ok\n * registerTypeClassInstance(Functor)(Box, new FunctorInstance())\n *\n * // Ok, even though a Monad is also a Functor\n * registerTypeClassInstance(Functor)(Box, new MonadInstance())\n * ```\n *\n * @throws `IllegalArgumentError` in case such a type class instance\n * was already specified, thus leading to a coherence issue.\n */\nexport function registerTypeClassInstance<F>(tc: TypeClass<F>):\n  <T>(c: Constructor<T>, instance: F) => void {\n\n  return <T>(c: Constructor<T>, instance: F) => {\n    const obj = c as any\n    const types: {[id: string]: any} = (obj[\"_funTypes\"] || {})\n    obj[\"_funTypes\"] = types\n\n    const existing = types[tc._funTypeId]\n    if (existing) {\n      // If trying to register the same instance, then ignore\n      if (existing === instance) return\n      // Coherence issue\n      const name = existing.constructor.name\n      throw new IllegalArgumentError(\n        \"Type class coherence issue, \" +\n        `${name}<${(c as any).name}> is already defined!`\n      )\n    }\n\n    types[tc._funTypeId] = instance\n    for (const id of tc._funSupertypeIds) {\n      if (!types[id]) types[id] = instance\n    }\n  }\n}\n\n/**\n * Given a {@link TypeClass} instance and a {@link Constructor} reference,\n * returns its associated type class implementation if it exists, or throws\n * a `NotImplementedError` in case there's no such association.\n *\n * ```typescript\n * import { Option, Functor, getTypeClass } from \"funfix\"\n *\n * const F: Functor<Option<any>> = getTypeClass(Functor, Option)\n * ```\n */\nexport function getTypeClassInstance<F>(tc: TypeClass<F>):\n  <T>(c: Constructor<T>) => F {\n\n  return <T>(c: Constructor<T>) => {\n    const obj = c as any\n    const types: {[id: string]: any} = obj[\"_funTypes\"] || {}\n    const instance = types[tc._funTypeId]\n    if (instance) return instance as any\n    throw new NotImplementedError(`${(tc as any).name}<${obj.name}>`)\n  }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Constructor, getTypeClassInstance } from \"./kinds\"\nimport { is } from \"funfix-core\"\n\n/**\n * The `Eq` is a type class used to determine equality between 2\n * instances of the same type. Any 2 instances `x` and `y` are equal\n * if `eqv(x, y)` is `true`. Moreover, `eqv` should form an\n * equivalence relation.\n *\n * Example:\n *\n * ```typescript\n * const F = eqOf(Option)\n *\n * F.eqv(Some(1), Some(1)) // true\n * F.eqv(Some(1), None)    // false\n * ```\n *\n * MUST obey the laws defined in {@link EqLaws}.\n *\n * CREDITS: this type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class Eq<A> {\n  abstract eqv(lh: A, rh: A): boolean\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"eq\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = []\n  /** @hidden */\n  static readonly _funErasure: Eq<any>\n\n  /**\n   * Tests equality for two values of type `A` by using the type's\n   * registered `Eq` instance, falling back to the universal equality\n   * defined by `is` and `IEquals` (in `funfix-core`) in case no such\n   * `Eq<A>` is implemented.\n   */\n  static testEq<A>(lh: A, rh: A): boolean {\n    if (!lh) return is(lh, rh)\n    const types: {[id: string]: any} = (lh as any).constructor[\"_funTypes\"] || {}\n    const instance = types[Eq._funTypeId]\n    if (instance) return instance.eqv(lh, rh)\n    // Fallback to IEquals or reference equality\n    return is(lh, rh)\n  }\n}\n\n/**\n * Type class laws defined for {@link Eq}.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class EqLaws<A> {\n  /**\n   * The {@link Eq} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: Eq<A>\n\n  /**\n   * Equality is reflexive, i.e.\n   * ```\n   * a == a\n   * ```\n   */\n  reflexive(a: A): boolean {\n    return this.F.eqv(a, a)\n  }\n\n  /**\n   * Equality is symmetric, i.e.\n   * ```\n   * x == y <-> y == x\n   * ```\n   */\n  symmetric(x: A, y: A): boolean {\n    return this.F.eqv(x, y) === this.F.eqv(y, x)\n  }\n\n  /**\n   * Equality is transitive, i.e.\n   * ```\n   * x == y && y == z -> x == z\n   * ```\n   */\n  transitive(x: A, y: A, z: A): boolean {\n    return !(this.F.eqv(x, y) && this.F.eqv(y, z)) || this.F.eqv(x, z)\n  }\n}\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link Eq} instance if it exists, or throws a `NotImplementedError`\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, Eq, eqOf } from \"funfix\"\n *\n * const F: Eq<Option<any>> = eqOf(Option)\n * ```\n */\nexport const eqOf: <F>(c: Constructor<F>) => Eq<F> =\n  getTypeClassInstance(Eq)\n\n/**\n * Given an {@link Eq} instance, returns the {@link EqLaws}\n * associated with it.\n */\nexport function eqLawsOf<A>(instance: Eq<A>): EqLaws<A> {\n  return new (class extends EqLaws<A> { public readonly F = instance })()\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { id } from \"funfix-core\"\nimport { HK, Equiv, Constructor, getTypeClassInstance } from \"./kinds\"\n\n/**\n * The `Functor` is a type class providing the `map` operation that\n * allows lifting an `f` function into the functor context and\n * applying it.\n *\n * The name is short for \"covariant functor\".\n *\n * Example:\n *\n * ```typescript\n * const F = functorOf(Option)\n *\n * F.map(Some(1), x => x + 1) // Some(2)\n * ```\n *\n * MUST obey the laws defined in {@link FunctorLaws}.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import { HK, Functor, registerTypeClassInstance } from \"funfix\"\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: T) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note these can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * // Type alias defined for readability\n * type BoxK<T> = HK<Box<any>, T>\n *\n * // Actual implementation\n * class BoxFunctor implements Functor<Box<any>> {\n *   map<A, B>(fa: BoxK<A>, f: (a: A) => B): Box<B> {\n *     const a = (fa as Box<A>).value\n *     return new Box(f(a))\n *   }\n * }\n *\n * // Registering global Functor instance for Box\n * registerTypeClassInstance(Functor)(Box, new BoxFunctor())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class Functor<F> {\n  /**\n   * Given a mapping function, transforms the source.\n   *\n   * The `map` operation must follow these laws:\n   *\n   * - `fa.map(id) <-> fa`\n   * - `fa.map(f).map(g) <-> fa.map(x => g(f(x)))`\n   */\n  abstract map<A, B>(fa: HK<F, A>, f: (a: A) => B): HK<F, B>\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"functor\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = []\n  /** @hidden */\n  static readonly _funErasure: Functor<any>\n}\n\n/**\n * Type class laws defined for {@link Functor}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class FunctorLaws<F> {\n  /**\n   * The {@link Functor} designated instance for `F`,\n   * to be tested.\n   */\n  abstract readonly F: Functor<F>\n\n  /**\n   * ```typescript\n   * fa.map(id) <-> fa\n   * ```\n   */\n  covariantIdentity<A>(fa: HK<F, A>): Equiv<HK<F, A>> {\n    return Equiv.of(this.F.map(fa, id), fa)\n  }\n\n  /**\n   * ```typescript\n   * fa.map(f).map(g) <-> fa.map(x => g(f(x)))\n   * ```\n   */\n  covariantComposition<A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C): Equiv<HK<F, C>> {\n    return Equiv.of(\n      this.F.map(this.F.map(fa, f), g),\n      this.F.map(fa, x => g(f(x)))\n    )\n  }\n}\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link Functor} instance if it exists, or throws a `NotImplementedError`\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, Functor, functorOf } from \"funfix\"\n *\n * const F: Functor<Option<any>> = functorOf(Option)\n * ```\n */\nexport const functorOf: <F>(c: Constructor<F>) => Functor<F> =\n  getTypeClassInstance(Functor)\n\n/**\n * Given an {@link Functor} instance, returns the {@link FunctorLaws}\n * associated with it.\n */\nexport function functorLawsOf<F>(instance: Functor<F>): FunctorLaws<F> {\n  return new (class extends FunctorLaws<F> { public readonly F = instance })()\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HK, Equiv, Constructor, getTypeClassInstance } from \"./kinds\"\nimport { Functor, FunctorLaws } from \"./functor\"\nimport { Either, Right, Left, applyMixins } from \"funfix-core\"\n\n/**\n * The `Apply` type class, a weaker version of {@link Applicative},\n * exposing `ap` (apply), but not `pure`.\n *\n * This type class is exposed in addition to `Applicative` because\n * there are data types for which we can't implement `pure`, but\n * that could still benefit from an `ap` definition. For example\n * in case of a `Map<K, ?>` we couldn't define `pure` for it\n * because we don't have a `K` key.\n *\n * MUST obey the laws defined in {@link ApplyLaws}.\n *\n * Note that having an `Apply` instance implies that a\n * {@link Functor} implementation is also available, which is why\n * `Apply` is a subtype of `Functor`.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK, Apply,\n *   registerTypeClassInstance,\n *   applyMixins\n * } from \"funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: T) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note these can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxApply implements Apply<Box<any>> {\n *   map<A, B>(fa: BoxK<A>, f: (a: A) => B): Box<B> {\n *     const a = (fa as Box<A>).value\n *     return new Box(f(a))\n *   }\n *\n *   ap<A, B>(fa: BoxK<A>, ff: BoxK<(a: A) => B>): Box<B> {\n *     const a = (fa as Box<A>).value\n *     const f = (ff as Box<(a: A) => B>).value\n *     return new Box(f(a))\n *   }\n *\n *   // Mixed-in, as these have default implementations\n *   map2: <A, B, Z>(fa: BoxK<A>, fb: BoxK<B>, f: (a: A, b: B) => Z) => Box<Z>\n *   product: <A, B> (fa: BoxK<A>, fb: BoxK<B>) => Box<[A, B]>\n * }\n *\n * // Call needed in order to implement `map2` and `product` using\n * // the default implementations defined by `Apply`, because\n * // we are using `implements` instead of `extends` above and\n * // because in this sample we want the default implementations,\n * // but note that you can always provide your own definitions\n * applyMixins(BoxApply, [Apply])\n *\n * // Registering global Apply instance for Box, needed in order\n * // for the `applyOf(Box)` calls to work\n * registerTypeClassInstance(Apply)(Box, new BoxApply())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class Apply<F> implements Functor<F> {\n  /**\n   * Given a value and a function in the `Apply` context,\n   * applies the function to the value.\n   */\n  abstract ap<A, B>(fa: HK<F, A>, ff: HK<F, (a: A) => B>): HK<F, B>\n\n  /** Inherited from {@link Functor.map}. */\n  abstract map<A, B>(fa: HK<F, A>, f: (a: A) => B): HK<F, B>\n\n  /**\n   * Applies the pure (binary) function `f` to the effectful values\n   * `fa` and `fb`.\n   *\n   * `map2` can be seen as a binary version of {@link Functor.map}.\n   */\n  map2<A, B, Z>(fa: HK<F, A>, fb: HK<F, B>, f: (a: A, b: B) => Z): HK<F, Z> {\n    return this.ap(fb, this.map(fa, a => (b: B) => f(a, b)))\n  }\n\n  /**\n   * Captures the idea of composing independent effectful values.\n   *\n   * It is of particular interest when taken together with [[Functor]].\n   * Where [[Functor]] captures the idea of applying a unary pure\n   * function to an effectful value, calling `product` with `map`\n   * allows one to apply a function of arbitrary arity to multiple\n   * independent effectful values.\n   *\n   * This operation is equivalent with:\n   *\n   * ```typescript\n   * map2(fa, fb, (a, b) => [a, b])\n   * ```\n   */\n  product<A, B>(fa: HK<F, A>, fb: HK<F, B>): HK<F, [A, B]> {\n    return this.map2(fa, fb, (a: A, b: B) => [a, b] as [A, B])\n  }\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"apply\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = [\"functor\"]\n  /** @hidden */\n  static readonly _funErasure: Apply<any>\n}\n\napplyMixins(Apply, [Functor])\n\n/**\n * Type class laws defined for {@link Apply}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class ApplyLaws<F> implements FunctorLaws<F> {\n  /**\n   * The {@link Apply} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: Apply<F>\n\n  applyComposition<A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>): Equiv<HK<F, C>> {\n    const F = this.F\n    const compose = (f: (b: B) => C) => (\n      (g: (a: A) => B) => (a: A) => f(g(a))\n    )\n\n    return Equiv.of(\n      F.ap(F.ap(fa, fab), fbc),\n      F.ap(fa, F.ap(fab, F.map(fbc, compose)))\n    )\n  }\n\n  applyProductConsistency<A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.ap(fa, f),\n      F.map(F.product(f, fa), p => { const [f, a] = p; return f(a) })\n    )\n  }\n\n  applyMap2Consistency<A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.ap(fa, f),\n      F.map2(f, fa, (f, a) => f(a))\n    )\n  }\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n}\n\napplyMixins(ApplyLaws, [FunctorLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link Apply} instance if it exists, or throws a `NotImplementedError`\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, Apply, applyOf } from \"funfix\"\n *\n * const F: Apply<Option<any>> = applyOf(Option)\n * ```\n */\nexport const applyOf: <F>(c: Constructor<F>) => Apply<F> =\n  getTypeClassInstance(Apply)\n\n/**\n * Given an {@link Apply} instance, returns the {@link ApplyLaws}\n * associated with it.\n */\nexport function applyLawsOf<F>(instance: Apply<F>): ApplyLaws<F> {\n  return new (class extends ApplyLaws<F> { public readonly F = instance })()\n}\n\n/**\n * `Applicative` functor type class.\n *\n * Allows application of a function in an Applicative context to a\n * value in an `Applicative` context.\n *\n * References:\n *\n * - [The Essence of the Iterator Pattern]{@link https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf}\n * - [Applicative programming with effects]{@link http://staff.city.ac.uk/~ross/papers/Applicative.pdf}\n *\n * Example:\n *\n * ```typescript\n * const F = applicativeOf(Option)\n *\n * F.ap(F.pure(1), F.pure((x: number) => x + 1)) // Some(2)\n * ```\n *\n * Note that having an `Applicative` instance implies\n * {@link Functor} and {@link Apply} implementations are also\n * available, which is why `Applicative` is a subtype of\n * `Functor` and `Apply`.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK, Applicative,\n *   registerTypeClassInstance,\n *   applyMixins\n * } from \"funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: T) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note they can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxApplicative implements Applicative<Box<any>> {\n *   pure<A>(a: A): Box<A> { return new Box(a) }\n *\n *   ap<A, B>(fa: BoxK<A>, ff: BoxK<(a: A) => B>): Box<B> {\n *     const a = (fa as Box<A>).value\n *     const f = (ff as Box<(a: A) => B>).value\n *     return new Box(f(a))\n *   }\n *\n *   // Mixed-in, as these have default implementations\n *   map: <A, B>(fa: BoxK<A>, f: (a: A) => B) => Box<B>\n *   map2: <A, B, Z>(fa: BoxK<A>, fb: BoxK<B>, f: (a: A, b: B) => Z) => Box<Z>\n *   product: <A, B> (fa: BoxK<A>, fb: BoxK<B>) => Box<[A, B]>\n *   unit: () => Box<void>\n * }\n *\n * // Call needed in order to implement `map`, `map2`, `product` and `unit`,\n * // using the default implementations defined by `Applicative`, because\n * // we are using `implements` instead of `extends` above and\n * // because in this sample we want the default implementations,\n * // but note that you can always provide your own\n * applyMixins(BoxApplicative, [Applicative])\n *\n * // Registering global Applicative instance for Box, needed in order\n * // for the `functorOf(Box)`, `applyOf(Box)` and `applicativeOf(Box)`\n * // calls to work\n * registerTypeClassInstance(Applicative)(Box, new BoxApplicative())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class Applicative<F> implements Apply<F> {\n  /**\n   * Lifts a strict value `A` into the `F<A>` context.\n   */\n  abstract pure<A>(a: A): HK<F, A>\n\n  /** Inherited from {@link Apply.ap}. */\n  abstract ap<A, B>(fa: HK<F, A>, ff: HK<F, (a: A) => B>): HK<F, B>\n\n  /**\n   * Shorthand for `pure<void>(undefined)`, provided for convenience\n   * and because implementations can override the default for\n   * optimization purposes.\n   */\n  unit(): HK<F, void> {\n    return this.pure(undefined)\n  }\n\n  /** Inherited from {@link Functor.map}. */\n  map<A, B>(fa: HK<F, A>, f: (a: A) => B): HK<F, B> {\n    return this.ap(fa, this.pure(f))\n  }\n\n  /** Mixed-in from {@link Apply.map2}. */\n  map2: <A, B, Z>(fa: HK<F, A>, fb: HK<F, B>, f: (a: A, b: B) => Z) => HK<F, Z>\n  /** Mixed-in from {@link Apply.product}. */\n  product: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => HK<F, [A, B]>\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"applicative\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = [\"functor\", \"apply\"]\n  /** @hidden */\n  static readonly _funErasure: Applicative<any>\n}\n\napplyMixins(Applicative, [Apply])\n\n/**\n * Type class laws defined for {@link Applicative}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class ApplicativeLaws<F> implements ApplyLaws<F> {\n  /**\n   * The {@link Applicative} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: Applicative<F>\n\n  applicativeIdentity<A>(fa: HK<F, A>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(\n      F.ap(fa, F.pure((a: A) => a)),\n      fa\n    )\n  }\n\n  applicativeHomomorphism<A, B>(a: A, f: (a: A) => B): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.ap(F.pure(a), F.pure(f)),\n      F.pure(f(a))\n    )\n  }\n\n  applicativeInterchange<A, B>(a: A, ff: HK<F, (a: A) => B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.ap(F.pure(a), ff),\n      F.ap(ff, F.pure((f: (a: A) => B) => f(a)))\n    )\n  }\n\n  applicativeMap<A, B>(fa: HK<F, A>, f: (a: A) => B): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.map(fa, f),\n      F.ap(fa, F.pure(f))\n    )\n  }\n\n  applicativeComposition<A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>): Equiv<HK<F, C>> {\n    const F = this.F\n    const compose = (f: (b: B) => C) => (\n      (g: (a: A) => B) => (a: A) => f(g(a))\n    )\n\n    return Equiv.of(\n      F.ap(fa, F.ap(fab, F.ap(fbc, F.pure(compose)))),\n      F.ap(F.ap(fa, fab), fbc)\n    )\n  }\n\n  applicativeUnit<A>(a: A): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(F.map(F.unit(), _ => a), F.pure(a))\n  }\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n\n  /** Mixed-in from {@link ApplyLaws.applyComposition}. */\n  applyComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link ApplyLaws.applyProductConsistency}. */\n  applyProductConsistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplyLaws.applyMap2Consistency}. */\n  applyMap2Consistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n}\n\napplyMixins(ApplicativeLaws, [ApplyLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link Applicative} instance if it exists, or throws a `NotImplementedError`\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, Applicative, applicativeOf } from \"funfix\"\n *\n * const F: Applicative<Option<any>> = applicativeOf(Option)\n * ```\n */\nexport const applicativeOf: <F>(c: Constructor<F>) => Applicative<F> =\n  getTypeClassInstance(Applicative)\n\n/**\n * Given an {@link Applicative} instance, returns the {@link ApplicativeLaws}\n * associated with it.\n */\nexport function applicativeLawsOf<F>(instance: Applicative<F>): ApplicativeLaws<F> {\n  return new (class extends ApplicativeLaws<F> { public readonly F = instance })()\n}\n\n/**\n * The `ApplicativeError` type class is a {@link Applicative} that\n * also allows you to raise and or handle an error value.\n *\n * This type class allows one to abstract over error-handling\n * applicative types.\n *\n * MUST follow the law defined in {@link ApplicativeErrorLaws}.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK,\n *   ApplicativeError,\n *   registerTypeClassInstance,\n *   applyMixins,\n *   Try\n * } from \"funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: Try<T>) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note they can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxApplicativeError implements ApplicativeError<Box<any>, any> {\n *   pure<A>(a: A): Box<A> { return new Box(Try.success(a)) }\n *\n *   ap<A, B>(fa: BoxK<A>, ff: BoxK<(a: A) => B>): Box<B> {\n *     const ta = (fa as Box<A>).value\n *     const tf = (ff as Box<(a: A) => B>).value\n *     return new Box(Try.map2(ta, tf, (a, f) => f(a)))\n *   }\n *\n *   raise<A>(e: any): HK<Box<any>, A> {\n *     return new Box(Try.failure(e))\n *   }\n *\n *   recoverWith<A>(fa: BoxK<A>, f: (e: any) => BoxK<A>): HK<Box<any>, A> {\n *     return new Box((fa as Box<A>).value.recoverWith(e => (f(e) as Box<A>).value))\n *   }\n *\n *   // Mixed-in, as these have default implementations\n *   map: <A, B>(fa: BoxK<A>, f: (a: A) => B) => Box<B>\n *   map2: <A, B, Z>(fa: BoxK<A>, fb: BoxK<B>, f: (a: A, b: B) => Z) => Box<Z>\n *   product: <A, B> (fa: BoxK<A>, fb: BoxK<B>) => Box<[A, B]>\n *   unit: () => Box<void>\n *   recover: <A>(fa: HK<Box<any>, A>, f: (e: any) => A) => HK<Box<any>, A>\n *   attempt: <A>(fa: HK<Box<any>, A>) => HK<Box<any>, Either<any, A>>\n * }\n *\n * // Call needed in order to implement `map`, `map2`, `product`, etc.\n * // using the default implementations defined by `ApplicativeError`,\n * // because we are using `implements` instead of `extends` above and\n * // because in this sample we want the default implementations,\n * // but note that you can always provide your own\n * applyMixins(BoxApplicativeError, [ApplicativeError])\n *\n * // Registering global ApplicativeError instance for Box, needed in order\n * // for the `functorOf(Box)`, `applyOf(Box)`, `applicativeOf(Box)`\n * // and `applicativeErrorOf(Box)` calls to work\n * registerTypeClassInstance(ApplicativeError)(Box, new BoxApplicativeError())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class ApplicativeError<F, E> implements Applicative<F> {\n  /**\n   * Lift an error into the `F` context.\n   */\n  abstract raise<A>(e: E): HK<F, A>\n\n  /**\n   * Handle any error, potentially recovering from it, by mapping it to an\n   * `F<A>` value.\n   *\n   * @see {@link recover} to handle any error by simply mapping it to an `A`\n   * value instead of an `F<A>`.\n   */\n  abstract recoverWith<A>(fa: HK<F, A>, f: (e: E) => HK<F, A>): HK<F, A>\n\n  /**\n   * Handle any error by mapping it to an `A` value.\n   *\n   * @see {@link recoverWith} to map to an `F[A]` value instead of\n   * simply an `A` value.\n   */\n  recover<A>(fa: HK<F, A>, f: (e: E) => A): HK<F, A> {\n    const F = this\n    return F.recoverWith(fa, e => F.pure(f(e)))\n  }\n\n  /**\n   * Handle errors by turning them into `Either` values.\n   *\n   * If there is no error, then a `Right` value will be returned.\n   * All non-fatal errors should be handled by this method.\n   */\n  attempt<A>(fa: HK<F, A>): HK<F, Either<E, A>> {\n    const F = this\n    return F.recover(\n      F.map(fa, a => Either.right<E, A>(a)),\n      Left)\n  }\n\n  /** Inherited from {@link Applicative.pure}. */\n  abstract pure<A>(a: A): HK<F, A>\n\n  /** Inherited from {@link Applicative.ap}. */\n  abstract ap<A, B>(fa: HK<F, A>, ff: HK<F, (a: A) => B>): HK<F, B>\n\n  /** Mixed-in from {@link Applicative.unit}. */\n  unit: () => HK<F, void>\n  /** Mixed-in from {@link Applicative.map}. */\n  map: <A, B>(fa: HK<F, A>, f: (a: A) => B) => HK<F, B>\n  /** Mixed-in from {@link Apply.map2}. */\n  map2: <A, B, Z>(fa: HK<F, A>, fb: HK<F, B>, f: (a: A, b: B) => Z) => HK<F, Z>\n  /** Mixed-in from {@link Apply.product}. */\n  product: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => HK<F, [A, B]>\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"applicativeError\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = [\"functor\", \"apply\", \"applicative\"]\n  /** @hidden */\n  static readonly _funErasure: ApplicativeError<any, any>\n}\n\napplyMixins(ApplicativeError, [Applicative])\n\n/**\n * Type class laws defined for {@link ApplicativeError}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class ApplicativeErrorLaws<F, E> implements ApplicativeLaws<F> {\n  /**\n   * The {@link Applicative} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: ApplicativeError<F, E>\n\n  applicativeErrorRecoverWith<A>(e: E, f: (e: E) => HK<F, A>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(F.recoverWith(F.raise<A>(e), f), f(e))\n  }\n\n  applicativeErrorRecover<A>(e: E, f: (e: E) => A): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(F.recover(F.raise<A>(e), f), F.pure(f(e)))\n  }\n\n  recoverWithPure<A>(a: A, f: (e: E) => HK<F, A>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(F.recoverWith(F.pure(a), f), F.pure(a))\n  }\n\n  recoverPure<A>(a: A, f: (e: E) => A): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(F.recover(F.pure(a), f), F.pure(a))\n  }\n\n  raiseErrorAttempt(e: E): Equiv<HK<F, Either<E, void>>> {\n    const F = this.F\n    return Equiv.of(F.attempt(F.raise<void>(e)), F.pure(Left(e)))\n  }\n\n  pureAttempt<A>(a: A): Equiv<HK<F, Either<E, A>>> {\n    const F = this.F\n    return Equiv.of(F.attempt(F.pure(a)), F.pure(Right(a)))\n  }\n\n  /** Mixed-in from {@link ApplicativeLaws.applicativeIdentity}. */\n  applicativeIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeHomomorphism}. */\n  applicativeHomomorphism: <A, B>(a: A, f: (a: A) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeInterchange}. */\n  applicativeInterchange: <A, B>(a: A, ff: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeMap}. */\n  applicativeMap: <A, B>(fa: HK<F, A>, f: (a: A) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeComposition}. */\n  applicativeComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeUnit}. */\n  applicativeUnit: <A>(a: A) => Equiv<HK<F, A>>\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n\n  /** Mixed-in from {@link ApplyLaws.applyComposition}. */\n  applyComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link ApplyLaws.applyProductConsistency}. */\n  applyProductConsistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplyLaws.applyMap2Consistency}. */\n  applyMap2Consistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n}\n\napplyMixins(ApplicativeErrorLaws, [ApplicativeLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link ApplicativeError} instance if it exists, or throws a `NotImplementedError`\n * in case there's no such association.\n *\n * ```typescript\n * import { Eval, ApplicativeError, applicativeErrorOf } from \"funfix\"\n *\n * const F: ApplicativeError<Option<any>> = applicativeErrorOf(Eval)\n * ```\n */\nexport const applicativeErrorOf: <F, E>(c: Constructor<F>) => ApplicativeError<F, E> =\n  getTypeClassInstance(ApplicativeError)\n\n/**\n * Given an {@link ApplicativeError} instance, returns the\n * {@link ApplicativeErrorLaws} associated with it.\n */\nexport function applicativeErrorLawsOf<F,E>(instance: ApplicativeError<F,E>): ApplicativeErrorLaws<F,E> {\n  return new (class extends ApplicativeErrorLaws<F,E> { public readonly F = instance })()\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Either, Right, Left, applyMixins } from \"funfix-core\"\nimport { HK, Equiv, Constructor, getTypeClassInstance } from \"./kinds\"\nimport {\n  Apply,\n  ApplyLaws,\n  Applicative,\n  ApplicativeLaws,\n  ApplicativeError,\n  ApplicativeErrorLaws\n} from \"./applicative\"\n\n/**\n * The `FlatMap` type class is a lightweight {@link Monad}.\n *\n * It exposes [flatMap]{@link FlatMap.flatMap}, which allows to have a\n * value in a context (`F<A>`) and then feed that into a function that\n * takes a normal value and returns a value in a context\n * (`A => F<B>`).\n *\n * One motivation for separating this out from `Monad` is that there are\n * situations where we can implement `flatMap` but not `pure`. For example,\n * we can implement `map` or `flatMap` that transforms the values of a\n * `Map<K, ?>` type, but we can't implement `pure` (because we wouldn't\n * know what key to use when instantiating the new `Map`).\n *\n * Must obey the laws defined in {@link FlatMapLaws}.\n *\n * Note that having an `Monad` instance implies\n * {@link Functor} and {@link Apply} implementations are also available,\n * as `FlatMap` is a subtype of these.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK, FlatMap, Either,\n *   registerTypeClassInstance,\n *   applyMixins\n * } from \"../src/funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: T) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note they can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxFlatMap implements FlatMap<Box<any>> {\n *   map<A, B>(fa: BoxK<A>, f: (a: A) => B): Box<B> {\n *     return new Box(f((fa as Box<A>).value))\n *   }\n *\n *   flatMap<A, B>(fa: BoxK<A>, f: (a: A) => BoxK<B>): Box<B> {\n *     return f((fa as Box<A>).value) as Box<B>\n *   }\n *\n *   tailRecM<A, B>(a: A, f: (a: A) => BoxK<Either<A, B>>): Box<B> {\n *     let cursor = a\n *     while (true) {\n *       const box = f(cursor) as Box<Either<A, B>>\n *       const v = box.value\n *       if (v.isRight()) return new Box(v.get())\n *       cursor = v.swap().get()\n *     }\n *   }\n *\n *   // Mixed-in, as these have default implementations\n *   map2: <A, B, Z>(fa: BoxK<A>, fb: BoxK<B>, f: (a: A, b: B) => Z) => Box<Z>\n *   ap: <A, B>(fa: BoxK<A>, ff: BoxK<(a: A) => B>) => Box<B>\n *   product: <A, B> (fa: BoxK<A>, fb: BoxK<B>) => Box<[A, B]>\n *   unit: () => Box<void>\n *   followedBy: <A, B>(fa: BoxK<A>, fb: BoxK<B>) => Box<B>\n *   followedByL: <A, B>(fa: BoxK<A>, fb: () => BoxK<B>) => Box<B>\n *   forEffect: <A, B>(fa: BoxK<A>, fb: BoxK<B>) => Box<A>\n *   forEffectL: <A, B>(fa: BoxK<A>, fb: () => BoxK<B>) => Box<A>\n * }\n *\n * // Call needed in order to implement `map`, `map2`, `product`, etc.\n * // using the default implementations defined by `FlatMap`, because\n * // we are using `implements` instead of `extends` above and\n * // because in this sample we want the default implementations,\n * // but note that you can always provide your own\n * applyMixins(BoxFlatMap, [FlatMap])\n *\n * // Registering global Functor instance for Box, needed in order\n * // for the `functorOf(Box)`, `applyOf(Box)`, `applicativeOf(Box)`\n * // and `flatMapOf(Box)` calls to work\n * registerTypeClassInstance(FlatMap)(Box, new BoxFunctor())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class FlatMap<F> implements Apply<F> {\n  abstract flatMap<A, B>(fa: HK<F, A>, f: (a: A) => HK<F, B>): HK<F, B>\n\n  /** Inherited from {@link Functor.map}. */\n  abstract map<A, B>(fa: HK<F, A>, f: (a: A) => B): HK<F, B>\n\n  /**\n   * Keeps calling `f` until a `Right(b)` is returned.\n   *\n   * Based on Phil Freeman's\n   * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.\n   *\n   * Implementations of this method should use constant stack space relative to `f`.\n   */\n  abstract tailRecM<A, B>(a: A, f: (a: A) => HK<F, Either<A, B>>): HK<F, B>\n\n  /**\n   * Sequentially compose two actions, discarding any value produced\n   * by the first.\n   *\n   * See [followedByL]{@link FlatMap.followedByL} for a lazy version.\n   */\n  followedBy<A, B>(fa: HK<F, A>, fb: HK<F, B>): HK<F, B> {\n    return this.flatMap(fa, _ => fb)\n  }\n\n  /**\n   * Sequentially compose two actions, discarding any value produced\n   * by the first.\n   *\n   * See [followedBy]{@link FlatMap.followedBy} for the strict version.\n   */\n  followedByL<A, B>(fa: HK<F, A>, fb: () => HK<F, B>): HK<F, B> {\n    return this.flatMap(fa, _ => fb())\n  }\n\n  /**\n   * Sequentially compose two actions, discarding any value\n   * produced by the second.\n   *\n   * See [forEffectL]{@link FlatMap.forEffectL} for the lazy version.\n   */\n  forEffect<A, B>(fa: HK<F, A>, fb: HK<F, B>): HK<F, A> {\n    return this.flatMap(fa, a => this.map(fb, _ => a))\n  }\n\n  /**\n   * Sequentially compose two actions, discarding any value\n   * produced by the second.\n   *\n   * See [forEffect]{@link FlatMap.forEffect} for the strict version.\n   */\n  forEffectL<A, B>(fa: HK<F, A>, fb: () => HK<F, B>): HK<F, A> {\n    return this.flatMap(fa, a => this.map(fb(), _ => a))\n  }\n\n  /** Inherited from {@link Apply.ap}. */\n  ap<A, B>(fa: HK<F, A>, ff: HK<F, (a: A) => B>): HK<F, B> {\n    return this.flatMap(fa, a => this.map(ff, f => f(a)))\n  }\n\n  /** Inherited from {@link Apply.map2}. */\n  map2<A, B, Z>(fa: HK<F, A>, fb: HK<F, B>, f: (a: A, b: B) => Z): HK<F, Z> {\n    return this.flatMap(fa, a => this.map(fb, b => f(a, b)))\n  }\n\n  /** Inherited from {@link Apply.product}. */\n  product<A, B>(fa: HK<F, A>, fb: HK<F, B>): HK<F, [A, B]> {\n    return this.flatMap(fa, a => this.map(fb, b => [a, b] as [A, B]))\n  }\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"flatMap\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = [\"functor\", \"apply\"]\n  /** @hidden */\n  static readonly _funErasure: FlatMap<any>\n}\n\n/**\n * Type class laws defined for {@link FlatMap}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class FlatMapLaws<F> implements ApplyLaws<F> {\n  /**\n   * The {@link Apply} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: FlatMap<F>\n\n  /**\n   * ```typescript\n   *  fa.flatMap(f).flatMap(g) <-> fa.flatMap(a => f(a).flatMap(g))\n   *  ```\n   */\n  flatMapAssociativity<A, B, C>(fa: HK<F, A>, f: (a: A) => HK<F, B>, g: (b: B) => HK<F, C>): Equiv<HK<F, C>> {\n    const F = this.F\n    return Equiv.of(\n      F.flatMap(F.flatMap(fa, f), g),\n      F.flatMap(fa, a => F.flatMap(f(a), g))\n    )\n  }\n\n  /**\n   * ```typescript\n   * fab.ap(fa) <-> fab.flatMap(f => fa.map(f))\n   * ```\n   */\n  flatMapConsistentApply<A, B>(fa: HK<F, A>, fab: HK<F, (a: A) => B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.ap(fa, fab),\n      F.flatMap(fab, f => F.map(fa, f))\n    )\n  }\n\n  /**\n   * ```typescript\n   * fa.followedBy(fb) <-> fa.flatMap(_ => fb)\n   * ```\n   */\n  followedByConsistency<A, B>(fa: HK<F, A>, fb: HK<F, B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.followedBy(fa, fb),\n      F.flatMap(fa, _ => fb)\n    )\n  }\n\n  /**\n   * ```typescript\n   * fa.followedBy(() => fb) <-> fa.flatMap(_ => fb)\n   * ```\n   */\n  followedByLConsistency<A, B>(fa: HK<F, A>, fb: HK<F, B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.followedByL(fa, () => fb),\n      F.flatMap(fa, _ => fb)\n    )\n  }\n\n  /**\n   * ```typescript\n   * fa.forEffect(fb) <-> fa.flatMap(a => fb.map(_ => a))\n   * ```\n   */\n  forEffectConsistency<A, B>(fa: HK<F, A>, fb: HK<F, B>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(\n      F.forEffect(fa, fb),\n      F.flatMap(fa, a => F.map(fb, _ => a))\n    )\n  }\n\n  /**\n   * ```typescript\n   * fa.forEffectL(() => fb) <-> fa.flatMap(a => fb.map(_ => a))\n   * ```\n   */\n  forEffectLConsistency<A, B>(fa: HK<F, A>, fb: HK<F, B>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(\n      F.forEffectL(fa, () => fb),\n      F.flatMap(fa, a => F.map(fb, _ => a))\n    )\n  }\n\n  tailRecMConsistentFlatMap<A>(a: A, f: (a: A) => HK<F, A>): Equiv<HK<F, A>> {\n    const F = this.F\n    const bounce = (n: number) => {\n      return F.tailRecM([a, n] as [A, number], x => {\n        const [a0, i] = x\n        return i > 0\n          ? F.map(f(a0), a1 => Left([a1, i - 1] as [A, number]))\n          : F.map(f(a0), Right)\n      })\n    }\n\n    /*\n     * The law is for n >= 1\n     * bounce(n) == bounce(n - 1).flatMap(f)\n     *\n     * Many monads blow up if n gets too large here (for instance List, becomes\n     * multiplicative, so the memory is exponential in n).\n     */\n    return Equiv.of(bounce(1), F.flatMap(bounce(0), f))\n  }\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n  /** Mixed in from {@link ApplyLaws.applyComposition}. */\n  applyComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed in from {@link ApplyLaws.applyProductConsistency}. */\n  applyProductConsistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed in from {@link ApplyLaws.applyMap2Consistency}. */\n  applyMap2Consistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n}\n\napplyMixins(FlatMapLaws, [ApplyLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link FlatMap} instance if it exists, or throws a `NotImplementedError`\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, FlatMap, flatMapOf } from \"funfix\"\n *\n * const F: FlatMap<Option<any>> = flatMapOf(Option)\n * ```\n */\nexport const flatMapOf: <F>(c: Constructor<F>) => FlatMap<F> =\n  getTypeClassInstance(FlatMap)\n\n/**\n * Given an {@link FlatMap} instance, returns the {@link FlatMapLaws}\n * associated with it.\n */\nexport function flatMapLawsOf<F>(instance: FlatMap<F>): FlatMapLaws<F> {\n  return new (class extends FlatMapLaws<F> { public readonly F = instance })()\n}\n\n/**\n * The `Monad` type class.\n *\n * Allows composition of dependent effectful functions.\n *\n * A `Monad` instance is defined by two operations:\n *\n * - `pure` from {@link Applicative}, which lifts an `A` value\n *    in the `F<A>` context\n * - `flatMap`, which allows us to have a value in a context (`F<A>`)\n *    and then feed that into a function that takes a normal value and\n *    returns a value in a context (`A => F<B>`)\n *\n * See [Monads for functional programming]{@link http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf},\n * by Philip Wadler.\n *\n * Must obey the laws defined in {@link MonadLaws}.\n *\n * Note that having an `Applicative` instance implies\n * {@link Functor}, {@link Apply}, {@link Applicative} and {@link FlatMap}\n * implementations are also available, as `Monad` is a subtype\n * of these type classes.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK, Monad, Either,\n *   registerTypeClassInstance,\n *   applyMixins\n * } from \"../src/funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: T) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note they can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxMonad implements Monad<Box<any>> {\n *   pure<A>(a: A): Box<A> { return new Box(a) }\n *\n *   flatMap<A, B>(fa: BoxK<A>, f: (a: A) => BoxK<B>): Box<B> {\n *     return f((fa as Box<A>).value) as Box<B>\n *   }\n *\n *   tailRecM<A, B>(a: A, f: (a: A) => BoxK<Either<A, B>>): Box<B> {\n *     let cursor = a\n *     while (true) {\n *       const box = f(cursor) as Box<Either<A, B>>\n *       const v = box.value\n *       if (v.isRight()) return new Box(v.get())\n *       cursor = v.swap().get()\n *     }\n *   }\n *\n *   // Mixed-in, as these have default implementations\n *   map: <A, B>(fa: BoxK<A>, f: (a: A) => B) => Box<B>\n *   map2: <A, B, Z>(fa: BoxK<A>, fb: BoxK<B>, f: (a: A, b: B) => Z) => Box<Z>\n *   ap: <A, B>(fa: BoxK<A>, ff: BoxK<(a: A) => B>) => Box<B>\n *   product: <A, B> (fa: BoxK<A>, fb: BoxK<B>) => Box<[A, B]>\n *   unit: () => Box<void>\n *   followedBy: <A, B>(fa: BoxK<A>, fb: BoxK<B>) => Box<B>\n *   followedByL: <A, B>(fa: BoxK<A>, fb: () => BoxK<B>) => Box<B>\n *   forEffect: <A, B>(fa: BoxK<A>, fb: BoxK<B>) => Box<A>\n *   forEffectL: <A, B>(fa: BoxK<A>, fb: () => BoxK<B>) => Box<A>\n * }\n *\n * // Call needed in order to implement `map`, `map2`, `product`, etc.\n * // using the default implementations defined by `Monad`, because\n * // we are using `implements` instead of `extends` above and\n * // because in this sample we want the default implementations,\n * // but note that you can always provide your own\n * applyMixins(BoxMonad, [Monad])\n *\n * // Registering global Monad instance for Box, needed in order\n * // for the `functorOf(Box)`, `applyOf(Box)`, `applicativeOf(Box)`,\n * // `flatMapOf(Box)` and `monadOf(Box)` calls to work\n * registerTypeClassInstance(Monad)(Box, new BoxFunctor())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class Monad<F> implements FlatMap<F>, Applicative<F> {\n  /** Inherited from {@link Applicative.pure}. */\n  abstract pure<A>(a: A): HK<F, A>\n\n  /** Inherited from {@link FlatMap.flatMap}. */\n  abstract flatMap<A, B>(fa: HK<F, A>, f: (a: A) => HK<F, B>): HK<F, B>\n\n  /** Inherited from {@link FlatMap.tailRecM}. */\n  abstract tailRecM<A, B>(a: A, f: (a: A) => HK<F, Either<A, B>>): HK<F, B>\n\n  /** Inherited from {@link Apply.ap}. */\n  ap<A, B>(fa: HK<F, A>, ff: HK<F, (a: A) => B>): HK<F, B> {\n    return this.flatMap(fa, a => this.map(ff, f => f(a)))\n  }\n\n  /** Inherited from {@link Functor.map}. */\n  map<A, B>(fa: HK<F, A>, f: (a: A) => B): HK<F, B> {\n    return this.flatMap(fa, a => this.pure(f(a)))\n  }\n\n  /** Inherited from {@link Apply.map2}. */\n  map2<A, B, Z>(fa: HK<F, A>, fb: HK<F, B>, f: (a: A, b: B) => Z): HK<F, Z> {\n    const F = this\n    return F.flatMap(fa, a => F.map(fb, b => f(a, b)))\n  }\n\n  /** Inherited from {@link Apply.product}. */\n  product<A, B>(fa: HK<F, A>, fb: HK<F, B>): HK<F, [A, B]> {\n    const F = this\n    return F.flatMap(fa, a => F.map(fb, b => [a, b] as [A, B]))\n  }\n\n  /** Mixed-in from {@link Applicative.unit}. */\n  unit: () => HK<F, void>\n  /** Mixed-in from {@link FlatMap.followedBy}. */\n  followedBy: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => HK<F, B>\n  /** Mixed-in from {@link FlatMap.followedByL}. */\n  followedByL: <A, B>(fa: HK<F, A>, fb: () => HK<F, B>) => HK<F, B>\n  /** Mixed-in from {@link FlatMap.forEffect}. */\n  forEffect: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => HK<F, A>\n  /** Mixed-in from {@link FlatMap.forEffectL}. */\n  forEffectL: <A, B>(fa: HK<F, A>, fb: () => HK<F, B>) => HK<F, A>\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"monad\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = [\"functor\", \"apply\", \"applicative\", \"flatMap\"]\n  /** @hidden */\n  static readonly _funErasure: Monad<any>\n}\n\napplyMixins(Monad, [Applicative, FlatMap])\n\n/**\n * Type class laws defined for {@link Monad}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class MonadLaws<F> implements ApplicativeLaws<F>, FlatMapLaws<F> {\n  /**\n   * The {@link Monad} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: Monad<F>\n\n  monadLeftIdentity<A, B>(a: A, f: (a: A) => HK<F, B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(F.flatMap(F.pure(a), f), f(a))\n  }\n\n  monadRightIdentity<A, B>(fa: HK<F, A>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(F.flatMap(fa, F.pure), fa)\n  }\n\n  mapFlatMapCoherence<A, B>(fa: HK<F, A>, f: (a: A) => B): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(F.flatMap(fa, a => F.pure(f(a))), F.map(fa, f))\n  }\n\n  tailRecMStackSafety(): Equiv<HK<F, number>> {\n    const F = this.F\n    const n = 10000\n    const res = F.tailRecM(0, i => F.pure(i < n ? Left(i + 1) : Right(i)))\n    return Equiv.of(res, F.pure(n))\n  }\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n\n  /** Mixed-in from {@link ApplyLaws.applyComposition}. */\n  applyComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link ApplyLaws.applyProductConsistency}. */\n  applyProductConsistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplyLaws.applyMap2Consistency}. */\n  applyMap2Consistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n\n  /** Mixed-in from {@link ApplicativeLaws.applyComposition}. */\n  applicativeIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeHomomorphism}. */\n  applicativeHomomorphism: <A, B>(a: A, f: (a: A) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeInterchange}. */\n  applicativeInterchange: <A, B>(a: A, ff: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeMap}. */\n  applicativeMap: <A, B>(fa: HK<F, A>, f: (a: A) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeComposition}. */\n  applicativeComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeUnit}. */\n  applicativeUnit: <A>(a: A) => Equiv<HK<F, A>>\n\n  /** Mixed-in from {@link FlatMapLaws.flatMapAssociativity}. */\n  flatMapAssociativity: <A, B, C>(fa: HK<F, A>, f: (a: A) => HK<F, B>, g: (b: B) => HK<F, C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link FlatMapLaws.flatMapConsistentApply}. */\n  flatMapConsistentApply: <A, B>(fa: HK<F, A>, fab: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link FlatMapLaws.followedByConsistency}. */\n  followedByConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link FlatMapLaws.followedByLConsistency}. */\n  followedByLConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link FlatMapLaws.forEffectConsistency}. */\n  forEffectConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FlatMapLaws.forEffectLConsistency}. */\n  forEffectLConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FlatMapLaws.tailRecMConsistentFlatMap}. */\n  tailRecMConsistentFlatMap: <A>(a: A, f: (a: A) => HK<F, A>) => Equiv<HK<F, A>>\n}\n\napplyMixins(MonadLaws, [ApplicativeLaws, FlatMapLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link Monad} instance if it exists, or throws a `NotImplementedError`\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, Monad, monadOf } from \"funfix\"\n *\n * const F: Monad<Option<any>> = monadOf(Option)\n * ```\n */\nexport const monadOf: <F>(c: Constructor<F>) => Monad<F> =\n  getTypeClassInstance(Monad)\n\n/**\n * Given an {@link Monad} instance, returns the {@link MonadLaws}\n * associated with it.\n */\nexport function monadLawsOf<F>(instance: Monad<F>): MonadLaws<F> {\n  return new (class extends MonadLaws<F> { public readonly F = instance })()\n}\n\n/**\n * The `MonadError` type class is a {@link Applicative} that\n * also allows you to raise and or handle an error value.\n *\n * This type class allows one to abstract over error-handling\n * applicative types.\n *\n * MUST follow the law defined in {@link MonadErrorLaws}.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK,\n *   MonadError,\n *   registerTypeClassInstance,\n *   applyMixins,\n *   Try\n * } from \"funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: Try<T>) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note they can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxMonadError implements MonadError<Box<any>, any> {\n *   pure<A>(a: A): Box<A> { return new Box(Try.success(a)) }\n *\n *   flatMap<A, B>(fa: BoxK<A>, f: (a: A) => BoxK<B>): Box<B> {\n *     throw new NotImplementedError(\"Provide implementation\")\n *   }\n *\n *   tailRecM<A, B>(a: A, f: (a: A) => BoxK<Either<A, B>>): Box<B> {\n *     throw new NotImplementedError(\"Provide implementation\")\n *   }\n *\n *   raise<A>(e: any): HK<Box<any>, A> {\n *     return new Box(Try.failure(e))\n *   }\n *\n *   recoverWith<A>(fa: BoxK<A>, f: (e: any) => BoxK<A>): HK<Box<any>, A> {\n *     return new Box((fa as Box<A>).value.recoverWith(e => (f(e) as Box<A>).value))\n *   }\n *\n *   // Mixed in\n *   map: <A, B>(fa: BoxK<A>, f: (a: A) => B) => Box<B>\n *   map2: <A, B, Z>(fa: BoxK<A>, fb: BoxK<B>, f: (a: A, b: B) => Z) => Box<Z>\n *   ap: <A, B>(fa: BoxK<A>, ff: BoxK<(a: A) => B>) => Box<B>\n *   product: <A, B> (fa: BoxK<A>, fb: BoxK<B>) => Box<[A, B]>\n *   unit: () => Box<void>\n *   followedBy: <A, B>(fa: BoxK<A>, fb: BoxK<B>) => Box<B>\n *   followedByL: <A, B>(fa: BoxK<A>, fb: () => BoxK<B>) => Box<B>\n *   forEffect: <A, B>(fa: BoxK<A>, fb: BoxK<B>) => Box<A>\n *   forEffectL: <A, B>(fa: BoxK<A>, fb: () => BoxK<B>) => Box<A>\n *   recover: <A>(fa: HK<Box<any>, A>, f: (e: any) => A) => HK<Box<any>, A>\n *   attempt: <A>(fa: HK<Box<any>, A>) => HK<Box<any>, Either<any, A>>\n * }\n *\n * // Call needed in order to implement `map`, `map2`, `product`, etc.\n * // using the default implementations defined by `MonadError`,\n * // because we are using `implements` instead of `extends` above and\n * // because in this sample we want the default implementations,\n * // but note that you can always provide your own\n * applyMixins(BoxMonadError, [MonadError])\n *\n * // Registering global MonadError instance for Box, needed in order\n * // for the `functorOf(Box)`, `applyOf(Box)`, `applicativeOf(Box)`\n * // and `monadErrorOf(Box)` calls to work\n * registerTypeClassInstance(MonadError)(Box, new BoxMonadError())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class MonadError<F, E> implements ApplicativeError<F, E>, Monad<F> {\n  /** Inherited from {@link Applicative.pure}. */\n  abstract pure<A>(a: A): HK<F, A>\n\n  /** Inherited from {@link ApplicativeError.raise}. */\n  abstract raise<A>(e: E): HK<F, A>\n\n  /** Inherited from {@link FlatMap.flatMap}. */\n  abstract flatMap<A, B>(fa: HK<F, A>, f: (a: A) => HK<F, B>): HK<F, B>\n\n  /** Inherited from {@link FlatMap.tailRecM}. */\n  abstract tailRecM<A, B>(a: A, f: (a: A) => HK<F, Either<A, B>>): HK<F, B>\n\n  /** Inherited from {@link ApplicativeError.recoverWith}. */\n  abstract recoverWith<A>(fa: HK<F, A>, f: (e: E) => HK<F, A>): HK<F, A>\n\n  /** Mixed-in from {@link ApplicativeError.recover}. */\n  recover: <A>(fa: HK<F, A>, f: (e: E) => A) => HK<F, A>\n  /** Mixed-in from {@link ApplicativeError.attempt}. */\n  attempt: <A>(fa: HK<F, A>) => HK<F, Either<E, A>>\n\n  /** Mixed-in from {@link Applicative.unit}. */\n  unit: () => HK<F, void>\n  /** Mixed-in from {@link Applicative.map}. */\n  map: <A, B>(fa: HK<F, A>, f: (a: A) => B) => HK<F, B>\n  /** Mixed-in from {@link Apply.map2}. */\n  map2: <A, B, Z>(fa: HK<F, A>, fb: HK<F, B>, f: (a: A, b: B) => Z) => HK<F, Z>\n  /** Mixed-in from {@link Apply.product}. */\n  product: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => HK<F, [A, B]>\n  /** Mixed-in from {@link FlatMap.followedBy}. */\n  followedBy: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => HK<F, B>\n  /** Mixed-in from {@link FlatMap.followedByL}. */\n  followedByL: <A, B>(fa: HK<F, A>, fb: () => HK<F, B>) => HK<F, B>\n  /** Mixed-in from {@link FlatMap.forEffect}. */\n  forEffect: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => HK<F, A>\n  /** Mixed-in from {@link FlatMap.forEffectL}. */\n  forEffectL: <A, B>(fa: HK<F, A>, fb: () => HK<F, B>) => HK<F, A>\n  /** Mixed-in from {@link Monad.ap}. */\n  ap: <A, B>(fa: HK<F, A>, ff: HK<F, (a: A) => B>) => HK<F, B>\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"monadError\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] =\n    [\"functor\", \"apply\", \"applicative\", \"monad\", \"applicativeError\"]\n\n  /** @hidden */\n  static readonly _funErasure: MonadError<any, any>\n}\n\napplyMixins(MonadError, [Monad, ApplicativeError])\n\n/**\n * Type class laws defined for {@link MonadError}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class MonadErrorLaws<F, E> implements ApplicativeErrorLaws<F, E>, MonadLaws<F> {\n  /**\n   * The {@link MonadError} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: MonadError<F, E>\n\n  monadErrorLeftZero<A, B>(e: E, f: (a: A) => HK<F, B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(F.flatMap(F.raise<A>(e), f), F.raise<B>(e))\n  }\n\n  /** Mixed-in from {@link ApplicativeErrorLaws.applicativeErrorRecoverWith}. */\n  applicativeErrorRecoverWith: <A>(e: E, f: (e: E) => HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link ApplicativeErrorLaws.applicativeErrorRecover}. */\n  applicativeErrorRecover: <A>(e: E, f: (e: E) => A) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link ApplicativeErrorLaws.recoverWithPure}. */\n  recoverWithPure: <A>(a: A, f: (e: E) => HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link ApplicativeErrorLaws.recoverPure}. */\n  recoverPure: <A>(a: A, f: (e: E) => A) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link ApplicativeErrorLaws.raiseErrorAttempt}. */\n  raiseErrorAttempt: (e: E) => Equiv<HK<F, Either<E, void>>>\n  /** Mixed-in from {@link ApplicativeErrorLaws.pureAttempt}. */\n  pureAttempt: <A>(a: A) => Equiv<HK<F, Either<E, A>>>\n\n  /** Mixed-in from {@link MonadLaws.monadLeftIdentity}. */\n  monadLeftIdentity: <A, B>(a: A, f: (a: A) => HK<F, B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link MonadLaws.monadRightIdentity}. */\n  monadRightIdentity: <A, B>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link MonadLaws.mapFlatMapCoherence}. */\n  mapFlatMapCoherence: <A, B>(fa: HK<F, A>, f: (a: A) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link MonadLaws.tailRecMStackSafety}. */\n  tailRecMStackSafety: () => Equiv<HK<F, number>>\n\n  /** Mixed-in from {@link FlatMapLaws.flatMapAssociativity}. */\n  flatMapAssociativity: <A, B, C>(fa: HK<F, A>, f: (a: A) => HK<F, B>, g: (b: B) => HK<F, C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link FlatMapLaws.flatMapConsistentApply}. */\n  flatMapConsistentApply: <A, B>(fa: HK<F, A>, fab: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link FlatMapLaws.followedByConsistency}. */\n  followedByConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link FlatMapLaws.followedByLConsistency}. */\n  followedByLConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link FlatMapLaws.forEffectConsistency}. */\n  forEffectConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FlatMapLaws.forEffectLConsistency}. */\n  forEffectLConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FlatMapLaws.tailRecMConsistentFlatMap}. */\n  tailRecMConsistentFlatMap: <A>(a: A, f: (a: A) => HK<F, A>) => Equiv<HK<F, A>>\n\n  /** Mixed-in from {@link ApplicativeLaws.applicativeIdentity}. */\n  applicativeIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeHomomorphism}. */\n  applicativeHomomorphism: <A, B>(a: A, f: (a: A) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeInterchange}. */\n  applicativeInterchange: <A, B>(a: A, ff: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeMap}. */\n  applicativeMap: <A, B>(fa: HK<F, A>, f: (a: A) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeComposition}. */\n  applicativeComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeUnit}. */\n  applicativeUnit: <A>(a: A) => Equiv<HK<F, A>>\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n\n  /** Mixed-in from {@link ApplyLaws.applyComposition}. */\n  applyComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link ApplyLaws.applyProductConsistency}. */\n  applyProductConsistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplyLaws.applyMap2Consistency}. */\n  applyMap2Consistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n}\n\napplyMixins(MonadErrorLaws, [MonadLaws, ApplicativeErrorLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link MonadError} instance if it exists, or throws a `NotImplementedError`\n * in case there's no such association.\n *\n * ```typescript\n * import { IO, MonadError, monadErrorOf } from \"funfix\"\n *\n * const F: MonadError<IO<any>> = monadErrorOf(IO)\n * ```\n */\nexport const monadErrorOf: <F, E>(c: Constructor<F>) => MonadError<F, E> =\n  getTypeClassInstance(MonadError)\n\n/**\n * Given an {@link MonadError} instance, returns the\n * {@link MonadErrorLaws} associated with it.\n */\nexport function monadErrorLawsOf<F,E>(instance: MonadError<F,E>): MonadErrorLaws<F,E> {\n  return new (class extends MonadErrorLaws<F,E> { public readonly F = instance })()\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HK, Equiv, Constructor, getTypeClassInstance } from \"./kinds\"\nimport { Functor, FunctorLaws } from \"./functor\"\nimport { applyMixins, id } from \"funfix-core\"\n\n/**\n * The `CoflatMap` type class, a weaker version of {@link Comonad},\n * exposing `coflatMap`, but not `extract`.\n *\n * This type class is exposed in addition to `Comonad` because\n * there are data types for which we can't implement `extract`, but\n * that could still benefit from an `coflatMap` definition.\n *\n * MUST obey the laws defined in {@link CoflatMapLaws}.\n *\n * Note that having a `CoflatMap` instance implies that a\n * {@link Functor} implementation is also available, which is why\n * `CoflatMap` is a subtype of `Functor`.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK, CoflatMap,\n *   registerTypeClassInstance,\n *   applyMixins\n * } from \"funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: T) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note these can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxCoflatMap implements CoflatMap<Box<any>> {\n *   map<A, B>(fa: BoxK<A>, f: (a: A) => B): Box<B> {\n *     const a = (fa as Box<A>).value\n *     return new Box(f(a))\n *   }\n *\n *   coflatMap<A, B>(fa: BoxK<A>, ff: (a: BoxK<A>) => B): BoxK<B> {\n *     return new Box(Success(ff(fa)))\n *   }\n *\n *   coflatten<A>(fa: BoxK<A>): BoxK<BoxK<A>> {\n *     return new Box(Success(fa))\n *   }\n * }\n *\n * // At the moment of writing, this call is not needed, but it is\n * // recommended anyway to future-proof the code ;-)\n * applyMixins(BoxCoflatMap, [CoflatMap])\n *\n * // Registering global CoflatMap instance for Box, needed in order\n * // for the `coflatMapOf(Box)` calls to work\n * registerTypeClassInstance(CoflatMap)(Box, new BoxCoflatMap())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class CoflatMap<F> implements Functor<F> {\n  /**\n   * `coflatMap` is the dual of `flatMap` on {@link FlatMap}.\n   *\n   * It applies a value in a context to a function that takes a\n   * value in a context and returns a normal value.\n   */\n  abstract coflatMap<A, B>(fa: HK<F, A>, ff: (a: HK<F, A>) => B): HK<F, B>\n\n  /**\n   * `coflatten` is the dual of `flatten` on {@link FlatMap}.\n   *\n   * Whereas `flatten` removes a layer of `F`, coflatten adds a\n   * layer of `F`.\n   */\n  abstract coflatten<A>(fa: HK<F, A>): HK<F, HK<F, A>>\n\n  /** Inherited from {@link Functor.map}. */\n  map: <A, B>(fa: HK<F, A>, f: (a: A) => B) => HK<F, B>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"coflatMap\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = [\"functor\"]\n  /** @hidden */\n  static readonly _funErasure: CoflatMap<any>\n}\n\napplyMixins(CoflatMap, [Functor])\n\n/**\n * Type class laws defined for {@link CoflatMap}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of\n * extending it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class CoflatMapLaws<F> implements FunctorLaws<F> {\n  /**\n   * The {@link CoflatMap} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: CoflatMap<F>\n\n  /**\n   * ```\n   *  fa.coflatMap(f).coflatMap(g) <-> fa.coflatMap(x => g(x.coflatMap(f)))\n   * ```\n   */\n  coflatMapAssociativity<A, B, C>(fa: HK<F, A>, f: (a: HK<F, A>) => B, g: (b: HK<F, B>) => C): Equiv<HK<F, C>> {\n    const F = this.F\n    return Equiv.of(\n      F.coflatMap(F.coflatMap(fa, f), g),\n      F.coflatMap(fa, a => g(F.coflatMap(a, f)))\n    )\n  }\n\n  /**\n   * ```\n   * fa.coflatten.coflatten <-> fa.coflatten.map(_.coflatten)\n   * ```\n   */\n  coflattenThroughMap<A>(fa: HK<F, A>): Equiv<HK<F, HK<F, HK<F, A>>>> {\n    const F = this.F\n    return Equiv.of(\n      F.coflatten(F.coflatten(fa)),\n      F.map(F.coflatten(fa), F.coflatten)\n    )\n  }\n\n  /**\n   * ```\n   * fa.coflatMap(f) <-> fa.coflatten.map(f)\n   * ```\n   */\n  coflattenCoherence<A, B>(fa: HK<F, A>, f: (a: HK<F, A>) => B): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.coflatMap(fa, f),\n      F.map(F.coflatten(fa), f)\n    )\n  }\n\n  /**\n   * ```\n   * fa.coflatten <-> fa.coflatMap(identity)\n   * ```\n   */\n  coflatMapIdentity<A>(fa: HK<F, A>): Equiv<HK<F, HK<F, A>>> {\n    const F = this.F\n    return Equiv.of(\n      F.coflatten(fa),\n      F.coflatMap(fa, id)\n    )\n  }\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n}\n\napplyMixins(CoflatMapLaws, [FunctorLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link CoflatMap} instance if it exists, or throws a `NotImplementedError`\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, CoflatMap, coflatMapOf } from \"funfix\"\n *\n * const F: CoflatMap<Option<any>> = coflatMapOf(Option)\n * ```\n */\nexport const coflatMapOf: <F>(c: Constructor<F>) => CoflatMap<F> =\n  getTypeClassInstance(CoflatMap)\n\n/**\n * Given an {@link CoflatMap} instance, returns the {@link CoflatMapLaws}\n * associated with it.\n */\nexport function coflatMapLawsOf<F>(instance: CoflatMap<F>): CoflatMapLaws<F> {\n  return new (class extends CoflatMapLaws<F> { public readonly F = instance })()\n}\n\n/**\n * `Comonad` is the dual of {@link Monad}.\n *\n * Whereas Monads allow for the composition of effectful functions,\n * Comonads allow for composition of functions that extract the\n * value from their context.\n *\n * Example:\n *\n * ```typescript\n * const F = comonadOf(Eval)\n *\n * F.extract(Eval.of(() => 2)) // 2\n * ```\n *\n * Note that having an `Comonad` instance implies {@link Functor} and\n * {@link CoflatMap} implementations are also available, which is why\n * `Comonad` is a subtype of `Functor` and `CoflatMap`.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK, Comonad,\n *   registerTypeClassInstance,\n *   applyMixins\n * } from \"funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: T) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note they can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxComonad implements Comonad<Box<any>> {\n *   map<A, B>(fa: BoxK<A>, f: (a: A) => B): BoxK<B> {\n *     const a = (fa as Box<A>).value\n *     return new Box(f(a))\n *   }\n *\n *   coflatMap<A, B>(fa: BoxK<A>, ff: (a: BoxK<A>) => B): BoxK<B> {\n *     return new Box(ff(fa))\n *   }\n *\n *   coflatten<A>(fa: BoxK<A>): BoxK<BoxK<A>> {\n *     return new Box(fa)\n *   }\n *\n *   extract<A>(fa: BoxK<A>): A {\n *     return (fa as Box<A>).value\n *   }\n * }\n *\n * // At the moment of writing, this call is not needed, but it is\n * // recommended anyway to future-proof the code ;-)\n * applyMixins(BoxComonad, [Comonad])\n *\n * // Registering global Comonad instance for Box, needed in order\n * // for the `functorOf(Box)`, `coflatMapOf(Box)` and `comonadOf(Box)`\n * // calls to work\n * registerTypeClassInstance(Comonad)(Box, new BoxComonad())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class Comonad<F> implements CoflatMap<F> {\n  /**\n   * `extract` is the dual of `pure` on {@link Monad}\n   * (via {@link Applicative}) and extracts the value from\n   * its context.\n   *\n   * Example:\n   *\n   * ```typescript\n   * const cm = comonadOf(Eval)\n   *\n   * cm.extract(Eval.of(() => 10)) //=> 10\n   * ```\n   */\n  abstract extract<A>(fa: HK<F, A>): A\n\n  /** Inherited from {@link Functor.map}. */\n  map: <A, B>(fa: HK<F, A>, f: (a: A) => B) => HK<F, B>\n  /** Inherited from {@link CoflatMap.coflatMap}. */\n  coflatMap: <A, B>(fa: HK<F, A>, ff: (a: HK<F, A>) => B) => HK<F, B>\n  /** Inherited from {@link CoflatMap.coflatten}. */\n  coflatten: <A>(fa: HK<F, A>) => HK<F, HK<F, A>>\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"comonad\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = [\"functor\", \"coflatMap\"]\n  /** @hidden */\n  static readonly _funErasure: Comonad<any>\n}\n\napplyMixins(Comonad, [CoflatMap])\n\n/**\n * Type class laws defined for {@link Comonad}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have `applyMixins` defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class ComonadLaws<F> implements CoflatMapLaws<F> {\n  /**\n   * The {@link Comonad} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: Comonad<F>\n\n  /**\n   * ```\n   * fa.coflatten.extract <-> fa\n   * ```\n   */\n  extractCoflattenIdentity<A>(fa: HK<F, A>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(\n      F.extract(F.coflatten(fa)),\n      fa\n    )\n  }\n\n  /**\n   * ```\n   * fa.coflatten.map(_.extract) <-> fa\n   * ```\n   */\n  mapCoflattenIdentity<A>(fa: HK<F, A>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(\n      F.map(F.coflatten(fa), F.extract),\n      fa\n    )\n  }\n\n  /**\n   * ```\n   * fa.map(f) <-> fa.coflatMap(fa0 => f(fa0.extract))\n   * ```\n   */\n  mapCoflatMapCoherence<A, B>(fa: HK<F, A>, f: (a: A) => B): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.map(fa, f),\n      F.coflatMap(fa, fa0 => f(F.extract(fa0)))\n    )\n  }\n\n  /**\n   * ```\n   * fa.coflatMap(_.extract) <-> fa\n   * ```\n   */\n  comonadLeftIdentity<A>(fa: HK<F, A>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(\n      F.coflatMap(fa, F.extract),\n      fa\n    )\n  }\n\n  /**\n   * ```\n   * fa.coflatMap(f).extract <-> f(fa)\n   * ```\n   */\n  comonadRightIdentity<A, B>(fa: HK<F, A>, f: (a: HK<F, A>) => B): Equiv<B> {\n    const F = this.F\n    return Equiv.of(\n      F.extract(F.coflatMap(fa, f)),\n      f(fa)\n    )\n  }\n\n  /** Mixed-in from {@link CoflatMapLaws.coflatMapAssociativity}. */\n  coflatMapAssociativity: <A, B, C>(fa: HK<F, A>, f: (a: HK<F, A>) => B, g: (b: HK<F, B>) => C) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link CoflatMapLaws.coflattenThroughMap}. */\n  coflattenThroughMap: <A>(fa: HK<F, A>) => Equiv<HK<F, HK<F, HK<F, A>>>>\n  /** Mixed-in from {@link CoflatMapLaws.coflattenCoherence}. */\n  coflattenCoherence: <A, B>(fa: HK<F, A>, f: (a: HK<F, A>) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link CoflatMapLaws.coflatMapIdentity}. */\n  coflatMapIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, HK<F, A>>>\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n}\n\napplyMixins(ComonadLaws, [CoflatMapLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link Comonad} instance if it exists, or throws a `NotImplementedError`\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, Comonad, comonadOf } from \"funfix\"\n *\n * const F: Comonad<Option<any>> = comonadOf(Option)\n * ```\n */\nexport const comonadOf: <F>(c: Constructor<F>) => Comonad<F> =\n  getTypeClassInstance(Comonad)\n\n/**\n * Given an {@link Comonad} instance, returns the {@link ComonadLaws}\n * associated with it.\n */\nexport function comonadLawsOf<F>(instance: Comonad<F>): ComonadLaws<F> {\n  return new (class extends ComonadLaws<F> { public readonly F = instance })()\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Try, Success, Option, Some, Either, Right, applyMixins, Throwable } from \"funfix-core\"\nimport { Eval, IO } from \"funfix-effect\"\nimport { Future } from \"funfix-exec\"\nimport { HK, registerTypeClassInstance } from \"./kinds\"\nimport { Monad, MonadError } from \"./monad\"\nimport { Comonad, CoflatMap } from \"./comonad\"\nimport { Eq } from \"./eq\"\n\n/**\n * Alias used for encoding higher-kinded types when implementing\n * type class instances.\n */\nexport type OptionK<A> = HK<Option<any>, A>\n\n/**\n * Type class instances provided by default for `Option`.\n */\nexport class OptionInstances implements Monad<Option<any>>, Eq<Option<any>>, CoflatMap<Option<any>> {\n  // tslint:disable-next-line:variable-name\n  private __unit: Option<void> = Some(undefined)\n\n  eqv(lh: Option<any>, rh: Option<any>): boolean {\n    if (lh === rh) return true\n    if (lh.isEmpty()) return rh.isEmpty()\n    if (rh.isEmpty()) return false\n    return Eq.testEq(lh.get(), rh.get())\n  }\n\n  pure<A>(a: A): Option<A> {\n    return Some(a)\n  }\n\n  unit(): Option<void> {\n    return this.__unit\n  }\n\n  ap<A, B>(fa: OptionK<A>, ff: OptionK<(a: A) => B>): Option<B> {\n    return Option.map2(fa as Option<A>, ff as Option<(a: A) => B>, (a, f) => f(a))\n  }\n\n  map<A, B>(fa: OptionK<A>, f: (a: A) => B): Option<B> {\n    return (fa as Option<A>).map(f)\n  }\n\n  map2<A, B, Z>(fa: OptionK<A>, fb: OptionK<B>, f: (a: A, b: B) => Z): Option<Z> {\n    return Option.map2(fa as Option<A>, fb as Option<B>, f)\n  }\n\n  product<A, B>(fa: OptionK<A>, fb: OptionK<B>): Option<[A, B]> {\n    return Option.map2(fa as Option<A>, fb as Option<B>, (a, b) => [a, b] as [A, B])\n  }\n\n  flatMap<A, B>(fa: OptionK<A>, f: (a: A) => OptionK<B>): Option<B> {\n    return (fa as any).flatMap(f)\n  }\n\n  tailRecM<A, B>(a: A, f: (a: A) => OptionK<Either<A, B>>): Option<B> {\n    return Option.tailRecM(a, f as any) as any\n  }\n\n  coflatMap<A, B>(fa: OptionK<A>, ff: (a: OptionK<A>) => B): Option<B> {\n    return Some(ff(fa))\n  }\n\n  coflatten<A>(fa: OptionK<A>): Option<Option<A>> {\n    return Some(fa as Option<A>)\n  }\n\n  // Mixed-in\n  followedBy: <A, B>(fa: OptionK<A>, fb: OptionK<B>) => Option<B>\n  followedByL: <A, B>(fa: OptionK<A>, fb: () => OptionK<B>) => Option<B>\n  forEffect: <A, B>(fa: OptionK<A>, fb: OptionK<B>) => Option<A>\n  forEffectL: <A, B>(fa: OptionK<A>, fb: () => OptionK<B>) => Option<A>\n\n  static readonly global: OptionInstances =\n    new OptionInstances()\n}\n\n// Mixins the default implementations\napplyMixins(OptionInstances, [Monad])\n\n// Registering `OptionInstances` as global instances for Option\nregisterTypeClassInstance(Eq)(Option, OptionInstances.global)\nregisterTypeClassInstance(Monad)(Option, OptionInstances.global)\nregisterTypeClassInstance(CoflatMap)(Option, OptionInstances.global)\n\n/**\n * Alias used for encoding higher-kinded types when implementing\n * type class instances.\n */\nexport type TryK<A> = HK<Try<any>, A>\n\n/**\n * Type class instances provided by default for `Option`.\n */\nexport class TryInstances\n  implements MonadError<Try<any>, Throwable>, Eq<Try<any>>, CoflatMap<Try<any>> {\n\n  eqv(lh: Try<any>, rh: Try<any>): boolean {\n    if (lh === rh) return true\n    if (lh.isSuccess()) {\n      if (rh.isFailure()) return false\n      return Eq.testEq(lh.get(), rh.get())\n    } else {\n      if (rh.isSuccess()) return false\n      return Eq.testEq(lh.failed().get(), rh.failed().get())\n    }\n  }\n\n  pure<A>(a: A): Try<A> {\n    return Success(a)\n  }\n\n  unit(): Try<void> {\n    return Try.unit()\n  }\n\n  ap<A, B>(fa: TryK<A>, ff: TryK<(a: A) => B>): Try<B> {\n    return Try.map2(fa as Try<A>, ff as Try<(a: A) => B>, (a, f) => f(a))\n  }\n\n  map<A, B>(fa: TryK<A>, f: (a: A) => B): Try<B> {\n    return (fa as Try<A>).map(f)\n  }\n\n  map2<A, B, Z>(fa: TryK<A>, fb: TryK<B>, f: (a: A, b: B) => Z): Try<Z> {\n    return Try.map2(fa as Try<A>, fb as Try<B>, f)\n  }\n\n  product<A, B>(fa: TryK<A>, fb: TryK<B>): Try<[A, B]> {\n    return Try.map2(fa as Try<A>, fb as Try<B>, (a, b) => [a, b] as [A, B])\n  }\n\n  flatMap<A, B>(fa: TryK<A>, f: (a: A) => TryK<B>): Try<B> {\n    return (fa as any).flatMap(f)\n  }\n\n  tailRecM<A, B>(a: A, f: (a: A) => TryK<Either<A, B>>): Try<B> {\n    return Try.tailRecM(a, f as any) as any\n  }\n\n  raise<A>(e: any): Try<A> {\n    return Try.failure<A>(e)\n  }\n\n  attempt<A>(fa: TryK<A>): Try<Either<Throwable, A>> {\n    return Try.success((fa as Try<A>).fold(\n      e => Either.left<Throwable, A>(e),\n      Either.right\n    ))\n  }\n\n  recoverWith<A>(fa: TryK<A>, f: (e: Throwable) => TryK<A>): Try<A> {\n    return (fa as Try<A>).recoverWith(f as ((e: Throwable) => Try<A>))\n  }\n\n  recover<A>(fa: TryK<A>, f: (e: Throwable) => A): Try<A> {\n    return (fa as Try<A>).recover(f as ((e: Throwable) => A))\n  }\n\n  coflatMap<A, B>(fa: TryK<A>, ff: (a: TryK<A>) => B): Try<B> {\n    return Success(ff(fa))\n  }\n\n  coflatten<A>(fa: TryK<A>): Try<Try<A>> {\n    return Success(fa as Try<A>)\n  }\n\n  // Mixed-in\n  followedBy: <A, B>(fa: TryK<A>, fb: TryK<B>) => Try<B>\n  followedByL: <A, B>(fa: TryK<A>, fb: () => TryK<B>) => Try<B>\n  forEffect: <A, B>(fa: TryK<A>, fb: TryK<B>) => Try<A>\n  forEffectL: <A, B>(fa: TryK<A>, fb: () => TryK<B>) => Try<A>\n\n  static global: TryInstances =\n    new TryInstances()\n}\n\n// Mixins the default implementations\napplyMixins(TryInstances, [MonadError])\n\n// Registering `TryInstances` as global instances for Try\nregisterTypeClassInstance(Eq)(Try, TryInstances.global)\nregisterTypeClassInstance(MonadError)(Try, TryInstances.global)\nregisterTypeClassInstance(CoflatMap)(Try, TryInstances.global)\n\n/**\n * Alias used for encoding higher-kinded types when implementing\n * type class instances.\n */\nexport type EitherK<L, R> = HK<Either<L, any>, R>\n\n/**\n * Type class instances provided by default for `Either`.\n */\nexport class EitherInstances<L>\n  implements Monad<Either<L, any>>, Eq<Either<L, any>>, CoflatMap<Either<L, any>> {\n  // tslint:disable-next-line:variable-name\n  private __unit: Either<L, void> = Right(undefined)\n\n  eqv(lh: Either<L, any>, rh: Either<L, any>): boolean {\n    if (lh === rh) return true\n    if (lh.isRight()) {\n      if (rh.isLeft()) return false\n      return Eq.testEq(lh.get(), rh.get())\n    } else {\n      if (rh.isRight()) return false\n      return Eq.testEq(lh.swap().get(), rh.swap().get())\n    }\n  }\n\n  pure<A>(a: A): Either<L, A> {\n    return Right(a)\n  }\n\n  unit(): Either<L, void> {\n    return this.__unit\n  }\n\n  ap<A, B>(fa: EitherK<L, A>, ff: EitherK<L, (a: A) => B>): Either<L, B> {\n    const faE = (fa as any) as Either<L, A>\n    const ffE = (ff as any) as Either<L, (a: A) => B>\n    return Either.map2(faE, ffE, (a, f) => f(a))\n  }\n\n  map<A, B>(fa: EitherK<L, A>, f: (a: A) => B): Either<L, B> {\n    return ((fa as any) as Either<L, A>).map(f)\n  }\n\n  map2<A, B, Z>(fa: EitherK<L, A>, fb: EitherK<L, B>, f: (a: A, b: B) => Z): Either<L, Z> {\n    return Either.map2((fa as any) as Either<L, A>, (fb as any) as Either<L, B>, f)\n  }\n\n  product<A, B>(fa: EitherK<L, A>, fb: EitherK<L, B>): Either<L, [A, B]> {\n    return Either.map2(\n      (fa as any) as Either<L, A>,\n      (fb as any) as Either<L, B>,\n      (a, b) => [a, b] as [A, B])\n  }\n\n  flatMap<A, B>(fa: HK<Either<L, any>, A>, f: (a: A) => HK<Either<L, any>, B>): HK<Either<L, any>, B> {\n    return (fa as any).flatMap(f)\n  }\n\n  tailRecM<A, B>(a: A, f: (a: A) => HK<Either<L, any>, Either<A, B>>): HK<Either<L, any>, B> {\n    return Either.tailRecM(a, f as any) as any\n  }\n\n  coflatMap<A, B>(fa: EitherK<L, A>, ff: (a: EitherK<L, A>) => B): Either<L, B> {\n    return Right(ff(fa))\n  }\n\n  coflatten<A>(fa: EitherK<L, A>): Either<L, Either<L, A>> {\n    return Right(fa as Either<L, A>)\n  }\n\n  // Mixed-in\n  followedBy: <A, B>(fa: EitherK<L, A>, fb: EitherK<L, B>) => Either<L, B>\n  followedByL: <A, B>(fa: EitherK<L, A>, fb: () => EitherK<L, B>) => Either<L, B>\n  forEffect: <A, B>(fa: EitherK<L, A>, fb: EitherK<L, B>) => Either<L, A>\n  forEffectL: <A, B>(fa: EitherK<L, A>, fb: () => EitherK<L, B>) => Either<L, A>\n\n  static global: EitherInstances<any> =\n    new EitherInstances()\n}\n\n// Mixins the default implementations\napplyMixins(EitherInstances, [Monad])\n// Registering `TryInstances` as global instances for Try\nregisterTypeClassInstance(Eq)(Either, EitherInstances.global)\nregisterTypeClassInstance(Monad)(Either, EitherInstances.global)\nregisterTypeClassInstance(CoflatMap)(Either, EitherInstances.global)\n\n/**\n * Alias used for encoding higher-kinded types when implementing\n * type class instances.\n */\nexport type EvalK<A> = HK<Eval<any>, A>\n\n/**\n * Type class instances provided by default for `Eval`.\n */\nexport class EvalInstances implements Monad<Eval<any>>, Comonad<Eval<any>> {\n  pure<A>(a: A): Eval<A> {\n    return Eval.now(a)\n  }\n\n  flatMap<A, B>(fa: EvalK<A>, f: (a: A) => EvalK<B>): Eval<B> {\n    return (fa as any).flatMap(f)\n  }\n\n  tailRecM<A, B>(a: A, f: (a: A) => EvalK<Either<A, B>>): Eval<B> {\n    return Eval.tailRecM(a, f as any) as any\n  }\n\n  ap<A, B>(fa: EvalK<A>, ff: EvalK<(a: A) => B>): Eval<B> {\n    return (fa as Eval<A>).flatMap(a =>\n      (ff as Eval<(a: A) => B>).map(f => f(a))\n    )\n  }\n\n  map<A, B>(fa: EvalK<A>, f: (a: A) => B): Eval<B> {\n    return (fa as Eval<A>).map(f)\n  }\n\n  unit(): Eval<void> {\n    return Eval.unit()\n  }\n\n  coflatMap<A, B>(fa: EvalK<A>, ff: (a: EvalK<A>) => B): Eval<B> {\n    return Eval.now(ff(fa))\n  }\n\n  coflatten<A>(fa: EvalK<A>): Eval<Eval<A>> {\n    return Eval.now(fa as Eval<A>)\n  }\n\n  extract<A>(fa: EvalK<A>): A {\n    return (fa as Eval<A>).get()\n  }\n\n  // Mixed-in\n  map2: <A, B, Z>(fa: EvalK<A>, fb: EvalK<B>, f: (a: A, b: B) => Z) => Eval<Z>\n  product: <A, B>(fa: EvalK<A>, fb: EvalK<B>) => EvalK<[A, B]>\n  followedBy: <A, B>(fa: EvalK<A>, fb: EvalK<B>) => Eval<B>\n  followedByL: <A, B>(fa: EvalK<A>, fb: () => EvalK<B>) => Eval<B>\n  forEffect: <A, B>(fa: EvalK<A>, fb: EvalK<B>) => Eval<A>\n  forEffectL: <A, B>(fa: EvalK<A>, fb: () => EvalK<B>) => Eval<A>\n\n  static global: EvalInstances =\n    new EvalInstances()\n}\n\n// Mixins the default implementations\napplyMixins(EvalInstances, [Monad, Comonad])\n// Registering `EvalInstances` as global instances for `Eval`\nregisterTypeClassInstance(Monad)(Eval, EvalInstances.global)\nregisterTypeClassInstance(Comonad)(Eval, EvalInstances.global)\n\n/**\n * Alias used for encoding higher-kinded types when implementing\n * type class instances.\n */\nexport type FutureK<A> = HK<Future<any>, A>\n\n/**\n * Type class instances provided by default for `Future`.\n */\nexport class FutureInstances implements MonadError<Future<any>, Throwable>, CoflatMap<Future<any>> {\n  pure<A>(a: A): Future<A> {\n    return Future.pure(a)\n  }\n\n  flatMap<A, B>(fa: FutureK<A>, f: (a: A) => FutureK<B>): Future<B> {\n    return (fa as any).flatMap(f)\n  }\n\n  tailRecM<A, B>(a: A, f: (a: A) => FutureK<Either<A, B>>): Future<B> {\n    return Future.tailRecM(a, f as any) as any\n  }\n\n  ap<A, B>(fa: FutureK<A>, ff: FutureK<(a: A) => B>): Future<B> {\n    return (fa as Future<A>).flatMap(a =>\n      (ff as Future<(a: A) => B>).map(f => f(a))\n    )\n  }\n\n  map<A, B>(fa: FutureK<A>, f: (a: A) => B): Future<B> {\n    return (fa as Future<A>).map(f)\n  }\n\n  unit(): Future<void> {\n    return Future.unit()\n  }\n\n  raise<A>(e: Throwable): Future<A> {\n    return Future.raise(e)\n  }\n\n  attempt<A>(fa: FutureK<A>): Future<Either<Throwable, A>> {\n    return (fa as Future<A>).attempt() as any\n  }\n\n  recoverWith<A>(fa: FutureK<A>, f: (e: Throwable) => FutureK<A>): Future<A> {\n    return (fa as Future<A>).recoverWith(f as ((e: any) => Future<A>))\n  }\n\n  recover<A>(fa: FutureK<A>, f: (e: Throwable) => A): Future<A> {\n    return (fa as Future<A>).recover(f as ((e: any) => A))\n  }\n\n  map2<A, B, Z>(fa: FutureK<A>, fb: FutureK<B>, f: (a: A, b: B) => Z): Future<Z> {\n    return Future.map2(fa as any, fb as any, f as any) as any\n  }\n\n  coflatMap<A, B>(fa: FutureK<A>, ff: (a: FutureK<A>) => B): Future<B> {\n    return Future.pure(ff(fa))\n  }\n\n  coflatten<A>(fa: FutureK<A>): Future<Future<A>> {\n    return Future.pure(fa as Future<A>)\n  }\n\n  // Mixed-in\n  product: <A, B>(fa: FutureK<A>, fb: FutureK<B>) => FutureK<[A, B]>\n  followedBy: <A, B>(fa: FutureK<A>, fb: FutureK<B>) => Future<B>\n  followedByL: <A, B>(fa: FutureK<A>, fb: () => FutureK<B>) => Future<B>\n  forEffect: <A, B>(fa: FutureK<A>, fb: FutureK<B>) => Future<A>\n  forEffectL: <A, B>(fa: FutureK<A>, fb: () => FutureK<B>) => Future<A>\n\n  static global: FutureInstances =\n    new FutureInstances()\n}\n\n// Mixins the default implementations\napplyMixins(FutureInstances, [MonadError, CoflatMap])\n// Registering `FutureInstances` as global instances for `Future`\nregisterTypeClassInstance(MonadError)(Future, FutureInstances.global)\nregisterTypeClassInstance(CoflatMap)(Future, FutureInstances.global)\n\n/**\n * Alias used for encoding higher-kinded types when implementing\n * type class instances.\n */\nexport type IOK<A> = HK<IO<any>, A>\n\n/**\n * Type class instances provided by default for `IO`.\n */\nexport class IOInstances implements MonadError<IO<any>, Throwable>, CoflatMap<IO<any>> {\n  pure<A>(a: A): IO<A> {\n    return IO.pure(a)\n  }\n\n  flatMap<A, B>(fa: IOK<A>, f: (a: A) => IOK<B>): IO<B> {\n    return (fa as any).flatMap(f)\n  }\n\n  tailRecM<A, B>(a: A, f: (a: A) => IOK<Either<A, B>>): IO<B> {\n    return IO.tailRecM(a, f as any) as any\n  }\n\n  ap<A, B>(fa: IOK<A>, ff: IOK<(a: A) => B>): IO<B> {\n    return (fa as IO<A>).flatMap(a =>\n      (ff as IO<(a: A) => B>).map(f => f(a))\n    )\n  }\n\n  map<A, B>(fa: IOK<A>, f: (a: A) => B): IO<B> {\n    return (fa as IO<A>).map(f)\n  }\n\n  unit(): IO<void> {\n    return IO.unit()\n  }\n\n  raise<A>(e: Throwable): IO<A> {\n    return IO.raise(e)\n  }\n\n  attempt<A>(fa: IOK<A>): IO<Either<Throwable, A>> {\n    return (fa as IO<A>).attempt() as any\n  }\n\n  recoverWith<A>(fa: IOK<A>, f: (e: Throwable) => IOK<A>): IO<A> {\n    return (fa as IO<A>).recoverWith(f as ((e: any) => IO<A>))\n  }\n\n  recover<A>(fa: IOK<A>, f: (e: Throwable) => A): IO<A> {\n    return (fa as IO<A>).recover(f as ((e: any) => A))\n  }\n\n  map2<A, B, Z>(fa: IOK<A>, fb: IOK<B>, f: (a: A, b: B) => Z): IO<Z> {\n    return IO.map2(fa as any, fb as any, f as any) as any\n  }\n\n  followedBy<A, B>(fa: IOK<A>, fb: IOK<B>): IO<B> {\n    return (fa as any).followedBy(fb)\n  }\n\n  followedByL<A, B>(fa: IOK<A>, fb: () => IOK<B>): IO<B> {\n    return (fa as any).followedBy(IO.suspend(fb as any))\n  }\n\n  forEffect<A, B>(fa: IOK<A>, fb: IOK<B>): IO<A> {\n    return (fa as any).forEffect(fb)\n  }\n\n  forEffectL<A, B>(fa: IOK<A>, fb: () => IOK<B>): IO<A> {\n    return (fa as any).forEffect(IO.suspend(fb as any))\n  }\n\n  product<A, B>(fa: IOK<A>, fb: IOK<B>): IO<[A, B]> {\n    return IO.map2(fa as any, fb as any, (a, b) => [a, b]) as any\n  }\n\n  coflatMap<A, B>(fa: IOK<A>, ff: (a: IOK<A>) => B): IO<B> {\n    return IO.pure(ff(fa))\n  }\n\n  coflatten<A>(fa: IOK<A>): IO<IO<A>> {\n    return IO.pure(fa as IO<A>)\n  }\n\n  static global: IOInstances =\n    new IOInstances()\n}\n\n// Mixins the default implementations\napplyMixins(IOInstances, [MonadError, CoflatMap])\n// Registering `IOInstances` as global instances for `IO`\nregisterTypeClassInstance(MonadError)(IO, IOInstances.global)\nregisterTypeClassInstance(CoflatMap)(IO, IOInstances.global)\n"],"names":["lh","rh","Equiv","tc","c","instance","obj","types","existing","_funTypeId","name","constructor","IllegalArgumentError","_funSupertypeIds","id","NotImplementedError","is","Eq","eqv","a","F","x","y","z","eqOf","getTypeClassInstance","EqLaws","Functor","fa","of","map","f","g","functorOf","FunctorLaws","fb","ap","b","map2","Apply","applyMixins","fab","fbc","compose","product","p","ApplyLaws","applyOf","pure","undefined","Applicative","ff","unit","ApplicativeLaws","applicativeOf","recoverWith","e","recover","Either","right","Left","ApplicativeError","raise","attempt","Right","ApplicativeErrorLaws","applicativeErrorOf","flatMap","FlatMap","followedBy","followedByL","forEffect","forEffectL","bounce","n","tailRecM","a0","i","a1","FlatMapLaws","flatMapOf","Monad","res","MonadLaws","monadOf","MonadError","MonadErrorLaws","monadErrorOf","CoflatMap","coflatMap","coflatten","CoflatMapLaws","coflatMapOf","Comonad","extract","fa0","ComonadLaws","comonadOf","Some","isEmpty","testEq","get","__unit","Option","OptionInstances","registerTypeClassInstance","global","isSuccess","isFailure","failed","Success","Try","failure","success","fold","left","TryInstances","isRight","isLeft","swap","faE","ffE","EitherInstances","Eval","now","EvalInstances","Future","FutureInstances","IO","suspend","IOInstances"],"mappings":"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"}