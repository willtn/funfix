{"version":3,"file":"es5.js","sources":["../src/cancelable.ts","../src/time.ts","../src/ref.ts","../src/internals.ts","../src/scheduler.ts","../src/future.ts"],"sourcesContent":["/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  CompositeError,\n  IllegalStateError,\n  IllegalArgumentError\n} from \"funfix-core\"\n\n/**\n * `ICancelable` represents a one-time idempotent action that can be\n * used to cancel async computations, or to release resources that\n * active data sources are holding.\n *\n * It is similar in spirit to `java.io.Closeable`, but without the I/O\n * focus, or to `IDisposable` in Microsoft .NET.\n *\n * ```typescript\n * // Scheduling execution with a 10 seconds delay\n * const ref = setTimeout(() => console.log(\"Hello1\"), 10000)\n * const task = Cancelable.of(() => clearTimeout(ref))\n *\n * // If we change our mind\n * task.cancel()\n * ```\n *\n * In case some API requires the return of an `ICancelable` reference,\n * but there isn't anything that can be canceled, then\n * {@link Cancelable.empty} can be used to return a reusable reference\n * that doesn't do anything when canceled.\n *\n * ```typescript\n * const task = Cancelable.empty()\n *\n * // It's a no-op, doesn't do anything\n * task.cancel()\n * ```\n *\n * Implementation sample:\n *\n * ```typescript\n * class MyCancelable implements ICancelable {\n *   // Idempotency guard\n *   private _isCanceled: boolean = false\n *\n *   cancel() {\n *     // We need an idempotency guarantee, any side-effects\n *     // need to happen only once\n *     if (!this._isCanceled) {\n *       this._isCanceled = true\n *       console.log(\"Was canceled!\")\n *     }\n *   }\n * }\n * ```\n */\nexport interface ICancelable {\n  cancel(): void\n}\n\n/**\n * `Cancelable` is an {@link ICancelable} class providing useful\n * builders for simple cancelable references.\n */\nexport abstract class Cancelable implements ICancelable {\n  abstract cancel(): void\n\n  /**\n   * Lifts any callback into a `Cancelable` reference.\n   *\n   * ```typescript\n   * const task = Cancelable.of(() => {\n   *   console.log(\"I was canceled!\")\n   * })\n   *\n   * task.cancel()\n   * //=> I was canceled!\n   * ```\n   *\n   * The returned reference has guaranteed idempotence, so\n   * calling it multiple times will trigger the given\n   * callback only once.\n   */\n  static of(cb: () => void): Cancelable {\n    return new WrapFn(cb)\n  }\n\n  /**\n   * Returns a reusable `Cancelable` reference that doesn't\n   * do anything on `cancel`.\n   */\n  static empty(): Cancelable {\n    return Empty\n  }\n\n  /**\n   * Returns a [[Cancelable]] implementation that represents an\n   * immutable list of [[Cancelable]] references which can be canceled\n   * as a group.\n   *\n   * ```typescript\n   * const list = Cancelable.collection(\n   *   Cancelable.of(() => console.log(\"Cancelled #1\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #2\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #3\"))\n   * )\n   *\n   * list.cancel()\n   * //=> Cancelled #1\n   * //=> Cancelled #2\n   * //=> Cancelled #3\n   * ```\n   *\n   * @param refs is the array of references to cancel when\n   *        cancellation is triggered\n   */\n  static collection(...refs: Array<ICancelable>): Cancelable {\n    return new CollectionCancelable(refs)\n  }\n\n  /**\n   * Utility that cancels a list of cancelable references, delaying\n   * any thrown exceptions until all references have been cancelled.\n   *\n   * In case multiple exceptions are caught, then the thrown exception\n   * is going to be a `CompositeError`.\n   */\n  static cancelAll(refs: Cancelable[]): void {\n    let errors: any[] | null = null\n    for (const c of refs) {\n      try {\n        c.cancel()\n      } catch (e) {\n        if (!errors) errors = [e]\n        else errors.push(e)\n      }\n    }\n\n    if (!errors)\n      return\n    else if (errors.length === 1)\n      throw errors[0]\n    else\n      throw new CompositeError(errors)\n  }\n}\n\n/**\n * Concrete [[Cancelable]] implementation that wraps a callback.\n *\n * Implementation is package private, use {@link Cancelable.of}\n * to instantiate it.\n *\n * @Private\n * @Hidden\n */\nclass WrapFn extends Cancelable {\n  protected thunk: null | (() => void)\n\n  constructor(cb: () => void) {\n    super()\n    this.thunk = cb\n  }\n\n  cancel() {\n    if (this.thunk !== null) {\n      const ref = this.thunk\n      this.thunk = null\n      ref()\n    }\n  }\n}\n\n/**\n * A `DummyCancelable` is for {@link ICancelable} references that\n * don't do anything on `cancel()` and thus can be ignored.\n *\n * The common supertype of {@link Cancelable.empty} and\n * {@link BoolCancelable.alreadyCanceled}.\n */\nexport class DummyCancelable implements ICancelable {\n  protected readonly _funIsDummy = true\n\n  cancel(): void {\n  }\n}\n\n/**\n * Reusable [[Cancelable]] reference that doesn't do anything on\n * cancel.\n *\n * Implementation is package private, to access it use\n * [[Cancelable.empty]].\n *\n * @Hidden\n */\nconst Empty: ICancelable =\n  new DummyCancelable()\n\n/**\n * `IBoolCancelable` represents a {@link ICancelable} that can be queried\n * for the canceled status.\n */\nexport interface IBoolCancelable extends ICancelable {\n  /**\n   * Return `true` in case this cancelable hasn't been canceled,\n   * or `false` otherwise.\n   *\n   * ```typescript\n   * const ref = BoolCancelable.of()\n   *\n   * ref.isCanceled() // false\n   * ref.cancel()\n   * ref.isCanceled() // true\n   * ```\n   */\n  isCanceled(): boolean\n}\n\n/**\n * `BoolCancelable` is an {@link IBoolCancelable} class providing useful\n * builders for cancelable references that can be queried for their\n * canceled status.\n */\nexport abstract class BoolCancelable implements IBoolCancelable {\n  /** Inherited from {@link IBoolCancelable.isCanceled}. */\n  abstract isCanceled(): boolean\n\n  /** Inherited from {@link ICancelable.cancel}. */\n  abstract cancel(): void\n\n  /**\n   * Lifts any callback into a `BoolCancelable` reference.\n   *\n   * ```typescript\n   * const task = BoolCancelable.of(() => {\n   *   console.log(\"I was canceled!\")\n   * })\n   *\n   * task.isCanceled()\n   * //=> false\n   *\n   * task.cancel()\n   * //=> I was canceled!\n   *\n   * task.isCanceled()\n   * //=> true\n   * ```\n   *\n   * The returned reference has guaranteed idempotence, so\n   * calling it multiple times will trigger the given\n   * callback only once.\n   */\n  public static of(cb: () => void): BoolCancelable {\n    return new BoolWrapFn(cb)\n  }\n\n  /**\n   * Returns a [[BoolCancelable]] implementation that doesn't do\n   * anything on `cancel` except for changing the status of `isCanceled`\n   * from `false` to `true`.\n   *\n   * ```typescript\n   * const task = BoolCancelable.empty()\n   *\n   * task.isCanceled()\n   * //=> false\n   *\n   * task.cancel()\n   * task.isCanceled()\n   * //=> true\n   * ```\n   */\n  public static empty(): BoolCancelable {\n    return new BoolEmpty()\n  }\n\n  /**\n   * Returns a [[BoolCancelable]] reference that is already canceled.\n   *\n   * ```typescript\n   * const ref = BoolCancelable.alreadyCanceled()\n   *\n   * ref.isCanceled()\n   * //=> true\n   *\n   * // Doesn't do anything, it's a no-op\n   * ref.cancel()\n   * ```\n   *\n   * The implementation returns the same reusable reference.\n   */\n  public static alreadyCanceled(): BoolCancelable {\n    return AlreadyCanceledRef\n  }\n\n  /**\n   * Returns a [[BoolCancelable]] implementation that represents an\n   * immutable list of [[Cancelable]] references which can be\n   * canceled as a group.\n   *\n   * ```typescript\n   * const list = BoolCancelable.collection(\n   *   Cancelable.of(() => console.log(\"Cancelled #1\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #2\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #3\"))\n   * )\n   *\n   * list.cancel()\n   * //=> Cancelled #1\n   * //=> Cancelled #2\n   * //=> Cancelled #3\n   * ```\n   *\n   * @param refs is the array of references to cancel when\n   *        cancellation is triggered\n   */\n  public static collection(...refs: Array<ICancelable>): BoolCancelable {\n    return new CollectionCancelable(refs)\n  }\n}\n\n/**\n * [[Cancelable]] implementation that represents an immutable list of\n * [[Cancelable]] references which can be canceled as a group.\n *\n * Implementation is package private, to access it use\n * [[Cancelable.collection]].\n *\n * @Hidden\n */\nclass CollectionCancelable extends BoolCancelable {\n  private _refs?: ICancelable[]\n\n  constructor(refs: ICancelable[]) {\n    super()\n    this._refs = refs\n  }\n\n  public isCanceled(): boolean {\n    return !this._refs\n  }\n\n  public cancel(): void {\n    if (this._refs)\n      try {\n        Cancelable.cancelAll(this._refs)\n      } finally {\n        delete this._refs\n      }\n  }\n}\n\n/**\n * Concrete [[BoolCancelable]] implementation that wraps a callback.\n *\n * Implementation is package private, use [[BoolCancelable.of]]\n * to instantiate it.\n *\n * @Hidden\n */\nclass BoolWrapFn extends WrapFn implements BoolCancelable {\n  isCanceled() {\n    return this.thunk === null\n  }\n}\n\n/**\n * Concrete [[BoolCancelable]] implementation that doesn't do\n * anything on `cancel` except for changing the status of `isCanceled`\n * from `false` to `true`.\n *\n * Implementation is package private, use [[BoolCancelable.empty]]\n * to instantiate it.\n *\n * @Hidden\n */\nclass BoolEmpty extends BoolCancelable {\n  private canceled: boolean = false\n\n  isCanceled(): boolean {\n    return this.canceled\n  }\n\n  public cancel(): void {\n    this.canceled = true\n  }\n}\n\n/**\n * Implementation for {@link BoolCancelable.alreadyCanceled}.\n *\n * @Hidden\n */\nclass AlreadyCanceledBoolCancelable\n  extends DummyCancelable implements IBoolCancelable {\n\n  isCanceled() {\n    return true\n  }\n}\n\n/**\n * Reusable [[BoolCancelable]] reference that's already canceled.\n *\n * Implementation is package private, to access it use\n * [[BoolCancelable.alreadyCanceled]].\n *\n * @Hidden\n */\nconst AlreadyCanceledRef: BoolCancelable =\n  new AlreadyCanceledBoolCancelable()\n\n/**\n * Represents a type of [[ICancelable]] that can hold\n * an internal reference to another cancelable (and thus\n * has to support the `update` operation).\n *\n * On assignment, if this cancelable is already\n * canceled, then no assignment should happen and the update\n * reference should be canceled as well.\n */\nexport interface IAssignCancelable extends IBoolCancelable {\n  /**\n   * Updates the internal reference of this assignable cancelable\n   * to the given value.\n   *\n   * If this cancelable is already canceled, then `value` is\n   * going to be canceled on assignment as well.\n   */\n  update(value: ICancelable): this\n}\n\n/**\n * `AssignCancelable` is an {@link IAssignCancelable} class providing\n * useful builders for cancelable references that can be assigned.\n */\nexport abstract class AssignCancelable implements IAssignCancelable {\n  /** Inherited from {@link IAssignCancelable.update}. */\n  abstract update(value: ICancelable): this\n\n  /** Inherited from {@link IBoolCancelable.isCanceled}. */\n  abstract isCanceled(): boolean\n\n  /** Inherited from {@link ICancelable.cancel}. */\n  abstract cancel(): void\n\n  /**\n   * Returns an [[AssignCancelable]] reference that is already\n   * canceled.\n   *\n   * ```typescript\n   * const ref = AssignCancelable.alreadyCanceled()\n   * ref.isCanceled() //=> true\n   *\n   * const c = BooleanCancelable.empty()\n   * ref.update(c) // cancels c\n   * c.isCanceled() // true\n   * ```\n   *\n   * The implementation returns the same reusable reference.\n   */\n  public static alreadyCanceled(): AssignCancelable {\n    return AlreadyCanceledAssignCancelableRef\n  }\n\n  /**\n   * Returns a new [[AssignCancelable]] that's empty.\n   *\n   * The returned reference is an instance of\n   * [[MultiAssignCancelable]], but this is an implementation\n   * detail that may change in the future.\n   */\n  public static empty(): AssignCancelable {\n    return MultiAssignCancelable.empty()\n  }\n\n  /**\n   * Initiates an [[AssignCancelable]] reference and assigns it\n   * a reference that wraps the given `cb` callback.\n   *\n   * So this code:\n   *\n   * ```typescript\n   * AssignCancelable.of(() => console.log(\"cancelled\"))\n   * ```\n   *\n   * Is equivalent to this:\n   *\n   * ```typescript\n   * const ref = AssignCancelable.empty()\n   * ref.update(Cancelable.of(() => console.log(\"cancelled\")))\n   * ```\n   */\n  public static of(cb: () => void): AssignCancelable {\n    return MultiAssignCancelable.of(cb)\n  }\n}\n\n/**\n * Internal reusable class for an {@link IAssignCancelable} that\n * is already cancelled.\n *\n * @Hidden\n */\nclass AlreadyCanceledAssignCancelable\n  extends DummyCancelable implements IAssignCancelable {\n\n  isCanceled() { return true }\n  cancel() {}\n\n  update(value: ICancelable) {\n    value.cancel()\n    return this\n  }\n}\n\n/**\n * Internal reusable reference for an {@link IAssignCancelable} that\n * is already cancelled.\n *\n * @Hidden\n */\nconst AlreadyCanceledAssignCancelableRef: AssignCancelable =\n  new AlreadyCanceledAssignCancelable()\n\n/**\n * The `MultiAssignCancelable` is an {@link IAssignCancelable} whose\n * underlying cancelable reference can be swapped for another.\n *\n * Example:\n *\n * ```typescript\n * const ref = MultiAssignCancelable()\n * ref.update(c1) // sets the underlying cancelable to c1\n * ref.update(c2) // swaps the underlying cancelable to c2\n *\n * ref.cancel() // also cancels c2\n * ref := c3 // also cancels c3, because s is already canceled\n * ```\n *\n * Also see [[SerialCancelable]], which is similar, except that it\n * cancels the old cancelable upon assigning a new cancelable.\n */\nexport class MultiAssignCancelable implements IAssignCancelable {\n  private _underlying?: ICancelable\n  private _canceled: boolean\n\n  constructor(initial?: ICancelable) {\n    this._underlying = initial\n    this._canceled = false\n  }\n\n  /** @inheritdoc */\n  public update(value: ICancelable): this {\n    if (this._canceled) value.cancel()\n    else this._underlying = value\n    return this\n  }\n\n  /** @inheritdoc */\n  public isCanceled(): boolean {\n    return this._canceled\n  }\n\n  /** @inheritdoc */\n  public cancel(): void {\n    if (!this._canceled) {\n      this._canceled = true\n      if (this._underlying) {\n        this._underlying.cancel()\n        delete this._underlying\n      }\n    }\n  }\n\n  /**\n   * In case the underlying reference is also a `MultiAssignCancelable`, then\n   * collapse its state into this one.\n   *\n   * ```typescript\n   * const c = Cancelable.of(() => console.info(\"Cancelled!\"))\n   *\n   * const mc1 = new MultiAssignCancelable()\n   * mc1.update(c)\n   *\n   * const mc2 = new MultiAssignCancelable()\n   * mc2.update(mc1)\n   *\n   * // After this the underlying reference of `mc2` becomes `c`\n   * mc2.collapse()\n   * ```\n   */\n  public collapse(): this {\n    if (this._underlying && this._underlying instanceof MultiAssignCancelable) {\n      const ref = this._underlying\n      this._underlying = ref._underlying\n      this._canceled = ref._canceled\n    }\n    return this\n  }\n\n  /**\n   * Sets the underlying cancelable reference to `undefined`,\n   * useful for garbage-collecting purposes.\n   */\n  public clear(): this {\n    if (!this._canceled) this._underlying = undefined\n    return this\n  }\n\n  /**\n   * Returns a new [[MultiAssignCancelable]] that's empty.\n   */\n  public static empty(): MultiAssignCancelable {\n    return new MultiAssignCancelable()\n  }\n\n  /**\n   * Initiates an [[MultiAssignCancelable]] reference and assigns it\n   * a reference that wraps the given `cb` callback.\n   *\n   * So this code:\n   *\n   * ```typescript\n   * MultiAssignCancelable.of(() => console.log(\"cancelled\"))\n   * ```\n   *\n   * Is equivalent to this:\n   *\n   * ```typescript\n   * const ref = MultiAssignCancelable.empty()\n   * ref.update(Cancelable.of(() => console.log(\"cancelled\")))\n   * ```\n   */\n  public static of(cb: () => void): MultiAssignCancelable {\n    return new MultiAssignCancelable(Cancelable.of(cb))\n  }\n}\n\n/**\n * The `SerialCancelable` is an {@link IAssignCancelable} whose underlying\n * cancelable reference can be swapped for another and on each\n * swap the previous reference gets canceled.\n *\n * Example:\n *\n * ```typescript\n * const ref = SerialCancelable()\n * ref.update(c1) // sets the underlying cancelable to c1\n * ref.update(c2) // cancels c1, swaps the underlying cancelable to c2\n *\n * ref.cancel() // also cancels c2\n * ref := c3 // also cancels c3, because s is already canceled\n * ```\n *\n * Also see [[SerialCancelable]], which is similar, except that it\n * cancels the old cancelable upon assigning a new cancelable.\n */\nexport class SerialCancelable implements IAssignCancelable {\n  private _underlying?: ICancelable\n  private _canceled: boolean\n\n  constructor(initial?: ICancelable) {\n    this._underlying = initial\n    this._canceled = false\n  }\n\n  public update(value: ICancelable): this {\n    if (this._canceled) value.cancel(); else {\n      if (this._underlying) this._underlying.cancel()\n      this._underlying = value\n    }\n    return this\n  }\n\n  public isCanceled(): boolean {\n    return this._canceled\n  }\n\n  public cancel(): void {\n    if (!this._canceled) {\n      this._canceled = true\n      if (this._underlying) {\n        this._underlying.cancel()\n        delete this._underlying\n      }\n    }\n  }\n\n  /**\n   * Returns a new [[SerialCancelable]] that's empty.\n   */\n  public static empty(): SerialCancelable {\n    return new SerialCancelable()\n  }\n\n  /**\n   * Initiates an [[SerialCancelable]] reference and assigns it\n   * a reference that wraps the given `cb` callback.\n   *\n   * So this code:\n   *\n   * ```typescript\n   * SerialCancelable.of(() => console.log(\"cancelled\"))\n   * ```\n   *\n   * Is equivalent to this:\n   *\n   * ```typescript\n   * const ref = SerialCancelable.empty()\n   * ref.update(Cancelable.of(() => console.log(\"cancelled\")))\n   * ```\n   */\n  public static of(cb: () => void): SerialCancelable {\n    return new SerialCancelable(Cancelable.of(cb))\n  }\n}\n\n/**\n * The `SingleAssignCancelable` is a [[Cancelable]] that can be\n * assigned only once to another cancelable reference.\n *\n * Example:\n *\n * ```typescript\n * const ref = SingleAssignCancelable()\n * ref.update(c1) // sets the underlying cancelable to c1\n *\n * ref.update(c2) // throws IllegalStateError\n * ```\n *\n * See [[MultiAssignCancelable]] for a similar type that can be\n * assigned multiple types.\n */\nexport class SingleAssignCancelable implements IAssignCancelable {\n  private _wasAssigned: boolean\n  private _canceled: boolean\n  private _underlying?: ICancelable\n\n  constructor() {\n    this._canceled = false\n    this._wasAssigned = false\n  }\n\n  /** @inheritdoc */\n  public update(value: ICancelable): this {\n    if (this._wasAssigned)\n      throw new IllegalStateError(\"SingleAssignCancelable#update multiple times\")\n\n    this._wasAssigned = true\n    if (this._canceled) value.cancel()\n    else this._underlying = value\n    return this\n  }\n\n  /** @inheritdoc */\n  public isCanceled(): boolean {\n    return this._canceled\n  }\n\n  /** @inheritdoc */\n  public cancel(): void {\n    if (!this._canceled) {\n      this._canceled = true\n      if (this._underlying) {\n        this._underlying.cancel()\n        delete this._underlying\n      }\n    }\n  }\n\n  /**\n   * Returns a new [[SingleAssignCancelable]] that's empty.\n   */\n  public static empty(): SingleAssignCancelable {\n    return new SingleAssignCancelable()\n  }\n\n  /**\n   * Initiates an [[SingleAssignCancelable]] reference and assigns it\n   * a reference that wraps the given `cb` callback.\n   *\n   * So this code:\n   *\n   * ```typescript\n   * SingleAssignCancelable.of(() => console.log(\"cancelled\"))\n   * ```\n   *\n   * Is equivalent to this:\n   *\n   * ```typescript\n   * const ref = SingleAssignCancelable.empty()\n   * ref.update(Cancelable.of(() => console.log(\"cancelled\")))\n   * ```\n   */\n  public static of(cb: () => void): SingleAssignCancelable {\n    const ref = new SingleAssignCancelable()\n    ref.update(Cancelable.of(cb))\n    return ref\n  }\n}\n\n/**\n * Represents a composite of cancelable references that are stacked,\n * so you can push a new reference, or pop an existing one and when\n * it gets canceled, then the whole stack gets canceled.\n *\n * The references are pushed and popped in a FIFO order.\n *\n * Used in the implementation of `Task`.\n *\n * @final\n */\nexport class StackedCancelable implements IBoolCancelable {\n  private _refs?: ICancelable[]\n\n  constructor(initial?: ICancelable[]) {\n    this._refs = initial ? initial.slice(0) : []\n  }\n\n  cancel(): void {\n    if (this._refs)\n      try {\n        Cancelable.cancelAll(this._refs)\n      } finally {\n        delete this._refs\n      }\n  }\n\n  isCanceled(): boolean {\n    return !this._refs\n  }\n\n  /**\n   * Pushes a cancelable reference on the stack, to be popped or\n   * cancelled later in FIFO order.\n   */\n  push(value: ICancelable): this {\n    if (this._refs) {\n      this._refs.push(value)\n    } else {\n      value.cancel()\n    }\n    return this\n  }\n\n  /**\n   * Removes a cancelable reference from the stack in FIFO order.\n   *\n   * @return the cancelable reference that was removed.\n   */\n  pop(): ICancelable {\n    if (!this._refs) return Cancelable.empty()\n    return this._refs.pop() || Cancelable.empty()\n  }\n\n  /**\n   * Returns a new {@link StackedCancelable} that's empty.\n   */\n  static empty(): StackedCancelable {\n    return new StackedCancelable()\n  }\n\n  /**\n   * Returns a {@link StackedCancelable} that's initialized with\n   * the given list of cancelable references.\n   *\n   * ```typescript\n   * const list = StackedCancelable.collection(\n   *   Cancelable.of(() => console.log(\"Cancelled #1\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #2\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #3\"))\n   * )\n   *\n   * // Popping cancelable no. 3 from the stack\n   * list.pop()\n   *\n   * list.cancel()\n   * //=> Cancelled #1\n   * //=> Cancelled #2\n   * ```\n   *\n   * @param refs is the array of references to cancel when\n   *        cancellation is triggered\n   */\n  static collection(...refs: Array<ICancelable>): StackedCancelable {\n    return new StackedCancelable(refs)\n  }\n}\n\n/**\n * Represents an {@link IAssignCancelable} whose underlying\n * cancelable reference can be swapped for another. It can\n * be \"chained\" to another `ChainedCancelable`, forwarding all\n * operations to it.\n *\n * For most purposes it works like a {@link MultiAssignCancelable}:\n *\n * ```typescript\n *   const s = ChainedCancelable.empty()\n *   s.update(c1) // sets the underlying cancelable to c1\n *   s.update(c2) // swaps the underlying cancelable to c2\n *\n *   s.cancel() // also cancels c2\n *   s.update(c3) // also cancels c3, because s is already canceled\n * ```\n *\n * However it can also be linked to another `ChainedCancelable`\n * reference, forwarding all requests to it:\n *\n * ```typescript\n *   const source = ChainedCancelable.empty()\n *   const child1 = ChainedCancelable.empty()\n *   const child2 = ChainedCancelable.empty()\n *\n *   // Hence forth forwards all operations on `child1` to `source`\n *   child1.chainTo(source)\n *\n *   // Also forwarding all `child2` operations to `source`.\n *   // This happens because `child1` was linked to `source` first\n *   // but order matters, as `child2` will be linked directly\n *   // to `source` and not to `child1`, in order for `child1` to\n *   // be garbage collected if it goes out of scope ;-)\n *   child2.chainTo(child1)\n *\n *   // Source will be updated with a new Cancelable ref\n *   child1.update(Cancelable.from(() => println(\"Cancelling (1)\")))\n *\n *   // Source will be updated with another Cancelable ref\n *   child2.update(Cancelable.from(() => println(\"Cancelling (2)\")))\n *\n *   source.cancel()\n *   //=> Cancelling (2)\n * ```\n *\n * This implementation is a special purpose {@link IAssignCancelable},\n * much like {@link StackedCancelable}, to be used in `flatMap`\n * implementations that need it.\n *\n * The problem that it solves in Funfix's codebase is that various\n * `flatMap` implementations need to be memory safe.\n * By \"chaining\" cancelable references, we allow the garbage collector\n * to get rid of references created in a `flatMap` loop, the goal\n * being to consume a constant amount of memory. Thus this\n * implementation is used for the {@link Future} implementation.\n *\n * If unsure about what to use, then you probably don't need\n * {@link ChainedCancelable}. Use {@link MultiAssignCancelable} or\n * {@link SingleAssignCancelable} for most purposes.\n */\nexport class ChainedCancelable implements IAssignCancelable {\n  private _underlying?: ICancelable\n  private _chained: boolean\n\n  constructor(initial?: ICancelable) {\n    // Reference cannot be null, because that signals a cancelled `this`\n    this._underlying = initial || Empty\n    this._chained = false\n  }\n\n  update(value: ICancelable): this {\n    if (!value) throw new IllegalArgumentError(`cannot update to null value`)\n    // A null underlying value signals a canceled `this`\n    if (!this._underlying) {\n      value.cancel()\n      return this\n    }\n    else if (this._chained) {\n      (this._underlying as ChainedCancelable).update(value)\n      return this\n    }\n    else {\n      this._underlying = value\n      return this\n    }\n  }\n\n  cancel(): void {\n    if (this._underlying) {\n      this._underlying.cancel()\n      this._chained = false\n      delete this._underlying\n    }\n  }\n\n  /**\n   * Clears the underlying reference, resetting it to a dummy\n   * reference.\n   *\n   * To be used for garbage collecting purposes.\n   */\n  clear(): void {\n    if (this._underlying) {\n      this._underlying = Empty\n      this._chained = false\n    }\n  }\n\n  isCanceled(): boolean {\n    return !this._underlying || (\n      this._chained && (this._underlying as ChainedCancelable).isCanceled())\n  }\n\n  /**\n   * Chains this `ChainedCancelable` to another reference,\n   * such that all operations are forwarded to `other`.\n   *\n   * ```typescript\n   * const source = ChainedCancelable.empty()\n   * const child1 = ChainedCancelable.empty()\n   * const child2 = ChainedCancelable.empty()\n   *\n   * // Hence forth forwards all operations on `child1` to `source`\n   * child1.chainTo(source)\n   *\n   * // Also forwarding all `child2` operations to `source`\n   * // (this happens because `child1` was linked to `source` first\n   * // but order matters ;-))\n   * child2.chainTo(child1)\n   *\n   * // Source will be updated with a new Cancelable ref\n   * child1.update( Cancelable.of(() => console.log(\"Cancelling (1)\")) )\n   *\n   * // Source will be updated with another Cancelable ref\n   * child2.update( Cancelable.of (() => console.log(\"Cancelling (2)\")) )\n   *\n   * source.cancel()\n   * //=> Cancelling (2)\n   * ```\n   */\n  chainTo(other: ChainedCancelable): this {\n    if (!other) throw new IllegalArgumentError(`cannot chain to null value`)\n    // Short-circuit in case we have the same reference\n    if (other === this) return this\n\n    if (!this._underlying) {\n      other.cancel()\n      return this\n    }\n\n    // Getting the last ChainedCancelable reference in the\n    // chain, since that's the reference that we care about!\n    let ref: ChainedCancelable | undefined = other\n    let keepSearching = true\n\n    while (ref && keepSearching) {\n      if (ref._chained) {\n        const ref2: ICancelable | undefined = ref._underlying\n        // Interrupt infinite loop if we see the same reference\n        if (ref2 === this) return this\n        ref = ref2 as ChainedCancelable\n        keepSearching = !!ref2\n      } else {\n        if (!ref._underlying) ref = undefined\n        keepSearching = false\n      }\n    }\n\n    // A null or undefined reference means that `other` is already\n    // cancelled, therefore we are cancelling `this` as well\n    if (!ref) {\n      this.cancel()\n    } else {\n      const prev = this._underlying\n      this._underlying = ref\n      this._chained = true\n\n      if (!(prev instanceof DummyCancelable))\n        ref.update(prev)\n    }\n    return this\n  }\n\n  /**\n   * Returns a new, empty [[ChainedCancelable]].\n   */\n  public static empty(): ChainedCancelable {\n    return new ChainedCancelable()\n  }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IEquals, IllegalArgumentError } from \"funfix-core\"\n\n/**\n * A `TimeUnit` represents time durations at a given unit of\n * granularity and provides utility methods to convert across units,\n * and to perform timing and delay operations in these units.\n *\n * A `TimeUnit` does not maintain time information, but only helps\n * organize and use time representations that may be maintained\n * separately across various contexts. A nanosecond is defined as one\n * thousandth of a microsecond, a microsecond as one thousandth of a\n * millisecond, a millisecond as one thousandth of a second, a minute\n * as sixty seconds, an hour as sixty minutes, and a day as twenty\n * four hours.\n *\n * `TimeUnit` is an enumeration and in usage the already defined\n * constants should be used:\n *\n *  - [[NANOSECONDS]]\n *  - [[MICROSECONDS]]\n *  - [[MILLISECONDS]]\n *  - [[SECONDS]]\n *  - [[MINUTES]]\n *  - [[HOURS]]\n *  - [[DAYS]]\n *\n * Example:\n *\n * ```typescript\n * // Converting 10 minutes to nanoseconds\n * MINUTES.toNanos(10)\n * // Equivalent with the above:\n * NANOSECONDS.convert(10, MINUTES)\n * ```\n */\nexport abstract class TimeUnit {\n  /**\n   * Converts the given time duration in the given unit to this unit.\n   * Conversions from finer to coarser granularities truncate, so lose\n   * precision. For example, converting `999` milliseconds to seconds\n   * results in `0`. Conversions from coarser to finer granularities\n   * with arguments that would numerically overflow saturate to\n   * `Number.MAX_VALUE` if negative or `MAX_VALUE` if positive.\n   *\n   * For example, to convert 10 minutes to milliseconds, use:\n   *\n   * ```typescript\n   * MILLISECONDS.convert(10, MINUTES)\n   * // ... or ...\n   * MINUTES.toMillis(10)\n   * ```\n   *\n   * @param duration the time duration in the given `unit`\n   * @param unit the unit of the `duration` argument\n   *\n   * @return the converted duration in this unit, or `Number.MIN_VALUE`\n   * if conversion would negatively overflow, or `Number.MAX_VALUE`\n   * if it would positively overflow\n   */\n  abstract convert(duration: number, unit: TimeUnit): number\n\n  /**\n   * Converts the given `d` value to nanoseconds.\n   *\n   * Equivalent with `NANOSECONDS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toNanos(d: number): number\n\n  /**\n   * Converts the given `d` value to microseconds.\n   *\n   * Equivalent with `MICROSECONDS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toMicros(d: number): number\n\n  /**\n   * Converts the given `d` value to milliseconds.\n   *\n   * Equivalent with `MILLISECONDS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toMillis(d: number): number\n\n  /**\n   * Converts the given `d` value to seconds.\n   *\n   * Equivalent with `SECONDS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toSeconds(d: number): number\n\n  /**\n   * Converts the given `d` value to minutes.\n   *\n   * Equivalent with `MINUTES.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toMinutes(d: number): number\n\n  /**\n   * Converts the given `d` value to hours.\n   *\n   * Equivalent with `HOURS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toHours(d: number): number\n\n  /**\n   * Converts the given `d` value to days.\n   *\n   * Equivalent with `DAYS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toDays(d: number): number\n\n  /**\n   * A number representing the unit's ordering in the `TimeUnit`\n   * enumeration, useful for doing comparisons to find out which unit\n   * is more coarse grained.\n   *\n   * ```typescript\n   * MINUTES.ord < DAYS.ord // true\n   * SECONDS.ord > MICROSECONDS.org // true\n   * ```\n   */\n  abstract ord: number\n\n  /**\n   * A human readable label for this unit.\n   */\n  abstract label: string\n\n  /** Override for `Object.toString`. */\n  toString(): string {\n    return this.label.toUpperCase()\n  }\n}\n\n/** @hidden */ const C0 = 1\n/** @hidden */ const C1 = C0 * 1000\n/** @hidden */ const C2 = C1 * 1000\n/** @hidden */ const C3 = C2 * 1000\n/** @hidden */ const C4 = C3 * 60\n/** @hidden */ const C5 = C4 * 60\n/** @hidden */ const C6 = C5 * 24\n\n/** @hidden */ const MIN = -9007199254740992\n/** @hidden */ const MAX = 9007199254740992\n\n/** @hidden */\nconst trunc: (x: number) => number = Math.trunc ||\n  /* istanbul ignore next */\n  function (x) {\n    if (isNaN(x)) return NaN\n    if (x > 0) return Math.floor(x)\n    return Math.ceil(x)\n  }\n\n/** @hidden */\nfunction x(d: number, m: number, over: number): number {\n  if (d > over) return MAX\n  if (d < -over) return MIN\n  return d * m\n}\n\n/** @hidden */\nclass Nanoseconds extends TimeUnit {\n  ord: number = 0\n  label = \"nanoseconds\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toNanos(duration) }\n  toNanos(d: number): number { return d }\n  toMicros(d: number): number { return trunc(d / (C1 / C0)) }\n  toMillis(d: number): number { return trunc(d / (C2 / C0)) }\n  toSeconds(d: number): number { return trunc(d / (C3 / C0)) }\n  toMinutes(d: number): number { return trunc(d / (C4 / C0)) }\n  toHours(d: number): number { return trunc(d / (C5 / C0)) }\n  toDays(d: number): number { return trunc(d / (C6 / C0)) }\n}\n\n /**\n  * Time unit for representing nanoseconds, where 1 nanosecond is\n  * one thousandth of a microsecond.\n  */\nexport const NANOSECONDS: TimeUnit =\n  new Nanoseconds()\n\n/** @hidden */\nclass Microseconds extends TimeUnit {\n  ord: number = 1\n  label = \"microseconds\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toMicros(duration) }\n  toNanos(d: number): number { return x(d, C1 / C0, trunc(MAX / (C1 / C0))) }\n  toMicros(d: number): number { return d }\n  toMillis(d: number): number { return trunc(d / (C2 / C1)) }\n  toSeconds(d: number): number { return trunc(d / (C3 / C1)) }\n  toMinutes(d: number): number { return trunc(d / (C4 / C1)) }\n  toHours(d: number): number { return trunc(d / (C5 / C1)) }\n  toDays(d: number): number { return trunc(d / (C6 / C1)) }\n}\n\n /**\n  * Time unit for representing microseconds, where 1 microsecond is\n  * one thousandth of a millisecond.\n  */\nexport const MICROSECONDS: TimeUnit =\n  new Microseconds()\n\n/** @hidden */\nclass Milliseconds extends TimeUnit {\n  ord: number = 2\n  label = \"milliseconds\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toMillis(duration) }\n  toNanos(d: number): number { return x(d, C2 / C0, trunc(MAX / (C2 / C0))) }\n  toMicros(d: number): number { return x(d, C2 / C1, trunc(MAX / (C2 / C1))) }\n  toMillis(d: number): number { return d }\n  toSeconds(d: number): number { return trunc(d / (C3 / C2)) }\n  toMinutes(d: number): number { return trunc(d / (C4 / C2)) }\n  toHours(d: number): number { return trunc(d / (C5 / C2)) }\n  toDays(d: number): number { return trunc(d / (C6 / C2)) }\n}\n\n /**\n  * Time unit for representing milliseconds, where 1 millisecond is\n  * one thousandth of a second.\n  */\nexport const MILLISECONDS: TimeUnit =\n  new Milliseconds()\n\n/** @hidden */\nclass Seconds extends TimeUnit {\n  ord: number = 3\n  label = \"seconds\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toSeconds(duration) }\n  toNanos(d: number): number { return x(d, C3 / C0, trunc(MAX / (C3 / C0))) }\n  toMicros(d: number): number { return x(d, C3 / C1, trunc(MAX / (C3 / C1))) }\n  toMillis(d: number): number { return x(d, C3 / C2, trunc(MAX / (C3 / C2))) }\n  toSeconds(d: number): number { return d }\n  toMinutes(d: number): number { return trunc(d / (C4 / C3)) }\n  toHours(d: number): number { return trunc(d / (C5 / C3)) }\n  toDays(d: number): number { return trunc(d / (C6 / C3)) }\n}\n\n /**\n  * Time unit for representing seconds.\n  */\nexport const SECONDS: TimeUnit =\n  new Seconds()\n\n/** @hidden */\nclass Minutes extends TimeUnit {\n  ord: number = 4\n  label = \"minutes\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toMinutes(duration) }\n  toNanos(d: number): number { return x(d, C4 / C0, trunc(MAX / (C4 / C0))) }\n  toMicros(d: number): number { return x(d, C4 / C1, trunc(MAX / (C4 / C1))) }\n  toMillis(d: number): number { return x(d, C4 / C2, trunc(MAX / (C4 / C2))) }\n  toSeconds(d: number): number { return x(d, C4 / C3, trunc(MAX / (C4 / C3))) }\n  toMinutes(d: number): number { return d }\n  toHours(d: number): number { return trunc(d / (C5 / C4)) }\n  toDays(d: number): number { return trunc(d / (C6 / C4)) }\n}\n\n /**\n  * Time unit for representing minutes.\n  */\nexport const MINUTES: TimeUnit =\n  new Minutes()\n\n/** @hidden */\nclass Hours extends TimeUnit {\n  ord: number = 5\n  label = \"hours\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toHours(duration) }\n  toNanos(d: number): number { return x(d, C5 / C0, trunc(MAX / (C5 / C0))) }\n  toMicros(d: number): number { return x(d, C5 / C1, trunc(MAX / (C5 / C1))) }\n  toMillis(d: number): number { return x(d, C5 / C2, trunc(MAX / (C5 / C2))) }\n  toSeconds(d: number): number { return x(d, C5 / C3, trunc(MAX / (C5 / C3))) }\n  toMinutes(d: number): number { return x(d, C5 / C4, trunc(MAX / (C5 / C4))) }\n  toHours(d: number): number { return d }\n  toDays(d: number): number { return trunc(d / (C6 / C5)) }\n}\n\n /**\n  * Time unit for representing hours.\n  */\nexport const HOURS: TimeUnit =\n  new Hours()\n\n/** @hidden */\nclass Days extends TimeUnit {\n  ord: number = 6\n  label = \"days\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toDays(duration) }\n  toNanos(d: number): number { return x(d, C6 / C0, trunc(MAX / (C6 / C0))) }\n  toMicros(d: number): number { return x(d, C6 / C1, trunc(MAX / (C6 / C1))) }\n  toMillis(d: number): number { return x(d, C6 / C2, trunc(MAX / (C6 / C2))) }\n  toSeconds(d: number): number { return x(d, C6 / C3, trunc(MAX / (C6 / C3))) }\n  toMinutes(d: number): number { return x(d, C6 / C4, trunc(MAX / (C6 / C4))) }\n  toHours(d: number): number { return x(d, C6 / C5, trunc(MAX / (C6 / C5))) }\n  toDays(d: number): number { return d }\n}\n\n /**\n  * Time unit for representing days.\n  */\nexport const DAYS: TimeUnit =\n  new Days()\n\n/**\n * A simple representation for time durations, based on [[TimeUnit]].\n */\nexport class Duration implements IEquals<Duration> {\n  public duration: number\n  public unit: TimeUnit\n\n  constructor(duration: number, unit: TimeUnit) {\n    if (isNaN(duration)) {\n      throw new IllegalArgumentError(\"NaN is not supported for a Duration\")\n    }\n    // Only integers allowed\n    this.duration = trunc(duration)\n    this.unit = unit\n  }\n\n  /**\n   * This method returns `true` if this duration is finite,\n   * or `false otherwise.\n   */\n  isFinite(): boolean { return isFinite(this.duration) }\n\n  /**\n   * Calculates the nanoseconds described by the source [[Duration]].\n   */\n  toNanos(): number {\n    return NANOSECONDS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the microseconds described by the source [[Duration]].\n   */\n  toMicros(): number {\n    return MICROSECONDS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the milliseconds described by the source [[Duration]].\n   */\n  toMillis(): number {\n    return MILLISECONDS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the seconds described by the source [[Duration]].\n   */\n  toSeconds(): number {\n    return SECONDS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the minutes described by the source [[Duration]].\n   */\n  toMinutes(): number {\n    return MINUTES.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the hours described by the source [[Duration]].\n   */\n  toHours(): number {\n    return HOURS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the days described by the source [[Duration]].\n   */\n  toDays(): number {\n    return DAYS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Returns a new `Duration` value that represents `this` converted\n   * to use the given `unit`.\n   *\n   * Note that this may be a lossy conversion, e.g. when converting\n   * 27 hours to 1 day, there's a loss of fidelity.\n   */\n  convertTo(unit: TimeUnit): Duration {\n    return new Duration(unit.convert(this.duration, this.unit), unit)\n  }\n\n  /**\n   * Negates `this` duration, by changing the sign.\n   */\n  negate(): Duration {\n    switch (this.duration) {\n      case Infinity: return Duration.negInf()\n      case -Infinity: return Duration.inf()\n      default:\n        return new Duration(-this.duration, this.unit)\n    }\n  }\n\n  /**\n   * Return the sum of `this` duration and `other`.\n   *\n   * Note that the `unit` used for the result will be the\n   * more finer grained one out of the two.\n   *\n   * ```typescript\n   * // Result will be 27 hours\n   * Duration.days(1).plus(Duration.hours(3))\n   * ```\n   */\n  plus(other: Duration): Duration {\n    if (!isFinite(this.duration)) {\n      if (!isFinite(other.duration) && this.duration !== other.duration) {\n        throw new IllegalArgumentError(\n          \"cannot deal with two infinities with different signs, \" +\n          \"as that would be a NaN\")\n      }\n      return this\n    } else if (other.duration === 0) {\n      return this\n    } else if (this.duration === 0) {\n      return other\n    }\n\n    if (!isFinite(other.duration)) return other\n\n    let d1: Duration = this\n    let d2: Duration = other\n    if (d2.unit.ord < d1.unit.ord) { d1 = other; d2 = this }\n\n    d2 = d2.convertTo(d1.unit)\n    return new Duration(d1.duration + d2.duration, d1.unit)\n  }\n\n  /**\n   * Subtracts the `other` duration from `this`.\n   *\n   * Note that the `unit` used for the result will be the\n   * more finer grained one out of the two:\n   *\n   * ```typescript\n   * // Result will be 21 hours\n   * Duration.days(1).minus(Duration.hours(3))\n   * ```\n   */\n  minus(other: Duration): Duration {\n    return this.plus(other.negate())\n  }\n\n  /** @inheritdoc */\n  equals(other: Duration): boolean {\n    function cmp(s: Duration, o: Duration) {\n      const n = s.unit.convert(o.duration, o.unit)\n      return n === s.duration\n    }\n\n    if (!isFinite(this.duration)) {\n      return !isFinite(other.duration) &&\n        this.duration === other.duration\n    }\n    return this.unit.ord <= other.unit.ord\n      ? cmp(this, other) : cmp(other, this)\n  }\n\n  /** @inheritdoc */\n  hashCode(): number {\n    if (this.isFinite()) {\n      return this.toNanos()\n    } else if (this.duration === Infinity) {\n      return 7540833725118015\n    } else {\n      return 422082410550358\n    }\n  }\n\n  toString(): string {\n    if (this.isFinite())\n      return `${this.duration} ${this.unit.label}`\n    else if (this.duration >= 0)\n      return \"[end of time]\"\n    else\n      return \"[beginning of time]\"\n  }\n\n  /**\n   * Wraps the argument in a `Duration.millis` reference, in case it's\n   * a number, otherwise returns the argument as is.\n   *\n   * In Javascript code it is customary to express durations with\n   * numbers representing milliseconds and in functions it's good\n   * to still allow developers to do that because it's the standard\n   * convention.\n   *\n   * Thus one can work with a union type like `number | Duration`.\n   * And in case a `number` is given, then it is interpreted as\n   * milliseconds.\n   *\n   * Usage:\n   *\n   * ```typescript\n   * function delay(d: number | Duration, r: () => {}) {\n   *   const millis = Duration.of(d).toMillis()\n   *   return setTimeout(r, millis)\n   * }\n   * ```\n   */\n  static of(value: number | Duration): Duration {\n    return typeof value === \"number\"\n      ? Duration.millis(value)\n      : value\n  }\n\n  /** Returns a zero length duration. */\n  static zero(): Duration {\n    return new Duration(0, DAYS)\n  }\n\n  /** Returns a [[Duration]] representing positive infinite. */\n  static inf(): Duration {\n    return new Duration(Infinity, DAYS)\n  }\n\n  /** Returns a [[Duration]] representing negative infinite. */\n  static negInf(): Duration {\n    return new Duration(-Infinity, DAYS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * nanoseconds.\n   */\n  static nanos(d: number): Duration {\n    return new Duration(d, NANOSECONDS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * microseconds.\n   */\n  static micros(d: number): Duration {\n    return new Duration(d, MICROSECONDS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * milliseconds.\n   */\n  static millis(d: number): Duration {\n    return new Duration(d, MILLISECONDS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * seconds.\n   */\n  static seconds(d: number): Duration {\n    return new Duration(d, SECONDS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * minutes.\n   */\n  static minutes(d: number): Duration {\n    return new Duration(d, MINUTES)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * hours.\n   */\n  static hours(d: number): Duration {\n    return new Duration(d, HOURS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * days.\n   */\n  static days(d: number): Duration {\n    return new Duration(d, DAYS)\n  }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * `DynamicRef` provides a binding mechanism where the current value is\n * found through dynamic scope, but where access to the variable itself is\n * resolved through static scope.\n *\n * The current value can be retrieved with the {@link DynamicRef.get} method.\n * New values should be pushed using the {@link DynamicRef.bind} method.\n *\n * Values pushed via `bind` only stay valid while its second argument,\n * a parameterless function (the `thunk`), executes. When that thunk finishes\n * execution, the reference reverts to the previous value.\n *\n * See {@link DynamicRef.bind} for a usage sample.\n *\n * @final\n */\nexport class DynamicRef<A> {\n  /** Previous states of the ref, to use in `revert`. */\n  private _previous: (() => A)[] = []\n\n  /** Returns the current value of this `DynamicRef`. */\n  get: () => A\n\n  private constructor(fn: () => A) {\n    this.get = fn\n  }\n\n  /**\n   * Updates the underlying of this `DynamicRef` to the given `value`.\n   *\n   * Note that the previous state can be reverted with\n   * [revert]{@link DynamicRef.revert}:\n   *\n   * ```typescript\n   * const ref = DynamicRef.of(() => \"initial\")\n   *\n   * ref.set(\"another\")\n   * ref.get() // another\n   *\n   * ref.revert()\n   * ref.get() // initial\n   * ```\n   */\n  set(value: A): void {\n    return this.setL(() => value)\n  }\n\n  /**\n   * Updates the underlying of this `DynamicRef` to values generated by the\n   * given `thunk`.\n   *\n   * Note that the previous state can be reverted with\n   * [revert]{@link DynamicRef.revert}:\n   *\n   * ```typescript\n   * const ref = DynamicRef.of(() => \"initial\")\n   *\n   * ref.setL(() => \"another\")\n   * ref.get() // another\n   *\n   * ref.revert()\n   * ref.get() // initial\n   * ```\n   */\n  setL(thunk: () => A): void {\n    this._previous.push(this.get)\n    this.get = thunk\n  }\n\n  /**\n   * Reverts this `DynamicRef` to a previous state, if a previous\n   * state is available due to calling [set]{@link DynamicRef.set} or\n   * [setL]{@link DynamicRef.setL}.\n   *\n   * ```typescript\n   * const ref = DynamicRef.of(() => \"initial\")\n   *\n   * ref.set(\"state 2\")\n   * ref.set(\"state 3\")\n   * ref.get() // Yields: state 3\n   *\n   * ref.revert()\n   * ref.get() // Yields: state 2\n   *\n   * ref.revert()\n   * ref.get() // Yields: initial\n   *\n   * ref.revert() // No-op\n   * ref.get() // Yields: initial\n   * ```\n   */\n  revert(): void {\n    const thunk = this._previous.pop()\n    if (thunk) this.get = thunk\n  }\n\n  /**\n   * Binds this `DynamicRef` to a different (strict) `value` that's going to be\n   * visible while executing `thunk` and then it will get reverted to\n   * its previous value.\n   *\n   * Sample:\n   *\n   * ```typescript\n   * const ref = DynamicRef.of(() => \"original\")\n   *\n   * ref.get() // original\n   *\n   * ref.bind(\"modified\", () => {\n   *   ref.get() // modified\n   * })\n   *\n   * ref.get() // original\n   * ```\n   *\n   * @see [bindL]{@link DynamicRef.bindL} for binding a non-strict value instead.\n   *\n   * @param value is the value to bind to this reference within `thunk`'s execution\n   * @param thunk is a parameterless function to execute\n   *\n   * @return the result of executing `thunk`\n   */\n  bind<R>(value: A, thunk: () => R): R {\n    return this.bindL(() => value, thunk)\n  }\n\n  /**\n   * Binds this `DynamicRef` to a different (non-strict) `value` that's going\n   * to be visible while executing `thunk` and then it will get reverted to\n   * its previous value.\n   *\n   * Sample:\n   *\n   * ```typescript\n   * const ref = DynamicRef.of(() => \"original\")\n   *\n   * ref.get() // original\n   *\n   * ref.bindL(() => \"modified\", () => {\n   *   ref.get() // modified\n   * })\n   *\n   * ref.get() // original\n   * ```\n   *\n   * @see [bind]{@link DynamicRef.bindL} for binding a strict value instead.\n   *\n   * @param value is the value generator to bind to this reference within `thunk`'s execution\n   * @param thunk is a parameterless function to execute\n   *\n   * @return the result of executing `thunk`\n   */\n  bindL<R>(value: () => A, thunk: () => R): R {\n    const oldFn = this.get\n    const oldPrev = this._previous.slice(0)\n    const ta = this as any\n    try {\n      ta.get = value\n      return thunk()\n    } finally {\n      ta.get = oldFn\n      ta._previous = oldPrev\n    }\n  }\n\n  /**\n   * Builds a {@link DynamicRef}, where the given parameterless function\n   * is going to be the generator for the default value of the returned\n   *\n   *\n   */\n  static of<A>(fn: () => A): DynamicRef<A> {\n    return new DynamicRef(fn)\n  }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IllegalArgumentError } from \"funfix-core\"\n\n/**\n * Given a sorted array, searches for an insert position for a given search\n * element such that, if inserted in the array at the returned position,\n * the array would remain sorted.\n *\n * @Hidden\n */\nexport function arrayBSearchInsertPos<A>(array: Array<A>, f: (a: A) => number):\n  ((search: number) => number) {\n\n  return search => {\n    let minIndex = 0\n    let maxIndex = array.length - 1\n\n    while (minIndex <= maxIndex) {\n      const index = (minIndex + maxIndex) / 2 | 0\n      const current = f(array[index])\n      const next = index + 1 <= maxIndex ? f(array[index + 1]) : undefined\n\n      if (current <= search && (next === undefined || search < next)) {\n        return index + 1\n      } else if (current <= search) {\n        minIndex = index + 1\n      } else { /* if (current > search) */\n        maxIndex = index - 1\n      }\n    }\n\n    return 0\n  }\n}\n\n/**\n * Internal utility that builds an iterator out of an `Iterable` or an `Array`.\n *\n * @hidden\n */\nexport function iterableToArray<A>(values: Iterable<A>): A[] {\n  if (!values) return []\n  if (Object.prototype.toString.call(values) === \"[object Array]\")\n    return values as A[]\n\n  const cursor = values[Symbol.iterator]()\n  const arr: A[] = []\n\n  while (true) {\n    const item = cursor.next()\n    if (item.value) arr.push(item.value)\n    if (item.done) return arr\n  }\n}\n\n/**\n * Natural log of 2.\n * @hidden\n */\nexport const lnOf2 = Math.log(2)\n\n/**\n * Calculates the base 2 logarithm of the given argument.\n *\n * @hidden\n * @return a number such that 2^nr^ is equal to our argument.\n */\nexport function log2(x: number): number {\n  return Math.log(x) / lnOf2\n}\n\n/**\n * The maximum number that can be returned by {@link nextPowerOf2}.\n * @hidden\n */\nexport const maxPowerOf2: number = 1 << 30\n\n/**\n * Given a positive integer, returns the next power of 2 that is bigger\n * than our argument, or the maximum that this function can\n * return which is 2^30^ (or 1,073,741,824).\n *\n * @return an integer that is a power of 2, that is bigger or\n *        equal with our argument and that is \"closest\" to it.\n *\n * @hidden\n */\nexport function nextPowerOf2(nr: number): number {\n  if (nr < 0) throw new IllegalArgumentError(\"nr must be positive\")\n  const bit = Math.ceil(log2(nr))\n  return 1 << (bit > 30 ? 30 : (bit & bit))\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IEquals, hashCodeOfString, NotImplementedError, Throwable } from \"funfix-core\"\nimport { Duration } from \"./time\"\nimport { ICancelable, Cancelable, IAssignCancelable, MultiAssignCancelable } from \"./cancelable\"\nimport { DynamicRef } from \"./ref\"\nimport { arrayBSearchInsertPos, maxPowerOf2, nextPowerOf2 } from \"./internals\"\n\n/**\n * A `Scheduler` is an execution context that can execute units of\n * work asynchronously, with a delay or periodically.\n *\n * It replaces Javascript's `setTimeout`, which is desirable due to\n * the provided utilities and because special behavior might be needed\n * in certain specialized contexts (e.g. tests), even if the\n * [[Scheduler.global]] reference is implemented with `setTimeout`.\n */\nexport abstract class Scheduler {\n  /**\n   *  The {@link ExecutionModel} is a specification of how run-loops\n   * and producers should behave in regards to executing tasks\n   * either synchronously or asynchronously.\n   */\n  public readonly executionModel: ExecutionModel\n\n  /**\n   * Index of the current cycle, incremented automatically (modulo\n   * the batch size) when doing execution by means of\n   * {@link Scheduler.executeBatched} and the `Scheduler` is\n   * configured with {@link ExecutionModel.batched}.\n   *\n   * When observed as being zero, it means an async boundary just\n   * happened.\n   */\n  batchIndex: number = 0\n\n  /**\n   * @param em the {@link ExecutionModel} to use for\n   *        {@link Scheduler.executionModel}, should default to\n   *        {@link ExecutionModel.global}\n   */\n  protected constructor(em: ExecutionModel) {\n    this.executionModel = em\n\n    // Building an optimized executeBatched\n    switch (em.type) {\n      case \"alwaysAsync\":\n        this.executeBatched = this.executeAsync\n        break\n\n      case \"synchronous\":\n        this.executeBatched = this.trampoline\n        break\n\n      case \"batched\":\n        const modulus = em.recommendedBatchSize - 1\n\n        this.executeBatched = (r) => {\n          const next = (this.batchIndex + 1) & modulus\n          if (next) {\n            this.batchIndex = next\n            return this.trampoline(r)\n          } else {\n            return this.executeAsync(r)\n          }\n        }\n    }\n  }\n\n  /**\n   * Executes tasks in batches, according to the rules set by the\n   * given {@link ExecutionModel}.\n   *\n   * The rules, depending on the chosen `ExecutionModel`:\n   *\n   * - if `synchronous`, then all tasks are executed with\n   *   {@link Scheduler.trampoline}\n   * - if `asynchronous`, then all tasks are executed with\n   *   {@link Scheduler.executeAsync}\n   * - if `batched(n)`, then `n` tasks will be executed\n   *   with `Scheduler.trampoline` and then the next execution\n   *   will force an asynchronous boundary by means of\n   *   `Scheduler.executeAsync`\n   *\n   * Thus, in case of batched execution, an internal counter gets\n   * incremented to keep track of how many tasks where executed\n   * immediately (trampolined), a counter that's reset when reaching\n   * the threshold or when an `executeAsync` happens.\n   */\n  public readonly executeBatched: (runnable: () => void) => void\n\n  /**\n   * Schedules the given `command` for async execution.\n   *\n   * In [[GlobalScheduler]] this method uses\n   * [setImmediate]{@link https://developer.mozilla.org/en/docs/Web/API/Window/setImmediate}\n   * when available. But given that `setImmediate` is a very\n   * non-standard operation that is currently implemented only by\n   * IExplorer and Node.js, on non-supporting environments we fallback\n   * on `setTimeout`. See\n   * [the W3C proposal]{@link https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html}.\n   *\n   * @param runnable is the thunk to execute asynchronously\n   */\n  public abstract executeAsync(runnable: () => void): void\n\n  /**\n   * Execute the given `runnable` on the current call stack by means\n   * of a \"trampoline\", preserving stack safety.\n   *\n   * This is an alternative to {@link executeAsync} for triggering\n   * light asynchronous boundaries.\n   */\n  public abstract trampoline(runnable: () => void): void\n\n  /** Reports that an asynchronous computation failed. */\n  public abstract reportFailure(e: Throwable): void\n\n  /**\n   * Returns the current time in milliseconds.  Note that while the\n   * unit of time of the return value is a millisecond, the\n   * granularity of the value depends on the underlying operating\n   * system and may be larger.  For example, many operating systems\n   * measure time in units of tens of milliseconds.\n   *\n   * It's the equivalent of `Date.now()`. When wanting to measure\n   * time, do not use `Date.now()` directly, prefer this method\n   * instead, because then it can be mocked for testing purposes,\n   * or overridden for better precision.\n   */\n  public abstract currentTimeMillis(): number\n\n  /**\n   * Schedules a task to run in the future, after `delay`.\n   *\n   * For example the following schedules a message to be printed to\n   * standard output after 5 minutes:\n   *\n   * ```typescript\n   * const task =\n   *   scheduler.scheduleOnce(Duration.minutes(5), () => {\n   *     console.log(\"Hello, world!\")\n   *   })\n   *\n   * // later if you change your mind ... task.cancel()\n   * ```\n   *\n   * @param delay is the time to wait until the execution happens; if\n   *        specified as a `number`, then it's interpreted as milliseconds;\n   *        for readability, prefer passing [[Duration]] values\n   * @param runnable is the callback to be executed\n   *\n   * @return a [[Cancelable]] that can be used to cancel the created\n   *         task before execution.\n   */\n  public abstract scheduleOnce(delay: number | Duration, runnable: () => void): ICancelable\n\n  /**\n   * Given a function that will receive the underlying\n   * {@link ExecutionModel}, returns a new {@link Scheduler}\n   * reference, based on the source that exposes the new\n   * `ExecutionModel` value when queried by means of the\n   * {@link Scheduler.executionModel} property.\n   *\n   * This method enables reusing global scheduler references in\n   * a local scope, but with a modified execution model to inject.\n   *\n   * The contract of this method (things you can rely on):\n   *\n   *  1. the source `Scheduler` must not be modified in any way\n   *  2. the implementation should wrap the source efficiently, such\n   *     that the result mirrors the implementation of the source\n   *     `Scheduler` in every way except for the execution model\n   *\n   * Sample:\n   *\n   * ```typescript\n   * import { Scheduler, ExecutionModel } from \"funfix\"\n   *\n   * const scheduler = Schedule.global()\n   *   .withExecutionModel(ExecutionModel.trampolined())\n   * ```\n   */\n  public abstract withExecutionModel(em: ExecutionModel): Scheduler\n\n  /**\n   * Schedules for execution a periodic task that is first executed\n   * after the given initial delay and subsequently with the given\n   * delay between the termination of one execution and the\n   * commencement of the next.\n   *\n   * For example the following schedules a message to be printed to\n   * standard output every 10 seconds with an initial delay of 5\n   * seconds:\n   *\n   * ```typescript\n   * const task =\n   *   s.scheduleWithFixedDelay(Duration.seconds(5), Duration.seconds(10), () => {\n   *     console.log(\"repeated message\")\n   *   })\n   *\n   * // later if you change your mind ...\n   * task.cancel()\n   * ```\n   *\n   * @param initialDelay is the time to wait until the first execution happens\n   * @param delay is the time to wait between 2 successive executions of the task\n   * @param runnable is the thunk to be executed\n   * @return a cancelable that can be used to cancel the execution of\n   *         this repeated task at any time.\n   */\n  public scheduleWithFixedDelay(initialDelay: number | Duration, delay: number | Duration, runnable: () => void): ICancelable {\n    const loop = (self: Scheduler, ref: IAssignCancelable, delayNow: number | Duration) =>\n      ref.update(self.scheduleOnce(delayNow, () => {\n        runnable()\n        loop(self, ref, delay)\n      }))\n\n    const task = MultiAssignCancelable.empty()\n    return loop(this, task, initialDelay)\n  }\n\n  /**\n   * Schedules a periodic task that becomes enabled first after the given\n   * initial delay, and subsequently with the given period. Executions will\n   * commence after `initialDelay` then `initialDelay + period`, then\n   * `initialDelay + 2 * period` and so on.\n   *\n   * If any execution of the task encounters an exception, subsequent executions\n   * are suppressed. Otherwise, the task will only terminate via cancellation or\n   * termination of the scheduler. If any execution of this task takes longer\n   * than its period, then subsequent executions may start late, but will not\n   * concurrently execute.\n   *\n   * For example the following schedules a message to be printed to standard\n   * output approximately every 10 seconds with an initial delay of 5 seconds:\n   *\n   * ```typescript\n   * const task =\n   *   s.scheduleAtFixedRate(Duration.seconds(5), Duration.seconds(10), () => {\n   *     console.log(\"repeated message\")\n   *   })\n   *\n   *   // later if you change your mind ...\n   *   task.cancel()\n   * ```\n   *\n   * @param initialDelay is the time to wait until the first execution happens\n   * @param period is the time to wait between 2 successive executions of the task\n   * @param runnable is the thunk to be executed\n   * @return a cancelable that can be used to cancel the execution of\n   *         this repeated task at any time.\n   */\n  public scheduleAtFixedRate(initialDelay: number | Duration, period: number | Duration, runnable: () => void): ICancelable {\n    const loop = (self: Scheduler, ref: IAssignCancelable, delayNowMs: number, periodMs: number) =>\n      ref.update(self.scheduleOnce(delayNowMs, () => {\n        // Benchmarking the duration of the runnable\n        const startAt = self.currentTimeMillis()\n        runnable()\n        // Calculating the next delay based on the current execution\n        const elapsedMs = self.currentTimeMillis() - startAt\n        const nextDelayMs = Math.max(0, periodMs - elapsedMs)\n        loop(self, ref, periodMs, nextDelayMs)\n      }))\n\n    const task = MultiAssignCancelable.empty()\n    return loop(this, task,\n      typeof initialDelay === \"number\" ? initialDelay : initialDelay.toMillis(),\n      typeof period === \"number\" ? period : period.toMillis()\n    )\n  }\n\n  /**\n   * Exposes a reusable [[GlobalScheduler]] reference by means of a\n   * {@link DynamicRef}, which allows for lexically scoped bindings to happen.\n   *\n   * ```typescript\n   * const myScheduler = new GlobalScheduler(false)\n   *\n   * Scheduler.global.bind(myScheduler, () => {\n   *   Scheduler.global.get() // myScheduler\n   * })\n   *\n   * Scheduler.global.get() // default instance\n   * ```\n   */\n  static readonly global: DynamicRef<Scheduler> =\n    DynamicRef.of(() => globalSchedulerRef)\n}\n\n/**\n * The `ExecutionModel` is a specification for how potentially asynchronous\n * run-loops should execute, imposed by the `Scheduler`.\n *\n * When executing tasks, a run-loop can always execute tasks\n * asynchronously (by forking logical threads), or it can always\n * execute them synchronously (same thread and call-stack, by\n * using an internal trampoline), or it can do a mixed mode\n * that executes tasks in batches before forking.\n *\n * The specification is considered a recommendation for how\n * run loops should behave, but ultimately it's up to the client\n * to choose the best execution model. This can be related to\n * recursive loops or to events pushed into consumers.\n */\nexport class ExecutionModel implements IEquals<ExecutionModel> {\n  /**\n   * Recommended batch size used for breaking synchronous loops in\n   * asynchronous batches. When streaming value from a producer to\n   * a synchronous consumer it's recommended to break the streaming\n   * in batches as to not hold the current thread or run-loop\n   * indefinitely.\n   *\n   * This is rounded to the next power of 2, because then for\n   * applying the modulo operation we can just do:\n   *\n   * ```typescript\n   * const modulus = recommendedBatchSize - 1\n   * // ...\n   * nr = (nr + 1) & modulus\n   * ```\n   */\n  public recommendedBatchSize: number\n\n  /**\n   * The type of the execution model, which can be:\n   *\n   * - `batched`: the default, specifying an mixed execution\n   *   mode under which tasks are executed synchronously in\n   *   batches up to a maximum size; after a batch of\n   *   {@link recommendedBatchSize} is executed, the next\n   *   execution should be asynchronous.\n   * - `synchronous`: specifies that execution should be\n   *   synchronous (immediate / trampolined) for as long as\n   *   possible.\n   * - `alwaysAsync`: specifies a run-loop should always do\n   *   async execution of tasks, triggering asynchronous\n   *   boundaries on each step.\n   */\n  public type: \"batched\" | \"synchronous\" | \"alwaysAsync\"\n\n  private constructor(type: \"batched\" | \"synchronous\" | \"alwaysAsync\", batchSize?: number) {\n    this.type = type\n    switch (type) {\n      case \"synchronous\":\n        this.recommendedBatchSize = maxPowerOf2\n        break\n      case \"alwaysAsync\":\n        this.recommendedBatchSize = 1\n        break\n      case \"batched\":\n        this.recommendedBatchSize = nextPowerOf2(batchSize || 128)\n        break\n    }\n  }\n\n  /** Implements `IEquals.equals`. */\n  equals(other: ExecutionModel): boolean {\n    return this.type === other.type &&\n      this.recommendedBatchSize === other.recommendedBatchSize\n  }\n\n  /** Implements `IEquals.hashCode`. */\n  hashCode(): number {\n    return hashCodeOfString(this.type) * 47 + this.recommendedBatchSize\n  }\n\n  /**\n   * An {@link ExecutionModel} that specifies that execution should be\n   * synchronous (immediate, trampolined) for as long as possible.\n   */\n  static synchronous(): ExecutionModel {\n    return new ExecutionModel(\"synchronous\")\n  }\n\n  /**\n   * An {@link ExecutionModel} that specifies a run-loop should always do\n   * async execution of tasks, thus triggering asynchronous boundaries on\n   * each step.\n   */\n  static alwaysAsync(): ExecutionModel {\n    return new ExecutionModel(\"alwaysAsync\")\n  }\n\n  /**\n   * Returns an {@link ExecutionModel} that specifies a mixed execution\n   * mode under which tasks are executed synchronously in batches up to\n   * a maximum size, the `recommendedBatchSize`.\n   *\n   * After such a batch of {@link recommendedBatchSize} is executed, the\n   * next execution should have a forced asynchronous boundary.\n   */\n  static batched(recommendedBatchSize?: number): ExecutionModel {\n    return new ExecutionModel(\"batched\", recommendedBatchSize)\n  }\n\n  /**\n   * The default {@link ExecutionModel} that should be used whenever\n   * an execution model isn't explicitly specified.\n   */\n  static readonly global: DynamicRef<ExecutionModel> =\n    DynamicRef.of(() => ExecutionModel.batched())\n}\n\n/**\n * Internal trampoline implementation used for implementing\n * {@link Scheduler.trampoline}.\n *\n * @final\n * @hidden\n */\nclass Trampoline {\n  private readonly _reporter: (e: Throwable) => void\n  private readonly _queue: (() => void)[]\n  private _isActive: boolean\n\n  constructor(reporter: (e: Throwable) => void) {\n    this._isActive = false\n    this._queue = []\n    this._reporter = reporter\n  }\n\n  execute(r: () => void) {\n    if (!this._isActive) {\n      this.runLoop(r)\n    } else {\n      this._queue.push(r)\n    }\n  }\n\n  private runLoop(r: () => void) {\n    this._isActive = true\n    try {\n      let cursor: (() => void) | undefined = r\n      while (cursor) {\n        try { cursor() } catch (e) { this._reporter(e) }\n        cursor = this._queue.pop()\n      }\n    } finally {\n      this._isActive = false\n    }\n  }\n}\n\n/**\n * `GlobalScheduler` is a [[Scheduler]] implementation based on Javascript's\n * [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout}\n * and (if available and configured)\n * [setImmediate]{@link https://developer.mozilla.org/en/docs/Web/API/Window/setImmediate}.\n */\nexport class GlobalScheduler extends Scheduler {\n  /**\n   * If `true`, then `setImmediate` is used in `execute`.\n   */\n  private readonly _useSetImmediate: boolean\n\n  /**\n   * {@link Trampoline} used for immediate execution in\n   * {@link Scheduler.trampoline}.\n   */\n  private readonly _trampoline: Trampoline\n\n  /**\n   * @param canUseSetImmediate is a boolean informing the\n   *        `GlobalScheduler` implementation that it can use the\n   *        nonstandard `setImmediate` for scheduling asynchronous\n   *        tasks without extra delays.\n   *\n   * @param em the {@link ExecutionModel} to use for\n   *        {@link Scheduler.executionModel}, should default to\n   *        {@link ExecutionModel.global}\n   *\n   * @param reporter is the reporter to use for reporting uncaught\n   *        errors, defaults to `console.error`\n   */\n  constructor(\n    canUseSetImmediate: boolean = false,\n    em: ExecutionModel = ExecutionModel.global.get(),\n    reporter?: (e: Throwable) => void) {\n\n    super(em)\n    if (reporter) this.reportFailure = reporter\n    this._trampoline = new Trampoline(this.reportFailure)\n    // tslint:disable:strict-type-predicates\n    this._useSetImmediate = (canUseSetImmediate || false) && (typeof setImmediate === \"function\")\n\n    this.executeAsync = this._useSetImmediate\n      ? r => setImmediate(safeRunnable(r, this.reportFailure))\n      : r => setTimeout(safeRunnable(r, this.reportFailure))\n  }\n\n  /* istanbul ignore next */\n  executeAsync(runnable: () => void): void {\n    /* istanbul ignore next */\n    throw new NotImplementedError(\"Constructor of GlobalScheduler wasn't executed\")\n  }\n\n  trampoline(runnable: () => void): void {\n    return this._trampoline.execute(runnable)\n  }\n\n  /* istanbul ignore next */\n  reportFailure(e: Throwable): void {\n    console.error(e)\n  }\n\n  currentTimeMillis(): number {\n    return Date.now()\n  }\n\n  scheduleOnce(delay: number | Duration, runnable: () => void): ICancelable {\n    const r = () => {\n      this.batchIndex = 0\n      try { runnable() } catch (e) { this.reportFailure(e) }\n    }\n\n    const ms = Math.max(0, Duration.of(delay).toMillis())\n    const task = setTimeout(r, ms)\n    return Cancelable.of(() => clearTimeout(task))\n  }\n\n  withExecutionModel(em: ExecutionModel) {\n    return new GlobalScheduler(this._useSetImmediate, em)\n  }\n}\n\n/**\n * The `TestScheduler` is a {@link Scheduler} type meant for testing purposes,\n * being capable of simulating asynchronous execution and the passage of time.\n *\n * Example:\n *\n * ```typescript\n * const s = new TestScheduler()\n *\n * s.execute(() => { console.log(\"Hello, world!\") })\n *\n * // Triggers actual execution\n * s.tick()\n *\n * // Simulating delayed execution\n * const task = s.scheduleOnce(Duration.seconds(10), () => {\n *   console.log(\"Hello, delayed!\")\n * })\n *\n * // We can cancel a delayed task if we want\n * task.cancel()\n *\n * // Or we can execute it by moving the internal clock forward in time\n * s.tick(Duration.seconds(10))\n * ```\n */\nexport class TestScheduler extends Scheduler {\n  private _reporter: (error: any) => void\n  private _trampoline: Trampoline\n  private _stateRef?: TestSchedulerState\n\n  /**\n   * @param reporter is an optional function that will be called\n   *        whenever {@link Scheduler.reportFailure} is invoked.\n   *\n   * @param em the {@link ExecutionModel} to use for\n   *        the {@link Scheduler.executionModel}, defaults to\n   *        `\"synchronous\"` for `TestScheduler`\n   */\n  constructor(reporter?: (error: any) => void, em: ExecutionModel = ExecutionModel.synchronous()) {\n    super(em)\n    this._reporter = reporter || (_ => {})\n    this._trampoline = new Trampoline(this.reportFailure.bind(this))\n  }\n\n  private _state() {\n    if (!this._stateRef) {\n      this._stateRef = new TestSchedulerState()\n      this._stateRef.updateTasks([])\n    }\n    return this._stateRef\n  }\n\n  /**\n   * Returns a list of triggered errors, if any happened during\n   * the {@link tick} execution.\n   */\n  public triggeredFailures(): Array<any> { return this._state().triggeredFailures }\n\n  /**\n   * Returns `true` if there are any tasks left to execute, `false`\n   * otherwise.\n   */\n  public hasTasksLeft(): boolean { return this._state().tasks.length > 0 }\n\n  public executeAsync(runnable: () => void): void {\n    this._state().tasks.push([this._state().clock, runnable])\n  }\n\n  public trampoline(runnable: () => void): void {\n    this._trampoline.execute(runnable)\n  }\n\n  public reportFailure(e: Throwable): void {\n    this._state().triggeredFailures.push(e)\n    this._reporter(e)\n  }\n\n  public currentTimeMillis(): number {\n    return this._state().clock\n  }\n\n  public scheduleOnce(delay: number | Duration, runnable: () => void): ICancelable {\n    const d = Math.max(0, Duration.of(delay).toMillis())\n    const state = this._state()\n    const scheduleAt = state.clock + d\n    const insertAt = state.tasksSearch(-scheduleAt)\n    const ref: [number, () => void] = [scheduleAt, runnable]\n    state.tasks.splice(insertAt, 0, ref)\n\n    return Cancelable.of(() => {\n      const filtered: Array<[number, () => void]> = []\n      for (const e of state.tasks) {\n        if (e !== ref) filtered.push(e)\n      }\n      state.updateTasks(filtered)\n    })\n  }\n\n  public withExecutionModel(em: ExecutionModel): TestScheduler {\n    const ec2 = new TestScheduler(this._reporter, em)\n    ec2._stateRef = this._state()\n    return ec2\n  }\n\n  /**\n   * Executes the current batch of tasks that are pending, relative\n   * to [currentTimeMillis]{@link TestScheduler.currentTimeMillis}.\n   *\n   * ```typescript\n   * const s = new TestScheduler()\n   *\n   * // Immediate execution\n   * s.executeAsync(() => console.log(\"A\"))\n   * s.executeAsync(() => console.log(\"B\"))\n   * // Delay with 1 second from now\n   * s.scheduleOnce(Duration.seconds(1), () => console.log(\"C\"))\n   * s.scheduleOnce(Duration.seconds(1), () => console.log(\"D\"))\n   * // Delay with 2 seconds from now\n   * s.scheduleOnce(Duration.seconds(2), () => console.log(\"E\"))\n   * s.scheduleOnce(Duration.seconds(2), () => console.log(\"F\"))\n   *\n   * // Actual execution...\n   *\n   * // Prints A, B\n   * s.tick()\n   * // Prints C, D\n   * s.tick(Duration.seconds(1))\n   * // Prints E, F\n   * s.tick(Duration.seconds(1))\n   * ```\n   *\n   * @param duration is an optional timespan to user for incrementing\n   * [currentTimeMillis]{@link TestScheduler.currentTimeMillis}, thus allowing\n   * the execution of tasks scheduled to execute with a delay.\n   *\n   * @return the number of executed tasks\n   */\n  public tick(duration?: number | Duration): number {\n    const state = this._state()\n    let toExecute = []\n    let jumpMs = Duration.of(duration || 0).toMillis()\n    let executed = 0\n\n    while (true) {\n      const peek = state.tasks.length > 0\n        ? state.tasks[state.tasks.length - 1]\n        : undefined\n\n      if (peek && peek[0] <= state.clock) {\n        toExecute.push(state.tasks.pop())\n      } else if (toExecute.length > 0) {\n        // Executing current batch, randomized\n        while (toExecute.length > 0) {\n          const index = Math.floor(Math.random() * toExecute.length)\n          const elem = toExecute[index] as any\n          try {\n            toExecute.splice(index, 1)\n            this.batchIndex = 0\n            elem[1]()\n          } catch (e) {\n            this.reportFailure(e)\n          } finally {\n            executed += 1\n          }\n        }\n      } else if (jumpMs > 0) {\n        const nextTaskJump = peek && (peek[0] - state.clock) || jumpMs\n        const add = Math.min(nextTaskJump, jumpMs)\n        state.clock += add\n        jumpMs -= add\n      } else {\n        break\n      }\n    }\n    return executed\n  }\n\n  /**\n   * Executes the task that's at the top of the stack, in case we\n   * have a task to execute that doesn't require a jump in time.\n   *\n   * ```typescript\n   * const ec = new TestScheduler()\n   *\n   * ec.execute(() => console.log(\"A\"))\n   * ec.execute(() => console.log(\"B\"))\n   *\n   * // Prints B\n   * ec.tickOne()\n   * // Prints A\n   * ec.tickOne()\n   * ```\n   */\n  public tickOne(): boolean {\n    const state = this._state()\n    const peek = state.tasks.length > 0\n      ? state.tasks[state.tasks.length - 1]\n      : undefined\n\n    if (!peek || peek[0] > state.clock) return false\n    this._state().tasks.pop()\n    this.batchIndex = 0\n    try { peek[1]() } catch (e) { this.reportFailure(e) }\n    return true\n  }\n}\n\nclass TestSchedulerState {\n  public clock: number\n  public triggeredFailures: Array<any>\n  public tasks: Array<[number, () => void]>\n  public tasksSearch: (search: number) => number\n\n  constructor() {\n    this.clock = 0\n    this.triggeredFailures = []\n    this.updateTasks([])\n  }\n\n  updateTasks(tasks: Array<[number, () => void]>) {\n    this.tasks = tasks\n    this.tasksSearch = arrayBSearchInsertPos(this.tasks, e => -e[0])\n  }\n}\n\n/**\n * Internal, reusable [[GlobalScheduler]] reference.\n *\n * @Hidden\n */\nconst globalSchedulerRef = new GlobalScheduler(true)\n\n/**\n * Internal utility wrapper a runner in an implementation that\n * reports errors with the provided `reporter` callback.\n *\n * @Hidden\n */\nfunction safeRunnable(r: () => void, reporter: (error: any) => void): () => void {\n  return () => { try { r() } catch (e) { reporter(e) } }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Try, Success, Failure, Option, Some, None, Either, Left, Right,\n  IllegalStateError, IllegalArgumentError, TimeoutError, Throwable\n} from \"funfix-core\"\n\nimport { Scheduler } from \"./scheduler\"\nimport { Duration } from \"./time\"\nimport { ICancelable, Cancelable, ChainedCancelable, DummyCancelable } from \"./cancelable\"\nimport { iterableToArray } from \"./internals\"\n\n/**\n * `IPromiseLike` represents objects that have a `then` method complying with\n * the [Promises/A+](https://promisesaplus.com/) specification.\n */\nexport interface IPromiseLike<T> {\n  /**\n   * Attaches callbacks for the resolution and/or rejection of the promise.\n   *\n   * See [MDN: Promise.then]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then}.\n   *\n   * @param onFulfilled The callback to execute when the promise is resolved.\n   * @param onRejected The callback to execute when the promise is rejected.\n   *\n   * @returns A promise for the completion of which ever callback is executed.\n   */\n  then(onFulfilled?: (value: T) => any, onRejected?: (reason: Throwable) => any): IPromiseLike<any>\n}\n\n/**\n * A `Future` represents a value which may or may not *currently* be available, but will be\n * available at some point, or an exception if the operation producing the result fails.\n *\n * `Future<A>` is a Promise-like alternative data type, that's cancelable and lawful,\n * inspired by Scala's `Future[A]`.\n *\n * You can easily build futures out of functions, that will execute asynchronously\n * (e.g. not on the current call stack) by means of `Future.of`:\n *\n * ```typescript\n * Future.of(() => 1 + 1)\n * ```\n *\n * Such computations use the [[Scheduler.global]] reference for execution, which\n * can be overridden, many times in the function call, being an optional parameter\n * (e.g. in `Future.of`), or in the local context, because it is exposed as a\n * [[DynamicRef]], which allows for localised overrides:\n *\n * ```typescript\n * import { Scheduler, GlobalScheduler, Future } from \"funfix\"\n *\n * // Custom Scheduler reference that we want to use\n * const ec = new GlobalScheduler(false)\n *\n * Future.of(() => x + y, ec)\n *\n * // ... is equivalent with ...\n *\n * Scheduler.global.bind(ec, () => {\n *   Future.of(() => x + y)\n * })\n * ```\n *\n * To create a `Future` out of an actual asynchronous computation, you can\n * use `Future.create`. Here's an example that takes a function and executes\n * it with an initial delay, returning a cancelable `Future`:\n *\n * ```typescript\n * import { Scheduler, Future, Try, Duration, Cancelable } from \"funfix\"\n *\n * const delay = <A>(d: Duration, f: () => A, ec: Scheduler = Scheduler.global.get()) =>\n *   Future.create<A>(\n *     cb => {\n *       const task = ec.scheduleOnce(d, () => cb(Try.of(f)))\n *\n *       return Cancelable.of(() => {\n *         console.warn(\"Delayed task was cancelled\")\n *         task.cancel()\n *       })\n *     },\n *     ec\n *   )\n * ```\n *\n * Normally you can `await` on functions returning `Future<A>` values:\n *\n * ```typescript\n * async function asyncSample(n: number): Promise<number> {\n *   let sum = 0\n *   for (let i = 0; i < n; i++) {\n *     sum += await Future.of(() => i)\n *   }\n *   return sum\n * }\n * ```\n *\n * Such functions do need to return a `Promise`, because JavaScript\n * generates code that uses `Promise`'s constructor. But a `Future`\n * is \"thenable\", so you can await on functions returning `Future`\n * just fine.\n */\nexport abstract class Future<A> implements IPromiseLike<A>, ICancelable {\n  /**\n   * Reference to the current {@link Scheduler} available for subsequent\n   * data transformations. Can be set in `Future`'s constructors, or by\n   * transforming the source by {@link withScheduler}.\n   *\n   * Protected, because it shouldn't be public API, being meant for\n   * `Future` implementations.\n   *\n   * @protected\n   */\n  protected readonly _scheduler: Scheduler\n\n  /**\n   * Reference to the current {@link ICancelable} available for\n   * subsequent data transformations.\n   *\n   * Protected, because it shouldn't be public API, being meant for\n   * `Future` implementations.\n   *\n   * @protected\n   */\n  protected _cancelable?: ICancelable\n\n  /**\n   * Extracts the completed value for this `Future`, returning `Some(result)`\n   * if this `Future` is already complete or `None` in case the `Future` wasn't\n   * completed yet.\n   *\n   * ```typescript\n   * const f1 = Future.of(() => 1)\n   *\n   * // Given the async execution of `Future.of`, the immediate invocations of\n   * // `value()` will yield `None`, but after complete it will yield\n   * // `Some(Success(1))`\n   * f1.value()\n   *\n   * const f2 = Future.raise(new DummyError())\n   *\n   * // Immediately yields Some(Failure(DummyError))\n   * f2.value()\n   * ```\n   */\n  abstract value(): Option<Try<A>>\n\n  /**\n   * Given a callback, calls it with this `Future`'s result when that result\n   * is ready.\n   *\n   * The execution of this callback is always trampolined (for already completed\n   * futures), or asynchronous, which means that modeling loops based on it is\n   * memory safe.\n   *\n   * ```typescript\n   * Future.of(() => \"John\").complete(r => {\n   *   r.fold(\n   *    error => console.info(\"Error: \" + error),\n   *    success => console.info(\"Hello, \" + John)\n   *   )\n   * })\n   * ```\n   */\n  abstract onComplete(f: (a: Try<A>) => void): void\n\n  /**\n   * In case this `Future` isn't complete, then send it a cancel signal.\n   *\n   * Depending on the computation that will complete this future, its execution\n   * might be interrupted.\n   *\n   * Execution has the same properties of {@link ICancelable}, being idempotent\n   * (calling it multiple times has the same effect as calling it once).\n   *\n   * In order to create a cancelable `Future`, use {@link Future.create}.\n   */\n  abstract cancel(): void\n\n  /**\n   * Sets the {@link Scheduler} reference that's going to get used for\n   * subsequent data transformations.\n   *\n   * `Future` references have a {@link Scheduler} reference attached at build\n   * time, that's going to get used for data transformations. This method\n   * returns a new `Future` reference that's going to mirror the source,\n   * but that's going to use the given `Scheduler` for subsequent operations\n   * like `map`, `flatMap`, `transformWith`, etc.\n   *\n   * ```typescript\n   * const ec1 = new GlobalScheduler(true)\n   *\n   * // The default Scheduler is global (that second parameter is optiona)\n   * const f1 = Future.create(f, ec1)\n   *\n   * // The `f1` future is going to get executed by `ec1`, however\n   * // this subsequent `flatMap` is getting evaluated by `ec2`\n   * const ec2 = new GlobalScheduler(false)\n   * const f2 = f1.withScheduler(ec2).flatMap(x => Future.pure(x * 2))\n   * ```\n   *\n   * When no `Scheduler` is specified, the default is assumed to be\n   * {@link Scheduler.global}.\n   *\n   * @param ec is the scheduler that's going to get used asynchronous execution\n   *        of subsequent operations\n   */\n  abstract withScheduler(ec: Scheduler): Future<A>\n\n  /**\n   * Transforms the source, regardless if the result is a failure or a success.\n   *\n   * This function is a combination of {@link flatMap} and {@link recoverWith},\n   * being the (type safe) alternative to JavaScript's\n   * [then]{@link IPromiseLike.then} from the\n   * [Promises/A+](https://promisesaplus.com/) specification.\n   *\n   * NOTE: in Funfix these fold-like methods, by convention, take as the\n   * first parameter the function that transforms the failure (the left),\n   * whereas the second parameter is the function that transforms the\n   * successful result (the right). Think of `Either<Error, A>`.\n   *\n   * ```typescript\n   * const randomInt = (max: number) =>\n   *   Future.of(() => {\n   *     const n = Math.random() * max\n   *     n & n\n   *   })\n   *\n   * const randomEvenInt = (max: number) =>\n   *   randomInt(max).transformWith(\n   *     err => Future.pure(9),\n   *     value => (\n   *       // retry until we have an even value\n   *       value % 2 == 0 ? Future.pure(value) : randomEvenInt()\n   *     )\n   *   )\n   * ```\n   *\n   * Also see {@link transform}.\n   *\n   * @param failure is the function that's going to get executed in case the\n   *        source signals a failure\n   *\n   * @param success is the function that's going to get executed in case the\n   *        source signals a successful result\n   */\n  abstract transformWith<B>(failure: (e: Throwable) => Future<B>, success: (a: A) => Future<B>): Future<B>\n\n  /**\n   * Transforms the sources, regardless if the result is a failure or a success.\n   *\n   * This function is a combination of {@link map} and {@link recover},\n   * being the (type safe) alternative to JavaScript's\n   * [then]{@link IPromiseLike.then} from the\n   * [Promises/A+](https://promisesaplus.com/) specification.\n   *\n   * Example:\n   *\n   * ```typescript\n   * import { Left, Right } from \"funfix\"\n   *\n   * // Expose errors by lifting them to an Either<Error, A>\n   * future.transform<Either<Throwable, A>>(Left, Right)\n   * ```\n   *\n   * Also see {@link transformWith}.\n   *\n   * @param failure is the function that's going to get executed in case the\n   *        source signals a failure\n   *\n   * @param success is the function that's going to get executed in case the\n   *        source signals a successful result\n   */\n  transform<B>(failure: (e: Throwable) => B, success: (a: A) => B): Future<B> {\n    return this.transformWith(\n      e => Future.pure(failure(e), this._scheduler),\n      a => Future.pure(success(a), this._scheduler))\n  }\n\n  /**\n   * Exposes underlying errors by lifting both successful and failed\n   * results into an `Either` value.\n   *\n   * Given that errors are short-circuiting the processing of {@link flatMap}\n   * chains, this method is useful for exposing errors such that you can\n   * `flatMap` over them.\n   *\n   * ```typescript\n   * const f: Future<number> = Future.raise(new DummyError)\n   *\n   * // Yields a successful Left(DummyError) on completion\n   * const fe: Future<Either<Throwable, number>> = f.attempt()\n   *\n   * // Yields a Right(1) on completion\n   * const fr: Future<Either<Throwable, number>> = Future.pure(1).attempt()\n   * ```\n   */\n  attempt(): Future<Either<Throwable, A>> {\n    return this.transform<Either<Throwable, A>>(Left, Right)\n  }\n\n  /**\n   * Chains asynchronous operations.\n   *\n   * Creates a new future by applying a function to the successful result of\n   * the source and returns the result of the function as the new future.\n   * If this future is completed with an exception then the new future will\n   * also contain this exception.\n   *\n   * This operation is the monadic bind (e.g. `Monad.flatMap`).\n   *\n   * ```typescript\n   * const fa = Future.of(() => 3)\n   * const fb = Future.of(() => 5)\n   *\n   * // Yields 3 + 5\n   * fa.flatMap(a => fb.map(b => a + b))\n   * ```\n   */\n  flatMap<B>(f: (a: A) => Future<B>): Future<B> {\n    return this.transformWith(Future.raise, f)\n  }\n\n  /**\n   * Given a mapping function, transforms the successful result of the source.\n   *\n   * If the source is completed with an exception, then the new future will\n   * also be completed in an error.\n   *\n   * This operation is the functor map (e.g. `Functor.map`).\n   *\n   * ```typescript\n   * const f = Future.of(() => \"The future\")\n   *\n   * const g = f.map(x => x + \" is now!\")\n   * ```\n   */\n  map<B>(f: (a: A) => B): Future<B> {\n    return this.transformWith(Future.raise,\n      a => Future.pure(f(a), this._scheduler))\n  }\n\n  /**\n   * Creates a new future that will handle any matching throwable that this\n   * future might contain by assigning it a value of another future.\n   *\n   * If there is no match, or if this future contains a valid result then the\n   * new future will contain the same result.\n   *\n   * This operation is the equivalent of {@link flatMap} for handling errors.\n   * Also see {@link transformWith}, which can handle both successful results\n   * and failures.\n   *\n   * ```typescript\n   * const f = Future.of<number>(() => { throw new DummyError() })\n   *\n   * f.recoverWith(e => e instanceof DummyError\n   *   ? Future.pure(10) // Fallback\n   *   : Future.raise(e) // Re-throw\n   * )\n   * ```\n   */\n  recoverWith<AA>(f: (e: Throwable) => Future<AA>): Future<A | AA> {\n    return this.transformWith<A | AA>(f, Future.pure)\n  }\n\n  /**\n   *\n   *\n   * ```typescript\n   * const f = Future.of<number>(() => { throw new DummyError() })\n   *\n   * f.recover(e => {\n   *   if (e instanceof DummyError) return 10\n   *   // Don't re-throw exceptions like this, use `recoverWith` instead!\n   *   throw e\n   * })\n   * ```\n   */\n  recover<AA>(f: (e: Throwable) => AA): Future<A | AA> {\n    return this.transformWith<A | AA>(\n      e => Future.pure(f(e), this._scheduler),\n      a => Future.pure(a, this._scheduler))\n  }\n\n  then<TResult1, TResult2>(\n    onFulfilled?: ((value: A) => (IPromiseLike<TResult1> | TResult1)) | undefined | null,\n    onRejected?: ((reason: Throwable) => (IPromiseLike<TResult2> | TResult2)) | undefined | null): Future<TResult2 | TResult1> {\n\n    if (!onFulfilled && !onRejected) return this as any\n    const ec = this._scheduler\n    return this.transformWith(\n      promiseThen(onRejected, e => Future.raise(e, ec), ec),\n      promiseThen(onFulfilled, a => Future.pure(a, ec), ec)\n    ) as any\n  }\n\n  /**\n   * Transforms this `Future<A>` reference into a standard JavaScript `Promise<A>`\n   * reference.\n   *\n   * Normally a `Future` is \"thenable\", so JavaScript should have no problem\n   * working with it, however in certain contexts this conversion is useful for\n   * working with type definitions that don't recognize the structural typing\n   * defined by the Promises/A+ specification.\n   */\n  toPromise(): Promise<A> {\n    return new Promise<A>((resolve, reject) => {\n      this.onComplete(_ => _.fold(reject, resolve))\n    })\n  }\n\n  /**\n   * Delays signaling the result of this `Future` by the specified duration.\n   *\n   * It works for successful results:\n   *\n   * ```typescript\n   * const fa = Future.of(() => \"Alex\")\n   *\n   * // Delays the signaling by 1 second\n   * fa.delayResult(1000).flatMap\n   * ```\n   *\n   * And for failures as well:\n   *\n   * ```typescript\n   * Future.raise(new TimeoutError()).delayResult(1000)\n   * ```\n   *\n   * @param delay is the duration to wait before signaling the final result\n   */\n  delayResult(delay: number | Duration): Future<A> {\n    return this.transformWith(\n      err => Future.delayedTick(delay, this._scheduler).flatMap(_ => Future.raise(err, this._scheduler)),\n      a => Future.delayedTick(delay, this._scheduler).map(_ => a)\n    )\n  }\n\n  /**\n   * Returns a future that mirrors the source in case the result of the source\n   * is signaled within the required `after` duration, otherwise it\n   * fails with a `TimeoutError`, cancelling the source.\n   *\n   * ```typescript\n   * const fa = Future.of(() => 1).delayResult(10000)\n   *\n   * // Will fail with a TimeoutError\n   * fa.timeout(1000)\n   * ```\n   *\n   * @param after is the duration to wait until it triggers the timeout error\n   */\n  timeout(after: number | Duration): Future<A> {\n    // Creating the exception immediately, to get a good stack trace\n    const fb = Future.raise(new TimeoutError(Duration.of(after).toString()), this._scheduler)\n    return this.timeoutTo(after, () => fb)\n  }\n\n  /**\n   * Returns a future that mirrors the source in case the result of the source\n   * is signaled within the required `after` duration, otherwise it\n   * triggers the execution of the given `fallback` after the duration has\n   * passed, cancelling the source.\n   *\n   * This is literally the implementation of {@link Future.timeout}:\n   *\n   * ```typescript\n   * const fa = Future.of(() => 1).delayResult(10000)\n   *\n   * fa.timeoutTo(1000, () => Future.raise(new TimeoutError()))\n   * ```\n   *\n   * @param after is the duration to wait until it triggers the `fallback`\n   * @param fallback is a thunk generating a fallback `Future` to timeout to\n   */\n  timeoutTo<AA>(after: number | Duration, fallback: () => Future<AA>): Future<A | AA> {\n    const other = Future.delayedTick(after, this._scheduler).flatMap(_ => fallback())\n    const lst: Future<A | AA>[] = [this, other]\n    return Future.firstCompletedOf(lst, this._scheduler)\n  }\n\n  // Implements HK<F, A>\n  /** @hidden */ readonly _funKindF: Future<any>\n  /** @hidden */ readonly _funKindA: A\n\n  // Implements Constructor<T>\n  /** @hidden */ static readonly _funErasure: Future<any>\n\n  /**\n   * Given a function that executes immediately, executes it asynchronously\n   * and returns a `Future` that will complete when the result is ready.\n   *\n   * ```typescript\n   * const sum = (x: number, y: number) =>\n   *   Future.of(() => x + y)\n   * ```\n   *\n   * @param thunk is the function to execute asynchronously\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static of<A>(thunk: () => A, ec: Scheduler = Scheduler.global.get()): Future<A> {\n    const ref = FutureMaker.empty<A>(ec)\n    ec.executeAsync(() => ref.tryComplete(Try.of(thunk)))\n    return ref.future()\n  }\n\n  /**\n   * Lifts a pure value into the `Future` context, returning a `Future`\n   * reference that's already complete with the given value.\n   *\n   * This is the equivalent of `Promise.resolve(a)`.\n   *\n   * ```typescript\n   * const f: Future<number> = Future.pure(10)\n   *\n   * // Prints Success(10)\n   * f.onComplete(r => console.info(r))\n   * ```\n   *\n   * @param a is the value to lift in the `Future` context and that will\n   *        get signaled in `onComplete` callbacks\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static pure<A>(a: A, ec: Scheduler = Scheduler.global.get()): Future<A> {\n    return new PureFuture(Success(a), ec)\n  }\n\n  /**\n   * Lifts an error in the `Future` context, returning a `Future` reference\n   * that's already failed with the given error.\n   *\n   * This is the equivalent of `Promise.reject`.\n   *\n   * ```typescript\n   * const f: Future<number> = Future.raise(\"Oops!\")\n   *\n   * // Prints Failure(\"Oops!\")\n   * f.onComplete(r => console.info(r))\n   * ```\n   *\n   * @param e is the error to lift in the `Future` context and that will\n   *        get signaled as a failure in `onComplete` callbacks\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static raise(e: Throwable, ec: Scheduler = Scheduler.global.get()): Future<never> {\n    return new PureFuture(Failure(e), ec)\n  }\n\n  /**\n   * Given a side-effectful function that triggers an asynchronous computation,\n   * execute it and return a `Future` reference.\n   *\n   * The given `register` function will be invoked immediately to \"schedule\"\n   * the asynchronous callback, where the callback is the parameter injected in\n   * that function.\n   *\n   * The `register` function can optionally return a {@link ICancelable}\n   * reference that can get used to cancel the running asynchronous\n   * computation.\n   *\n   * Example:\n   *\n   * ```typescript\n   * import { Scheduler, Future, Try, Duration, Cancelable } from \"funfix\"\n   *\n   * const delay = <A>(d: Duration, f: () => A, ec: Scheduler = Scheduler.global.get()) =>\n   *   Future.create<A>(\n   *     cb => {\n   *       const task = ec.scheduleOnce(d, () => cb(Try.of(f)))\n   *\n   *       return Cancelable.of(() => {\n   *         console.warn(\"Delayed task was cancelled\")\n   *         task.cancel()\n   *       })\n   *     },\n   *     ec\n   *   )\n   * ```\n   *\n   * Note that by not returning a cancelable, the returned `Future` reference\n   * will NOT BE cancelable.\n   *\n   * ```typescript\n   * // This future is not cancelable, because we are not\n   * // returning a cancelable reference\n   * Future.create<number>(cb => {\n   *   setTimeout(1000, () => cb(Success(10)))\n   * })\n   * ```\n   *\n   * @param register is the side-effectful function that will get invoked\n   *        to build our `Future`, receiving a callback that's supposed to\n   *        get invoked (only once) when the asynchronous computation completes,\n   *        and that can optionally return a cancelable reference that can\n   *        get used to cancel the running computation\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static create<A>(register: (cb: (a: Try<A>) => void) => (ICancelable | void), ec: Scheduler = Scheduler.global.get()): Future<A> {\n    const ref = FutureMaker.empty<A>(ec)\n    try {\n      const cRef = register(ref.complete)\n      return ref.future(cRef || undefined)\n    } catch (e) {\n      return Future.raise(e, ec)\n    }\n  }\n\n  /**\n   * Returns a `Future` reference that's already completed with a `void` value.\n   *\n   * Alias for:\n   *\n   * ```typescript\n   * Future.pure(undefined)\n   * ```\n   *\n   * Note that the same reference is always returned, so this property holds:\n   *\n   * ```typescript\n   * Future.unit() === Future.unit()\n   * ```\n   */\n  static unit(ec: Scheduler = Scheduler.global.get()): Future<void> {\n    // Given that this reference is immutable once built for the given\n    // Scheduler, and that schedulers don't change that much, we are\n    // caching the reference in order to preserve memory\n    const ecAny = ec as any\n    let ref = ecAny[\"_funCache\"] && ecAny[\"_funCache\"][\"futureUnit\"]\n    if (!ref) {\n      ref = new PureFuture(Success(undefined), ec)\n      ecAny[\"_funCache\"] = ecAny[\"_funCache\"] || {}\n      ecAny[\"_funCache\"][\"futureUnit\"] = ref\n    }\n    return ref\n  }\n\n  /**\n   * Returns a `Future` that will complete after the given `delay`.\n   *\n   * This can be used to do delayed execution. For example:\n   *\n   * ```typescript\n   * Future.delayedTick(1000).flatMap(_ =>\n   *   Future.of(() => console.info(\"Hello!\"))\n   * )\n   * ```\n   *\n   * @param delay is the duration to wait before signaling the tick\n   * @param ec is the scheduler that will actually schedule the tick's execution\n   */\n  static delayedTick<A>(delay: number | Duration, ec: Scheduler = Scheduler.global.get()): Future<void> {\n    return Future.create<void>(cb => ec.scheduleOnce(delay, () => cb(Success(undefined))), ec)\n  }\n\n  /**\n   * Keeps calling `f` until it returns a `Right` value.\n   *\n   * Based on Phil Freeman's\n   * [[http://functorial.com/stack-safety-for-free/index.pdf Stack Safety for Free]].\n   *\n   * ```typescript\n   * const generate = () => {\n   *   const n = Math.random() * 1000\n   *   return n & n\n   * }\n   *\n   * // Keeps looping until an odd number is returned\n   * Future.tailRecM(0, a => Future.of(() => {\n   *   return a % 2 == 0 ? Left(generate()) : Right(a)\n   * })\n   * ```\n   *\n   * @param a is the initial seed\n   * @param f is the function that keeps being invoked with the previous\n   *          `Left(a)` value, until a `Right(b)` value is returned,\n   *          which will be the `onComplete` result of the `Future`\n   *          reference\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static tailRecM<A, B>(a: A, f: (a: A) => Future<Either<A, B>>, ec: Scheduler = Scheduler.global.get()): Future<B> {\n    // Recursive loop based on flatMap\n    return f(a).flatMap(r => {\n      if (r.isRight()) return Future.pure(r.get(), ec)\n      return Future.tailRecM(r.swap().get(), f, ec)\n    })\n  }\n\n  /**\n   * Transforms any `Promise`-like data type into a `Future`.\n   *\n   * ```typescript\n   * const p: Promise<number> = Promise.resolve(10)\n   *\n   * const f: Future<number> = Future.fromPromise(p)\n   * ```\n   *\n   * @param ref is the promise reference that we want to convert into a `Future`\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static fromPromise<A>(ref: IPromiseLike<A>, ec: Scheduler = Scheduler.global.get()): Future<A> {\n    if (ref instanceof Future)\n      return (ref as Future<A>).withScheduler(ec)\n    else\n      return Future.create<A>(\n        cb => { ref.then(value => cb(Success(value)),err => cb(Failure(err))) },\n        ec\n      )\n  }\n\n  /**\n   * Builds an already complete `Future` from a `Try` value.\n   *\n   * ```typescript\n   * import { Success, Failure, Future } from \"funfix\"\n   *\n   * // Already completed with 1\n   * const f1 = Future.fromTry(Success(1))\n   *\n   * // Already completed in error\n   * const f2 = Future.fromTry(Failure(\"err\"))\n   * ```\n   *\n   * @param value is the `Try` value to stream in `onComplete` listeners\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static fromTry<A>(value: Try<A>, ec: Scheduler = Scheduler.global.get()): Future<A> {\n    return new PureFuture(value, ec)\n  }\n\n  /**\n   * Creates a race condition between multiple futures, returning the result\n   * of the first one that completes, cancelling the rest.\n   *\n   * ```typescript\n   * const failure = Future.raise(new TimeoutError()).delayResult(2000)\n   *\n   * // Will yield 1\n   * const fa1 = Future.of(() => 1).delayResult(1000)\n   * Future.firstCompletedOf([fa1, failure])\n   *\n   * // Will yield a TimeoutError\n   * const fa2 = Future.of(() => 1).delayResult(10000)\n   * Future.firstCompletedOf([fa2, failure])\n   * ```\n   *\n   * @param list is the list of futures for which the race is started\n   * @param ec is the scheduler doing the needed scheduling and error reporting\n   *\n   * @return a future that will complete with the result of the first\n   *         future form the list to complete, the rest being cancelled\n   */\n  static firstCompletedOf<A>(list: Future<A>[] | Iterable<Future<A>>, ec: Scheduler = Scheduler.global.get()): Future<A> {\n    return futureFirstCompletedOf(list, ec)\n  }\n\n  /**\n   * Given a list of items, builds future results out of it with the specified\n   * mapping function and returns a new future that's going to be completed\n   * with the list of all generated results.\n   *\n   * This is the generic version of {@link Future.sequence}. Useful for\n   * processing futures in parallel, with the `parallelism` factor being\n   * configurable.\n   *\n   * Example:\n   *\n   * ```typescript\n   * const list = [1, 2, 3, 4]\n   *\n   * // Yields [2, 4, 6, 8]\n   * Future.traverse(list)(a => Future.pure(a * 2))\n   * // ... is equivalent to:\n   * Future.sequence(list.map(_ => _ * 2))\n   * ```\n   *\n   * Note that the given `list` is strictly processed, so no lazy behavior\n   * should be expected if an `Iterable` is given.\n   *\n   * But in comparison with {@link Future.sequence}, this builder has lazy\n   * behavior in applying the given mapping function. Coupled with the\n   * `parallelism` factor, this can be used to do batched processing:\n   *\n   * ```typescript\n   * const userIDs = [1, 2, 3, 4]\n   *\n   * // Make at most 2 requests in parallel:\n   * Future.traverse(userIDs, 2)(fetchUserDetails)\n   * ```\n   *\n   * @param list are the values that get fed in the generator function for\n   *        building a list of future results\n   *\n   * @param parallelism is the maximum number of futures that are going to\n   *        be processed in parallel, defaults to `Infinity`\n   *\n   * @param ec is an optional scheduler that's going to be used for scheduling\n   *        the needed asynchronous boundaries\n   *\n   * @return a function that takes as parameter a the generator function that's\n   *         going to map the given `list`, transforming it into a list of\n   *         futures, finally returning a future that's going to complete\n   *         with the list of all asynchronously generated results\n   */\n  static traverse<A>(list: A[] | Iterable<A>, parallelism: number = Infinity, ec: Scheduler = Scheduler.global.get()):\n    <B>(f: (a: A) => Future<B>) => Future<B[]> {\n\n    return <B>(f: (a: A) => Future<B>) =>\n      futureTraverse(list, f, parallelism, ec)\n  }\n\n  /**\n   * Asynchronously transforms a list of futures into a future of a list.\n   *\n   * The equivalent of `Promise.all`, this is the specialized version of\n   * {@link Future.traverse}.\n   *\n   * Contract:\n   *\n   * - the given `Iterable<Future<A>>` list is eagerly evaluated, transformed\n   *   from the start into an `Array<Future<A>>`, so don't expect laziness in\n   *   evaluating it\n   * - In case one of the future fails, then all other futures that are still\n   *   pending get cancelled\n   * - In case the returned future gets cancelled, then all in-progress futures\n   *   from that list get cancelled\n   *\n   * Sample:\n   *\n   * ```typescript\n   * const f1 = Future.of(() => 1)\n   * const f2 = Future.of(() => 2)\n   * const f3 = Future.of(() => 3)\n   *\n   * // Yields [1, 2, 3]\n   * const all: Future<number[]> = Future.sequence([f1, f2, f3])\n   * ```\n   */\n  static sequence<A>(list: Future<A>[] | Iterable<Future<A>>, ec: Scheduler = Scheduler.global.get()): Future<A[]> {\n    return futureSequence(list, ec)\n  }\n\n  /**\n   * Maps 2 `Future` values by the mapping function, returning a new\n   * `Future` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link Future.sequence} operation and as such\n   * on cancellation or failure all future values get cancelled.\n   *\n   * ```typescript\n   * const fa1 = Future.of(() => 1)\n   * const fa2 = Future.of(() => 2)\n   *\n   *\n   * // Yields Success(3)\n   * Future.map2(fa1, fa2, (a, b) => a + b)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Future.map2(fa1, Future.raise(\"error\"),\n   *   (a, b) => a + b\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map2`.\n   */\n  static map2<A1, A2, R>(\n    fa1: Future<A1>, fa2: Future<A2>, f: (a1: A1, a2: A2) => R,\n    ec: Scheduler = Scheduler.global.get()): Future<R> {\n\n    const fl: Future<any[]> = Future.sequence([fa1, fa2] as any[], ec)\n    return fl.map(lst => f(lst[0], lst[1]))\n  }\n\n  /**\n   * Maps 3 `Future` values by the mapping function, returning a new\n   * `Future` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link Future.sequence} operation and as such\n   * on cancellation or failure all future values get cancelled.\n   *\n   * ```typescript\n   * const fa1 = Future.of(() => 1)\n   * const fa2 = Future.of(() => 2)\n   * const fa3 = Future.of(() => 3)\n   *\n   *\n   * // Yields Success(6)\n   * Future.map3(fa1, fa2, fa3, (a, b, c) => a + b + c)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Future.map3(\n   *   fa1, fa2, Future.raise(\"error\"),\n   *   (a, b, c) => a + b + c\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map3`.\n   */\n  static map3<A1, A2, A3, R>(\n    fa1: Future<A1>, fa2: Future<A2>, fa3: Future<A3>,\n    f: (a1: A1, a2: A2, a3: A3) => R,\n    ec: Scheduler = Scheduler.global.get()): Future<R> {\n\n    const fl: Future<any[]> = Future.sequence([fa1, fa2, fa3] as any[], ec)\n    return fl.map(lst => f(lst[0], lst[1], lst[2]))\n  }\n\n  /**\n   * Maps 4 `Future` values by the mapping function, returning a new\n   * `Future` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link Future.sequence} operation and as such\n   * on cancellation or failure all future values get cancelled.\n   *\n   * ```typescript\n   * const fa1 = Future.of(() => 1)\n   * const fa2 = Future.of(() => 2)\n   * const fa3 = Future.of(() => 3)\n   * const fa4 = Future.of(() => 4)\n   *\n   * // Yields Success(10)\n   * Future.map4(fa1, fa2, fa3, fa4, (a, b, c, d) => a + b + c + d)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Future.map4(\n   *   fa1, fa2, fa3, Future.raise(\"error\"),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map4`.\n   */\n  static map4<A1, A2, A3, A4, R>(\n    fa1: Future<A1>, fa2: Future<A2>, fa3: Future<A3>, fa4: Future<A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R,\n    ec: Scheduler = Scheduler.global.get()): Future<R> {\n\n    const fl: Future<any[]> = Future.sequence([fa1, fa2, fa3, fa4] as any[], ec)\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3]))\n  }\n\n  /**\n   * Maps 5 `Future` values by the mapping function, returning a new\n   * `Future` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link Future.sequence} operation and as such\n   * on cancellation or failure all future values get cancelled.\n   *\n   * ```typescript\n   * const fa1 = Future.of(() => 1)\n   * const fa2 = Future.of(() => 2)\n   * const fa3 = Future.of(() => 3)\n   * const fa4 = Future.of(() => 4)\n   * const fa5 = Future.of(() => 5)\n   *\n   * // Yields Success(15)\n   * Future.map5(fa1, fa2, fa3, fa4, fa5,\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Future.map5(\n   *   fa1, fa2, fa3, fa4, Future.raise(\"error\"),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map5`.\n   */\n  static map5<A1, A2, A3, A4, A5, R>(\n    fa1: Future<A1>, fa2: Future<A2>, fa3: Future<A3>, fa4: Future<A4>, fa5: Future<A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R,\n    ec: Scheduler = Scheduler.global.get()): Future<R> {\n\n    const fl: Future<any[]> = Future.sequence([fa1, fa2, fa3, fa4, fa5] as any[], ec)\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3], lst[4]))\n  }\n\n  /**\n   * Maps 6 `Future` values by the mapping function, returning a new\n   * `Future` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link Future.sequence} operation and as such\n   * on cancellation or failure all future values get cancelled.\n   *\n   * ```typescript\n   * const fa1 = Future.of(() => 1)\n   * const fa2 = Future.of(() => 2)\n   * const fa3 = Future.of(() => 3)\n   * const fa4 = Future.of(() => 4)\n   * const fa5 = Future.of(() => 5)\n   * const fa6 = Future.of(() => 6)\n   *\n   * // Yields Success(21)\n   * Future.map6(\n   *   fa1, fa2, fa3, fa4, fa5, fa6,\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Future.map6(\n   *   fa1, fa2, fa3, fa4, fa5, Future.raise(\"error\"),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map6`.\n   */\n  static map6<A1, A2, A3, A4, A5, A6, R>(\n    fa1: Future<A1>, fa2: Future<A2>, fa3: Future<A3>, fa4: Future<A4>, fa5: Future<A5>, fa6: Future<A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R,\n    ec: Scheduler = Scheduler.global.get()): Future<R> {\n\n    const fl: Future<any[]> = Future.sequence([fa1, fa2, fa3, fa4, fa5, fa6] as any[], ec)\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3], lst[4], lst[5]))\n  }\n}\n\nclass PureFuture<A> extends Future<A> {\n  constructor(\n    private readonly _value: Try<A>,\n    protected readonly _scheduler: Scheduler) { super() }\n\n  cancel(): void {}\n  value(): Option<Try<A>> { return Some(this._value) }\n\n  withScheduler(ec: Scheduler): Future<A> {\n    if (this._scheduler === ec) return this\n    return new PureFuture(this._value, ec)\n  }\n\n  onComplete(f: (a: Try<A>) => void): void {\n    this._scheduler.executeBatched(() => f(this._value))\n  }\n\n  transformWith<B>(failure: (e: Throwable) => Future<B>, success: (a: A) => Future<B>): Future<B> {\n    return genericTransformWith(this, failure, success, this._scheduler)\n  }\n\n  toPromise(): Promise<A> {\n    return this._value.fold(e => Promise.reject(e), a => Promise.resolve(a))\n  }\n}\n\n/**\n * Internal state shared between {@link AsyncFuture} and\n * {@link FutureMaker}.\n *\n * @Hidden\n */\nclass AsyncFutureState<A> {\n  id: null | \"chained\" | \"complete\"\n  ref: null | ((a: Try<A>) => void)[] | AsyncFutureState<A> | Try<A>\n\n  constructor() {\n    this.id = null\n    this.ref = null\n  }\n\n  compressedRoot(): AsyncFutureState<A> {\n    let cursor: AsyncFutureState<A> = this\n    while (cursor.id === \"chained\") {\n      cursor = cursor.ref as AsyncFutureState<A>\n      this.ref = cursor\n    }\n    return cursor\n  }\n\n  value(): Option<Try<A>> {\n    switch (this.id) {\n      case null: return None\n      case \"complete\":\n        return Some(this.ref as Try<A>)\n      case \"chained\":\n        return this.compressedRoot().value()\n    }\n  }\n\n  tryComplete(r: Try<A>, ec: Scheduler): boolean {\n    switch (this.id) {\n      case null:\n        const xs = (this.ref as (null | ((a: Try<A>) => void)[]))\n        this.ref = r\n        this.id = \"complete\"\n        if (xs) {\n          for (let i = 0; i < xs.length; i++)\n            ec.executeBatched(() => xs[i](r))\n        }\n        return true\n\n      case \"complete\":\n        return false\n\n      case \"chained\":\n        const ref = (this.ref as AsyncFutureState<A>).compressedRoot()\n        const result = ref.tryComplete(r, ec)\n        this.id = \"complete\"\n        this.ref = result ? r : ref.value().get()\n        return result\n    }\n  }\n\n  chainTo(target: AsyncFutureState<A>, ec: Scheduler): void {\n    switch (this.id) {\n      case null:\n        const xs = (this.ref as (null | ((a: Try<A>) => void)[]))\n        this.id = \"chained\"\n        this.ref = target.compressedRoot()\n\n        if (xs && xs.length > 0) {\n          // Transferring all listeners to chained future\n          for (let i = 0; i < xs.length; i++)\n            target.onComplete(xs[i], ec)\n        }\n        break\n\n      case \"chained\":\n        this.compressedRoot().chainTo(target.compressedRoot(), ec)\n        break\n\n      case \"complete\":\n        target.tryComplete(this.ref as Try<A>, ec)\n        break\n    }\n  }\n\n  onComplete(f: (a: Try<A>) => void, ec: Scheduler): void {\n    switch (this.id) {\n      case null:\n        if (!this.ref) this.ref = [];\n        (this.ref as ((a: Try<A>) => void)[]).push(f)\n        break\n      case \"complete\":\n        // Forced async boundary\n        ec.executeBatched(() => f(this.ref as Try<A>))\n        break\n      case \"chained\":\n        (this.ref as AsyncFutureState<A>).onComplete(f, ec)\n        break\n    }\n  }\n}\n\n/**\n * Internal `Future` implementation that's the result of a\n * {@link FutureMaker.future}.\n *\n * @Hidden\n */\nclass AsyncFuture<A> extends Future<A> {\n  readonly _state: AsyncFutureState<A>\n  readonly _scheduler: Scheduler\n  _cancelable?: ICancelable\n\n  constructor(state: AsyncFutureState<A>, cRef: ICancelable | undefined, ec: Scheduler) {\n    super()\n    this._state = state\n    this._scheduler = ec\n    if (cRef) this._cancelable = cRef\n  }\n\n  value(): Option<Try<A>> {\n    return this._state.value()\n  }\n\n  onComplete(f: (a: Try<A>) => void): void {\n    return this._state.onComplete(f, this._scheduler)\n  }\n\n  cancel(): void {\n    if (this._cancelable) {\n      try { this._cancelable.cancel() }\n      finally { delete this._cancelable }\n    }\n  }\n\n  withScheduler(ec: Scheduler): Future<A> {\n    if (this._scheduler === ec) return this\n    return new AsyncFuture(this._state, this._cancelable, ec)\n  }\n\n  transformWith<B>(failure: (e: Throwable) => Future<B>, success: (a: A) => Future<B>): Future<B> {\n    return genericTransformWith(this, failure, success, this._scheduler, this._cancelable)\n  }\n}\n\n/**\n * A write interface for {@link Future} to use when implementing\n * producers.\n *\n * This would be the equivalent of the now deprecated `Deferred`\n * data type in JavaScript.\n *\n * Example:\n *\n * ```typescript\n * import { Future, FutureMaker, Scheduler, Success } from \"funfix\"\n *\n * const ec = Scheduler.global.get()\n * const m = FutureMaker.empty<number>()\n *\n * // The producer\n * ec.scheduleOnce(1000, () => m.complete(Success(1)))\n *\n * // The future that will eventually complete when\n * // `m.complete` gets called\n * const f: Future<number> = maker.future()\n * ```\n */\nexport class FutureMaker<A> {\n  private readonly _state: AsyncFutureState<A>\n  private readonly _scheduler: Scheduler\n\n  private constructor(state: AsyncFutureState<A>, ec: Scheduler) {\n    this[\"_state\"] = state\n    this._scheduler = ec\n  }\n\n  /**\n   * Tries to complete this future builder either with a successful\n   * value or with a failure.\n   *\n   * This function can be used in concurrent races where multiple\n   * actors compete for completing the same `FutureMaker`.\n   *\n   * ```typescript\n   * const m = FutureMaker.empty<number>()\n   *\n   * m.tryComplete(Success(1)) //=> true\n   * m.tryComplete(Success(2)) //=> false\n   *\n   * m.future() //=> Yields 1\n   * ```\n   *\n   * In case you have a guarantee that the completion only\n   * happens once, then usage of {@link complete} is recommended.\n   *\n   * @return `false` in case the `FutureMaker` has been already\n   *         completed, or `true` otherwise\n   */\n  readonly tryComplete: (result: Try<A>) => boolean =\n    r => this[\"_state\"].tryComplete(r, this._scheduler)\n\n  /**\n   * Completes this `FutureMaker` either with a successful value or\n   * with a failure, but throws an exception if this maker was\n   * already completed.\n   *\n   * Due to throwing exceptions, this function is recommended for\n   * usage in cases where there's a guarantee that the completion\n   * of the `FutureMaker` is attempted only once.\n   *\n   * ```typescript\n   * const m = FutureMaker.empty<number>()\n   *\n   * m.complete(Success(1))\n   *\n   * m.complete(Success(2)) //=> throws IllegalStateError\n   * ```\n   *\n   * In case you have a concurrent race, see {@link tryComplete}\n   * for a version that does not throw exceptions.\n   */\n  readonly complete: (result: Try<A>) => void =\n    r => {\n      if (!this.tryComplete(r))\n        throw new IllegalStateError(\"Cannot complete a FutureMaker twice!\")\n    }\n\n  /**\n   * Alias for `tryComplete(Success(value))`.\n   *\n   * See {@link tryComplete}.\n   */\n  trySuccess(value: A): boolean {\n    return this.tryComplete(Success(value))\n  }\n\n  /**\n   * Alias for `complete(Success(value))`.\n   *\n   * See {@link complete}.\n   */\n  success(value: A): void {\n    return this.complete(Success(value))\n  }\n\n  /**\n   * Alias for `tryComplete(Failure(error))`.\n   *\n   * See {@link tryComplete}.\n   */\n  tryFailure(error: Throwable): boolean {\n    return this.tryComplete(Failure(error))\n  }\n\n  /**\n   * Alias for `complete(Failure(value))`.\n   *\n   * See {@link complete}.\n   */\n  failure(error: Throwable): void {\n    return this.complete(Failure(error))\n  }\n\n  /**\n   * Chains this to `target` such that any subsequent operations on\n   * this future maker is reflected on `target`.\n   *\n   * ```typescript\n   * const main = FutureMaker.empty<number>()\n   * const child = FutureMaker.empty<number>()\n   *\n   * // Now all operations on `child` will be redirected to `main`\n   * child.chainTo(main)\n   *\n   * // Completing `child` will complete `main`\n   * child.complete(Success(1))\n   *\n   * main.future() //=> Yields 1\n   * child.future() //=> Yields 1\n   * ```\n   *\n   * The purpose of this method is the same as with\n   * {@link ChainedCancelable}, to be used in pieces of logic where\n   * the chaining of `onComplete` calls creates a memory leaks,\n   * chaining being used to get rid of such chains.\n   *\n   * This method is being used in the implementation of\n   * {@link Future.flatMap} for example to make it memory safe.\n   *\n   * CREDITS: this was inspired by Scala's `scala.concurrent.Scala`\n   * implementation.\n   */\n  chainTo(target: FutureMaker<A>): void {\n    this[\"_state\"].chainTo(target[\"_state\"], this._scheduler)\n  }\n\n  /**\n   * Creates and returns a {@link Future} that will complete when this\n   * future maker is completed.\n   *\n   * ```typescript\n   * const m = FutureMaker.empty<number>()\n   *\n   * // Creates a simple future, no cancellation logic:\n   * m.future()\n   *\n   * // Creates a future with baked in cancellation logic:\n   * const cRef = Cancelable.of(() => console.log(\"Cancelled!\"))\n   * m.future(cRef)\n   * ```\n   *\n   * @param cancelable is an optional reference that can indicate\n   *        cancellation logic to be baked into the created future\n   */\n  future(cancelable?: ICancelable): Future<A> {\n    switch (this._state.id) {\n      case \"complete\":\n        return new PureFuture(this[\"_state\"].ref as Try<A>, this._scheduler)\n      default:\n        return new AsyncFuture(this[\"_state\"], cancelable, this._scheduler)\n    }\n  }\n\n  /**\n   * Returns a new `FutureMaker` that mirrors the state of the source,\n   * but that uses the given {@link Scheduler} reference for\n   * managing the required async boundaries.\n   *\n   * The given `Scheduler` reference is used for inserting async\n   * boundaries when the registered listeners are triggered when\n   * [.complete]{@link complete} is called or for data transformations\n   * executed on the future references returned by\n   * [.future]{@link FutureMaker.future}.\n   *\n   * See {@link Future.withScheduler}.\n   */\n  withScheduler(ec: Scheduler): FutureMaker<A> {\n    if (this._scheduler === ec) return this\n    return new FutureMaker(this._state, ec)\n  }\n\n  /**\n   * Returns an empty `FutureMaker` reference awaiting completion.\n   *\n   * This is the builder that one should use for building\n   * `FutureMaker` instances, since the default constructor is not\n   * exposed due to it exposing internal state.\n   */\n  static empty<A>(ec: Scheduler = Scheduler.global.get()): FutureMaker<A> {\n    return new FutureMaker(new AsyncFutureState(), ec)\n  }\n\n  /**\n   * Returns an already completed {@link FutureMaker} reference.\n   *\n   * Example:\n   *\n   * ```typescript\n   * const m = FutureMaker.completed(Success(1))\n   *\n   * m.future() // Yields 1\n   *\n   * m.complete(Success(2)) // Throws IllegalStateError\n   * ```\n   *\n   * If all you need is a `Future`, then use {@link Future.fromTry}\n   * instead.\n   */\n  static completed<A>(value: Try<A>, ec: Scheduler = Scheduler.global.get()): FutureMaker<A> {\n    const state = new AsyncFutureState<A>()\n    state.id = \"complete\"\n    state.ref = value\n    return new FutureMaker(state, ec)\n  }\n}\n\n/**\n * Internal, common `transformWith` implementation.\n *\n * @Hidden\n */\nfunction genericTransformWith<A, B>(\n  self: Future<A>,\n  failure: (e: Throwable) => Future<B>,\n  success: (a: A) => Future<B>,\n  scheduler: Scheduler,\n  cancelable?: ICancelable): Future<B> {\n\n  const defer = FutureMaker.empty<B>(scheduler)\n  const cRef = new ChainedCancelable(cancelable)\n\n  self.onComplete(tryA => {\n    let fb: Future<B>\n    try {\n      fb = tryA.fold(failure, success)\n    } catch (e) {\n      fb = Future.raise(e)\n    }\n\n    // If the resulting Future is already completed, there's no point\n    // in treating it as being cancelable\n    if (fb.value().isEmpty()) {\n      const fbb = fb as any\n      const cNext = fbb._cancelable\n\n      if (cNext && cNext instanceof ChainedCancelable) {\n        // Trick we are doing to get rid of extraneous memory\n        // allocations, otherwise we can leak memory\n        cNext.chainTo(cRef)\n      } else if (cNext && !(cNext instanceof DummyCancelable)) {\n        cRef.update(cNext)\n      }\n    } else {\n      // GC purposes\n      cRef.clear()\n    }\n\n    if (fb instanceof AsyncFuture) {\n      fb._state.chainTo(defer[\"_state\"] as AsyncFutureState<B>, scheduler)\n    } else {\n      (fb as Future<B>).onComplete(defer.tryComplete)\n    }\n  })\n\n  return defer.future(cRef)\n}\n\n/**\n * Internal, reusable function used in the implementation of {@link Future.then}.\n *\n * @Hidden\n */\nfunction promiseThen<T, R>(\n  f: ((t: T) => IPromiseLike<R> | R) | undefined | null,\n  alt: (t: T) => Future<T>,\n  ec: Scheduler):\n  ((value: T) => Future<R | T>) {\n\n  return value => {\n    if (typeof f !== \"function\") return alt(value)\n\n    const fb = f(value)\n    if (!fb) return Future.pure(value, ec)\n\n    if (typeof (fb as any).then === \"function\")\n      return Future.fromPromise(fb as IPromiseLike<R>, ec)\n    else\n      return Future.pure(fb as R, ec)\n  }\n}\n\n/** @Hidden */\nfunction futureCancelAll<A>(list: Future<A>[], ec: Scheduler, skip: number = -1): void {\n  const errors = []\n  for (let i = 0; i < list.length; i++) {\n    if (i !== skip)\n      try { list[i].cancel() } catch (e) { errors.push(e) }\n  }\n\n  if (errors.length > 0) {\n    for (const e of errors) ec.reportFailure(e)\n  }\n}\n\n/** @Hidden */\nfunction futureIterableToArray<A>(values: Future<A>[] | Iterable<Future<A>>, ec: Scheduler): Future<A>[] {\n  if (!values) return []\n  if (Object.prototype.toString.call(values) === \"[object Array]\")\n    return values as Future<A>[]\n\n  const arr: Future<A>[] = []\n  try {\n    const cursor = values[Symbol.iterator]()\n\n    while (true) {\n      const item = cursor.next()\n      if (item.value) arr.push(item.value)\n      if (item.done) break\n    }\n\n    return arr\n  } catch (e) {\n    futureCancelAll(arr, ec)\n    throw e\n  }\n}\n\n/**\n * Internal implementation for `Future.sequence`.\n *\n * @Hidden\n */\nfunction futureSequence<A>(values: Future<A>[] | Iterable<Future<A>>, ec: Scheduler): Future<A[]> {\n  return Future.create<A[]>(cb => {\n    try {\n      // This can throw, handling error below\n      const futures = futureIterableToArray(values, ec)\n      // Short-circuit in case the list is empty, otherwise the\n      // futureSequenceLoop fails (must be non-empty as an invariant)\n      if (futures.length === 0) return cb(Success([]))\n      const cRef = Cancelable.of(() => futureCancelAll(futures, ec))\n\n      // Creating race condition\n      let isDone = false\n      let finishedCount = 0\n      let finalArray: A[] = []\n\n      for (let index = 0; index < futures.length; index++) {\n        const fi = index\n        const fa = futures[index]\n\n        fa.onComplete(result => {\n          finishedCount += 1\n\n          if (result.isSuccess()) {\n            if (!isDone) {\n              finalArray[fi] = result.get()\n              isDone = finishedCount === futures.length\n              if (isDone) cb(Success(finalArray))\n            }\n          } else {\n            if (!isDone) {\n              isDone = true\n              cRef.cancel()\n              cb(result as any)\n            } else {\n              ec.reportFailure(result.failed().get())\n            }\n          }\n        })\n      }\n\n      return cRef\n    } catch (e) {\n      // If an error happens here, it means the conversion from iterable to\n      // array failed, and the futures we've seen are already canceled\n      cb(Failure(e))\n    }\n  }, ec)\n}\n\n/**\n * Internal implementation for `Future.firstCompletedOf`.\n *\n * @Hidden\n */\nfunction futureFirstCompletedOf<A>(iterable: Future<A>[] | Iterable<Future<A>>, ec: Scheduler): Future<A> {\n  return Future.create<A>(cb => {\n    try {\n      // This can throw, handling error below\n      const futures = futureIterableToArray(iterable, ec)\n      // Short-circuit in case the list is empty, otherwise the\n      // futureSequenceLoop fails (must be non-empty as an invariant)\n      if (futures.length === 0) return cb(Failure(new IllegalArgumentError(\"empty list of futures\")))\n\n      // Creating race condition\n      let isDone = false\n\n      for (let index = 0; index < futures.length; index++) {\n        const fi = index\n        const fa = futures[index]\n\n        fa.onComplete(result => {\n          if (!isDone) {\n            isDone = true\n            futureCancelAll(futures, ec, fi)\n            cb(result)\n          } else if (result.isFailure()) {\n            ec.reportFailure(result.failed().get())\n          }\n        })\n      }\n\n      return Cancelable.of(() => futureCancelAll(futures, ec))\n    } catch (e) {\n      // If an error happens here, it means the conversion from iterable to\n      // array failed, and the futures we've seen are already canceled\n      cb(Failure(e))\n    }\n  }, ec)\n}\n\n/**\n * Internal implementation for `Future.traverse`.\n *\n * @Hidden\n */\nfunction futureTraverse<A, B>(\n  list: A[] | Iterable<A>,\n  f: (a: A) => Future<B>,\n  parallelism: number,\n  ec: Scheduler): Future<B[]> {\n\n  if (parallelism <= 0) {\n    throw new IllegalArgumentError(`parallelism <= 0`)\n  }\n  return Future.of(() => iterableToArray(list), ec)\n    .flatMap(values => futureTraverseLoop(values, f, parallelism, ec, 0, []))\n}\n\n/** @Hidden */\nfunction futureTraverseLoop<A, B>(\n  list: A[],\n  f: (a: A) => Future<B>,\n  parallelism: number,\n  ec: Scheduler,\n  index: number,\n  result: B[]): Future<B[]> {\n\n  if (index >= list.length) return Future.pure(result, ec)\n  let batch: Future<B>[] = []\n  let length = 0\n\n  try {\n    while (index < list.length && length < parallelism) {\n      batch.push(f(list[index++]))\n      length += 1\n    }\n\n    const fa = Future.sequence(batch, ec).map(b => {\n      for (let i = 0; i < b.length; i++) result.push(b[i])\n    })\n\n    if (index >= list.length) {\n      // We are done, signal final result\n      return fa.map(_ => result)\n    } else {\n      // Continue with the next batch\n      return fa.flatMap(_ => futureTraverseLoop(list, f, parallelism, ec, index, result))\n    }\n  } catch (e) {\n    // Batch generation triggered an error\n    futureCancelAll(batch, ec)\n    return Future.raise(e)\n  }\n}\n"],"names":["cb","WrapFn","Empty","refs","CollectionCancelable","errors","c","cancel","e","push","length","CompositeError","thunk","ref","Cancelable","DummyCancelable","BoolWrapFn","BoolEmpty","AlreadyCanceledRef","_refs","cancelAll","BoolCancelable","canceled","AlreadyCanceledBoolCancelable","AlreadyCanceledAssignCancelableRef","MultiAssignCancelable","empty","of","value","AlreadyCanceledAssignCancelable","initial","_underlying","_canceled","undefined","SerialCancelable","_wasAssigned","IllegalStateError","SingleAssignCancelable","update","slice","pop","StackedCancelable","_chained","IllegalArgumentError","isCanceled","other","keepSearching","ref2","prev","ChainedCancelable","label","toUpperCase","C0","C1","C2","C3","C4","C5","C6","MIN","MAX","trunc","Math","x","isNaN","NaN","floor","ceil","d","m","over","duration","unit","toNanos","TimeUnit","NANOSECONDS","Nanoseconds","toMicros","MICROSECONDS","Microseconds","toMillis","MILLISECONDS","Milliseconds","toSeconds","SECONDS","Seconds","toMinutes","MINUTES","Minutes","toHours","HOURS","Hours","toDays","DAYS","Days","isFinite","convert","Duration","Infinity","negInf","inf","d1","d2","ord","convertTo","plus","negate","s","o","n","cmp","millis","fn","get","setL","_previous","bindL","oldFn","oldPrev","ta","DynamicRef","array","f","minIndex","maxIndex","index","current","next","search","values","Object","prototype","toString","call","cursor","Symbol","iterator","arr","item","done","lnOf2","log","maxPowerOf2","nr","bit","log2","em","executionModel","type","executeBatched","executeAsync","trampoline","modulus","recommendedBatchSize","r","batchIndex","initialDelay","delay","runnable","loop","self","delayNow","scheduleOnce","task","period","delayNowMs","periodMs","startAt","currentTimeMillis","elapsedMs","nextDelayMs","max","Scheduler","globalSchedulerRef","batchSize","nextPowerOf2","hashCodeOfString","ExecutionModel","batched","reporter","_isActive","_queue","_reporter","runLoop","canUseSetImmediate","global","reportFailure","_trampoline","Trampoline","_useSetImmediate","setImmediate","safeRunnable","setTimeout","NotImplementedError","execute","error","Date","now","ms","clearTimeout","GlobalScheduler","synchronous","bind","_stateRef","TestSchedulerState","updateTasks","_state","triggeredFailures","tasks","clock","state","scheduleAt","insertAt","tasksSearch","splice","filtered","ec2","TestScheduler","toExecute","jumpMs","executed","peek","random","elem","nextTaskJump","add","min","arrayBSearchInsertPos","failure","success","transformWith","Future","pure","_scheduler","a","transform","Left","Right","raise","onFulfilled","onRejected","ec","promiseThen","Promise","resolve","reject","onComplete","_","fold","delayedTick","flatMap","err","map","after","fb","TimeoutError","timeoutTo","fallback","lst","firstCompletedOf","FutureMaker","tryComplete","Try","future","PureFuture","Success","Failure","register","cRef","complete","ecAny","create","isRight","tailRecM","swap","withScheduler","then","list","futureFirstCompletedOf","parallelism","futureTraverse","futureSequence","fa1","fa2","fl","sequence","fa3","fa4","fa5","fa6","_value","Some","genericTransformWith","id","None","compressedRoot","xs","i","result","target","chainTo","_cancelable","AsyncFuture","cancelable","AsyncFutureState","scheduler","defer","tryA","isEmpty","fbb","cNext","clear","alt","fromPromise","skip","futures","futureIterableToArray","futureCancelAll","isDone","finishedCount","finalArray","fi","fa","isSuccess","failed","iterable","isFailure","iterableToArray","futureTraverseLoop","batch","b"],"mappings":"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"}