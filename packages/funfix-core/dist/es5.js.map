{"version":3,"file":"es5.js","sources":["../src/std.ts","../src/errors.ts","../src/disjunctions.ts"],"sourcesContent":["/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Interface for testing the equality of value objects.\n */\nexport interface IEquals<A> {\n  /**\n   * Indicates whether some other object is \"equal to\" this one.\n   *\n   * Properties:\n   *\n   *  - reflexive: for any value, `x.equals(x) == true`\n   *  - symmetric: for any values x and y, `x.equals(y) == y.equals(x)`\n   *  - transitive: `x.equals(y) && y.equals(z) => x.equals(z)`\n   *  - consistent: `x.equals(y)` always yields the same result\n   *\n   * Rule: equal objects MUST have equal hash codes!\n   */\n  equals(other: A): boolean\n\n  /**\n   * Returns a hash code value for this value.\n   *\n   * This method is supported for the benefit of hash tables.\n   *\n   * Properties:\n   *\n   *  - consistent: multiple invocations always yield the same result\n   *  - if `x.equals(y) == true` then `x.hashCode() == y.hashCode()`\n   *  - if `x.equals(y) == false` it is NOT required for their hash codes\n   *    to be equal, i.e. this function is not injective\n   */\n  hashCode(): number\n}\n\n/**\n * Test if the given reference is a value object.\n *\n * Value objects are objects that implement the [[IEquals]]\n * interface.\n *\n * @param ref is the reference to test\n */\nexport function isValueObject(ref: any): boolean {\n  return !!(ref &&\n    typeof ref.equals === \"function\" &&\n    typeof ref.hashCode === \"function\")\n}\n\n/**\n * Tests for universal equality.\n *\n * First attempting a reference check with `===`,\n * after which it tries to fallback on [[IEquals]], if the\n * left-hand side is implementing it.\n *\n * ```typescript\n * equals(10, 10) // true, because 10 === 10\n *\n * class Box implements IEquals<Box> {\n *   constructor(value: number) { this.value = value }\n *\n *   equals(other) { return this.value === other.value  }\n *   hashCode() { return this.value << 2 }\n * }\n *\n * // false, because they are not the same reference\n * new Box(10) === new Box(10)\n *\n * // true, because `Box#equals` gets called\n * equals(new Box(10), new Box(10))\n * ```\n */\nexport function is<A>(lh: A, rh: A): boolean {\n  if (lh === rh || (lh !== lh && rh !== rh)) {\n    return true\n  }\n  if (!lh || !rh) {\n    return false\n  }\n  /* istanbul ignore else */\n  /* tslint:disable-next-line:strict-type-predicates */\n  if (typeof lh.valueOf === \"function\" && typeof rh.valueOf === \"function\") {\n    const lh2 = lh.valueOf()\n    const rh2 = rh.valueOf()\n    if (lh2 === rh2 || (lh2 !== lh2 && rh2 !== rh2)) {\n      return true\n    }\n    if (!lh2 || !rh2) {\n      return false\n    }\n  }\n  // noinspection PointlessBooleanExpressionJS\n  return !!(\n    isValueObject(lh) &&\n    (lh as any).equals(rh)\n  )\n}\n\n/** Alias for [[is]]. */\nexport function equals<A>(lh: A, rh: A): boolean {\n  return is(lh, rh)\n}\n\n/**\n * Universal hash-code function.\n *\n * Depending on the given value, it calculates the hash-code like so:\n *\n *  1. if it's a `number`, then it gets truncated\n *     to an integer and returned\n *  2. if it's a \"value object\" (see [[isValueObject]]), then\n *     its `hashCode` is used\n *  3. if a `valueOf()` function is provided, then the\n *     `hashCode` gets recursively invoked on its result\n *  4. if all else fails, the value gets coerced to a `String`\n *     and a hash code is calculated using [[hashCodeOfString]]\n *\n * @param ref is the value to use for calculating a hash code\n * @return an integer with the aforementioned properties\n */\nexport function hashCode(ref: any): number {\n  if (typeof ref === \"number\") {\n    return ref & ref\n  }\n  /* istanbul ignore else */\n  if (typeof ref.valueOf === \"function\") {\n    const v = ref.valueOf()\n    if (v !== ref) return hashCode(v)\n  }\n  if (isValueObject(ref)) {\n    return (ref as IEquals<any>).hashCode()\n  }\n  return hashCodeOfString(String(ref))\n}\n\n/**\n * Calculates a hash code out of any string.\n */\nexport function hashCodeOfString(str: string): number {\n  let hash = 0\n  /* tslint:disable-next-line:strict-type-predicates */\n  if (str == null || str.length === 0) return hash\n  for (let i = 0; i < str.length; i++) {\n    const character = str.charCodeAt(i)\n    hash = ((hash << 5) - hash) + character\n    hash = hash & hash // Convert to 32bit integer\n  }\n  return hash\n}\n\n/** The identity function. */\nexport function id<A>(a: A): A {\n  return a\n}\n\n/**\n * Utility function for implementing mixins, based on the\n * [TypeScript Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * documentation.\n *\n * Sample:\n *\n * ```typescript\n * class Disposable { ... }\n * class Activatable { ... }\n * class SmartObject implements Disposable, Activatable { ... }\n *\n * applyMixins(SmartObject, [Disposable, Activatable]);\n * ```\n *\n * Using `implements` instead of `extends` for base classes\n * will make the type system treat them like interfaces instead of\n * classes. And by `applyMixins` we can also supply global\n * implementations for the non-abstract members.\n */\nexport function applyMixins(derivedCtor: {prototype: any}, baseCtors: {prototype: any}[]) {\n  baseCtors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      if (!derivedCtor.prototype[name])\n        derivedCtor.prototype[name] = baseCtor.prototype[name]\n    })\n  })\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Type alias for errors that can be thrown.\n *\n * Since in JavaScript any object can be thrown, the standard\n * `Error` class (capital `E`) is not useful as a type in signatures,\n * the needed type being effectively `any`, but we still need a type\n * alias for documentation purposes.\n *\n * And since `any` represents an untyped object that bypasses the\n * type system, Funfix is using `Object` for TypeScript and `mixed`\n * for Flow to represent such throwables.\n */\nexport type Throwable = Error | Object\n\n/**\n * A composite error represents a list of errors that were caught\n * while executing logic which delays re-throwing of errors.\n */\nexport class CompositeError extends Error {\n  private errorsRef: Array<Throwable>\n\n  constructor(errors: Array<Throwable>) {\n    let reasons = \"\"\n    for (const e of errors.slice(0, 2)) {\n      let message = \"\"\n      if (e instanceof Error) {\n        message = `${e.name}(${e.message})`\n      } else {\n        message = `${e}`\n      }\n      reasons += \", \" + message\n    }\n\n    reasons = reasons.slice(2)\n    if (errors.length > 2) reasons = reasons + \", ...\"\n    super(reasons)\n\n    this.name = \"CompositeError\"\n    this.errorsRef = errors\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = CompositeError\n    self.__proto__ = CompositeError.prototype\n  }\n\n  /**\n   * Returns the full list of caught errors.\n   */\n  public errors(): Array<Throwable> { return this.errorsRef.slice() }\n}\n\n/**\n * A dummy error that can be used for testing purposes.\n */\nexport class DummyError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"DummyError\"\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = DummyError\n    self.__proto__ = DummyError.prototype\n  }\n}\n\n/**\n * Thrown by various accessor methods or partial functions to indicate\n * that the element being requested does not exist.\n */\nexport class NoSuchElementError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"NoSuchElementError\"\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = NoSuchElementError\n    self.__proto__ = NoSuchElementError.prototype\n  }\n}\n\n/**\n * Error throw in class constructors by implementations that\n * are sealed or final.\n */\nexport class IllegalInheritanceError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"IllegalInheritanceError\"\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = IllegalInheritanceError\n    self.__proto__ = IllegalInheritanceError.prototype\n  }\n}\n\n/**\n * Signals that a function has been invoked at an illegal\n * or inappropriate time.\n *\n * In other words, environment or application is not in an\n * appropriate state for the requested operation.\n */\nexport class IllegalStateError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"IllegalStateError\"\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = IllegalStateError\n    self.__proto__ = IllegalStateError.prototype\n  }\n}\n\n/**\n * Signals that a function has been invoked with illegal\n * arguments.\n */\nexport class IllegalArgumentError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"IllegalArgumentError\"\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = IllegalArgumentError\n    self.__proto__ = IllegalArgumentError.prototype\n  }\n}\n\n/**\n * Signals that a function or a method is missing an implementation,\n * which should be provided in the future.\n */\nexport class NotImplementedError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"NotImplementedError\"\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = NotImplementedError\n    self.__proto__ = NotImplementedError.prototype\n  }\n}\n\n/**\n * Signals that completion of a procedure took longer than anticipated.\n */\nexport class TimeoutError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"TimeoutError\"\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = TimeoutError\n    self.__proto__ = TimeoutError.prototype\n  }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as std from \"./std\"\nimport { Throwable, NoSuchElementError } from \"./errors\"\n\n/**\n * Represents a value of one of two possible types (a disjoint union).\n *\n * A common use of Either is as an alternative to [[Option]] for dealing\n * with possible missing values. In this usage [[Option.none]] is replaced\n * with [[Either.left]] which can contain useful information and\n * [[Option.some]] is replaced with [[Either.right]].\n *\n * Convention dictates that `left` is used for failure and `right` is used\n * for success. Note that this `Either` type is right-biased, meaning that\n * operations such as `map`, `flatMap` and `filter` work on the `right` value\n * and if you want to work on the `left` value, then you need to do a `swap`.\n *\n * For example, you could use `Either<String, Int>` to detect whether an\n * input is a string or an number:\n *\n * ```typescript\n * function tryParseInt(str: string): Either<string, number> {\n *   const i = parseInt(value)\n *   return isNaN(i) ? Left(str) : Right(i)\n * }\n *\n * const result = tryParseInt(\"not an int\")\n * if (result.isRight()) {\n *   console.log(`Increment: ${result.get}`)\n * } else {\n *   console.log(`ERROR: could not parse ${result.swap.get}`)\n * }\n * ```\n *\n * @final\n */\nexport class Either<L, R> implements std.IEquals<Either<L, R>> {\n  private _isRight: boolean\n  private _rightRef: R\n  private _leftRef: L\n\n  private constructor(_leftRef: L, _rightRef: R, _isRight: boolean) {\n    this._isRight = _isRight\n    if (_isRight) this._rightRef = _rightRef\n    else this._leftRef = _leftRef\n  }\n\n  /**\n   * Returns `true` if this is a `left`, `false` otherwise.\n   *\n   * ```typescript\n   * Left(\"hello\").isLeft() // true\n   * Right(10).isLeft() // false\n   * ```\n   */\n  isLeft(): boolean { return !this._isRight }\n\n  /**\n   * Returns `true` if this is a `right`, `false` otherwise.\n   *\n   * ```typescript\n   * Left(\"hello\").isRight() // false\n   * Right(10).isRight() // true\n   * ```\n   */\n  isRight(): boolean { return this._isRight }\n\n  /**\n   * Returns true if this is a Right and its value is equal to `elem`\n   * (as determined by the `equals` protocol), returns `false` otherwise.\n   *\n   * ```typescript\n   * // True\n   * Right(\"something\").contains(\"something\")\n   *\n   * // False because the values are different\n   * Right(\"something\").contains(\"anything\") // false\n   *\n   * // False because the source is a `left`\n   * Left(\"something\").contains(\"something\") // false\n   * ```\n   */\n  contains(elem: R): boolean {\n    return this._isRight && std.is(this._rightRef, elem)\n  }\n\n  /**\n   * Returns `false` if the source is a `left`, or returns the result\n   * of the application of the given predicate to the `right` value.\n   *\n   * ```typescript\n   * // True, because it is a right and predicate holds\n   * Right(20).exists(n => n > 10)\n   *\n   * // False, because the predicate returns false\n   * Right(10).exists(n => n % 2 != 0)\n   *\n   * // False, because it is a left\n   * Left(10).exists(n => n == 10)\n   * ```\n   */\n  exists(p: (r: R) => boolean): boolean {\n    return this._isRight && p(this._rightRef)\n  }\n\n  /**\n   * Filters `right` values with the given predicate, returning\n   * the value generated by `zero` in case the source is a `right`\n   * value and the predicate doesn't hold.\n   *\n   * Possible outcomes:\n   *\n   *  - Returns the existing value of `right` if this is a `right` value and the\n   *    given predicate `p` holds for it\n   *  - Returns `Left(zero())` if this is a `right` value\n   *    and the given predicate `p` does not hold\n   *  - Returns the current \"left\" value, if the source is a `Left`\n   *\n   * ```typescript\n   * Right(12).filterOrElse(x => x > 10, () => -1) // Right(12)\n   * Right(7).filterOrElse(x => x > 10, () => -1)  // Left(-1)\n   * Left(7).filterOrElse(x => false, () => -1)    // Left(7)\n   * ```\n   */\n  filterOrElse(p: (r: R) => boolean, zero: () => L): Either<L, R> {\n    return this._isRight\n      ? (p(this._rightRef) ? (this as any) : Left(zero()))\n      : (this as any)\n  }\n\n  /**\n   * Binds the given function across `right` values.\n   *\n   * This operation is the monadic \"bind\" operation.\n   * It can be used to *chain* multiple `Either` references.\n   */\n  flatMap<S>(f: (r: R) => Either<L, S>): Either<L, S> {\n    return this._isRight ? f(this._rightRef) : (this as any)\n  }\n\n  /**\n   * Applies the `left` function to [[Left]] values, and the\n   * `right` function to [[Right]] values and returns the result.\n   *\n   * ```typescript\n   * const maybeNum: Either<string, number> =\n   *   tryParseInt(\"not a number\")\n   *\n   * const result: string =\n   *   maybeNum.fold(\n   *     str => `Could not parse string: ${str}`,\n   *     num => `Success: ${num}`\n   *   )\n   * ```\n   */\n  fold<S>(left: (l: L) => S, right: (r: R) => S): S {\n    return this._isRight ? right(this._rightRef) : left(this._leftRef)\n  }\n\n  /**\n   * Returns true if the source is a `left` or returns\n   * the result of the application of the given predicate to the\n   * `right` value.\n   *\n   * ```typescript\n   * // True, because it is a `left`\n   * Left(\"hello\").forAll(x => x > 10)\n   *\n   * // True, because the predicate holds\n   * Right(20).forAll(x => x > 10)\n   *\n   * // False, it's a right and the predicate doesn't hold\n   * Right(7).forAll(x => x > 10)\n   * ```\n   */\n  forAll(p: (r: R) => boolean): boolean {\n    return !this._isRight || p(this._rightRef)\n  }\n\n  /**\n   * Returns the `Right` value, if the source has one,\n   * otherwise throws an exception.\n   *\n   * WARNING!\n   *\n   * This function is partial, the `Either` must be a `Right`, otherwise\n   * a runtime exception will get thrown. Use with care.\n   *\n   * @throws [[NoSuchElementError]] in case the the `Either` is a `Left`\n   */\n  get(): R {\n    if (this._isRight) return this._rightRef\n    throw new NoSuchElementError(\"left.get()\")\n  }\n\n  /**\n   * Returns the value from this `right` or the given `fallback`\n   * value if this is a `left`.\n   *\n   * ```typescript\n   * Right(10).getOrElse(27) // 10\n   * Left(10).getOrElse(27)  // 27\n   * ```\n   */\n  getOrElse<RR>(fallback: RR): R | RR {\n    return this._isRight ? this._rightRef : fallback\n  }\n\n  /**\n   * Returns the value from this `right` or a value generated\n   * by the given `thunk` if this is a `left`.\n   *\n   * ```typescript\n   * Right(10).getOrElseL(() => 27) // 10\n   * Left(10).getOrElseL(() => 27)  // 27\n   * ```\n   */\n  getOrElseL<RR>(thunk: () => RR): R | RR {\n    return this._isRight ? this._rightRef : thunk()\n  }\n\n  /**\n   * Transform the source if it is a `right` with the given\n   * mapping function.\n   *\n   * ```typescript\n   * Right(10).map(x => x + 17) // right(27)\n   * Left(10).map(x => x + 17)  // left(10)\n   * ```\n   */\n  map<C>(f: (r: R) => C): Either<L, C> {\n    return this._isRight\n      ? Right(f(this._rightRef))\n      : (this as any)\n  }\n\n  /**\n   * Executes the given side-effecting function if the\n   * source is a `right` value.\n   *\n   * ```typescript\n   * Right(12).forAll(console.log) // prints 12\n   * Left(10).forAll(console.log)  // silent\n   * ```\n   */\n  forEach(cb: (r: R) => void): void {\n    if (this._isRight) cb(this._rightRef)\n  }\n\n  /**\n   * If this is a `left`, then return the left value as a `right`\n   * or vice versa.\n   *\n   * ```typescript\n   * Right(10).swap() // left(10)\n   * Left(20).swap()  // right(20)\n   * ```\n   */\n  swap(): Either<R, L> {\n    return this._isRight\n      ? Left(this._rightRef)\n      : Right(this._leftRef)\n  }\n\n  /**\n   * Returns an `Option.some(right)` if the source is a `right` value,\n   * or `Option.none` in case the source is a `left` value.\n   */\n  toOption(): Option<R> {\n    return this._isRight\n      ? Option.some(this._rightRef)\n      : Option.none()\n  }\n\n  /** Implements {@link IEquals.equals}. */\n  equals(other: Either<L, R>): boolean {\n    // tslint:disable-next-line:strict-type-predicates\n    if (other == null) return false\n    if (this._isRight) return std.is(this._rightRef, other._rightRef)\n    return std.is(this._leftRef, other._leftRef)\n  }\n\n  /** Implements {@link IEquals.hashCode}. */\n  hashCode(): number {\n    return this._isRight\n      ? std.hashCode(this._rightRef) << 2\n      : std.hashCode(this._leftRef) << 3\n  }\n\n  // Implements HK<F, A>\n  /** @hidden */ readonly _funKindF: Either<L, any>\n  /** @hidden */ readonly _funKindA: R\n\n  // Implements Constructor<T>\n  /** @hidden */ static readonly _funErasure: Either<any, any>\n\n  static left<L, R>(value: L): Either<L, R> {\n    return Left(value)\n  }\n\n  static right<L, R>(value: R): Either<L, R> {\n    return Right(value)\n  }\n\n  /**\n   * Maps 2 `Either` values by the mapping function, returning a new\n   * `Either` reference that is a `Right` only if both `Either` values are\n   * `Right` values, otherwise it returns the first `Left` value noticed.\n   *\n   * ```typescript\n   * // Yields Right(3)\n   * Try.map2(Right(1), Right(2),\n   *   (a, b) => a + b\n   * )\n   *\n   * // Yields Left, because the second arg is a Left\n   * Try.map2(Right(1), Left(\"error\"),\n   *   (a, b) => a + b\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map2`.\n   */\n  static map2<A1,A2,L,R>(fa1: Either<L,A1>, fa2: Either<L,A2>,\n                         f: (a1: A1, a2: A2) => R): Either<L, R> {\n\n    if (fa1.isLeft()) return ((fa1 as any) as Either<L, R>)\n    if (fa2.isLeft()) return ((fa2 as any) as Either<L, R>)\n    return Right(f(fa1._rightRef, fa2._rightRef))\n  }\n\n  /**\n   * Maps 3 `Either` values by the mapping function, returning a new\n   * `Either` reference that is a `Right` only if all 3 `Either` values are\n   * `Right` values, otherwise it returns the first `Left` value noticed.\n   *\n   * ```typescript\n   * // Yields Right(6)\n   * Try.map3(Right(1), Right(2), Right(3),\n   *   (a, b, c) => a + b + c\n   * )\n   *\n   * // Yields Left, because the second arg is a Left\n   * Try.map3(Right(1), Left(\"error\"), Right(3),\n   *   (a, b, c) => a + b + c\n   * )\n   * ```\n   */\n  static map3<A1,A2,A3,L,R>(\n    fa1: Either<L,A1>, fa2: Either<L,A2>, fa3: Either<L,A3>,\n    f: (a1: A1, a2: A2, a3: A3) => R): Either<L, R> {\n\n    if (fa1.isLeft()) return ((fa1 as any) as Either<L, R>)\n    if (fa2.isLeft()) return ((fa2 as any) as Either<L, R>)\n    if (fa3.isLeft()) return ((fa3 as any) as Either<L, R>)\n    return Right(f(fa1._rightRef, fa2._rightRef, fa3._rightRef))\n  }\n\n  /**\n   * Maps 4 `Either` values by the mapping function, returning a new\n   * `Either` reference that is a `Right` only if all 4 `Either` values are\n   * `Right` values, otherwise it returns the first `Left` value noticed.\n   *\n   * ```typescript\n   * // Yields Right(10)\n   * Try.map4(Right(1), Right(2), Right(3), Right(4),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   *\n   * // Yields Left, because the second arg is a Left\n   * Try.map4(Right(1), Left(\"error\"), Right(3), Right(4),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   * ```\n   */\n  static map4<A1,A2,A3,A4,L,R>(\n    fa1: Either<L,A1>, fa2: Either<L,A2>, fa3: Either<L,A3>, fa4: Either<L,A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R): Either<L, R> {\n\n    if (fa1.isLeft()) return ((fa1 as any) as Either<L, R>)\n    if (fa2.isLeft()) return ((fa2 as any) as Either<L, R>)\n    if (fa3.isLeft()) return ((fa3 as any) as Either<L, R>)\n    if (fa4.isLeft()) return ((fa4 as any) as Either<L, R>)\n    return Right(f(fa1._rightRef, fa2._rightRef, fa3._rightRef, fa4._rightRef))\n  }\n\n  /**\n   * Maps 5 `Either` values by the mapping function, returning a new\n   * `Either` reference that is a `Right` only if all 5 `Either` values are\n   * `Right` values, otherwise it returns the first `Left` value noticed.\n   *\n   * ```typescript\n   * // Yields Right(15)\n   * Try.map5(Right(1), Right(2), Right(3), Right(4), Right(5),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   *\n   * // Yields Left, because the second arg is a Left\n   * Try.map5(Right(1), Left(\"error\"), Right(3), Right(4), Right(5),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   * ```\n   */\n  static map5<A1,A2,A3,A4,A5,L,R>(\n    fa1: Either<L,A1>, fa2: Either<L,A2>, fa3: Either<L,A3>, fa4: Either<L,A4>, fa5: Either<L,A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R): Either<L, R> {\n\n    if (fa1.isLeft()) return ((fa1 as any) as Either<L, R>)\n    if (fa2.isLeft()) return ((fa2 as any) as Either<L, R>)\n    if (fa3.isLeft()) return ((fa3 as any) as Either<L, R>)\n    if (fa4.isLeft()) return ((fa4 as any) as Either<L, R>)\n    if (fa5.isLeft()) return ((fa5 as any) as Either<L, R>)\n    return Right(f(fa1._rightRef, fa2._rightRef, fa3._rightRef, fa4._rightRef, fa5._rightRef))\n  }\n\n  /**\n   * Maps 6 `Either` values by the mapping function, returning a new\n   * `Either` reference that is a `Right` only if all 6 `Either` values are\n   * `Right` values, otherwise it returns the first `Left` value noticed.\n   *\n   * ```typescript\n   * // Yields Right(21)\n   * Try.map5(Right(1), Right(2), Right(3), Right(4), Right(5), Right(6),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   *\n   * // Yields Left, because the second arg is a Left\n   * Try.map5(Right(1), Left(\"error\"), Right(3), Right(4), Right(5), Right(6),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   * ```\n   */\n  static map6<A1,A2,A3,A4,A5,A6,L,R>(\n    fa1: Either<L,A1>, fa2: Either<L,A2>, fa3: Either<L,A3>, fa4: Either<L,A4>, fa5: Either<L,A5>, fa6: Either<L,A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R): Either<L, R> {\n\n    if (fa1.isLeft()) return ((fa1 as any) as Either<L, R>)\n    if (fa2.isLeft()) return ((fa2 as any) as Either<L, R>)\n    if (fa3.isLeft()) return ((fa3 as any) as Either<L, R>)\n    if (fa4.isLeft()) return ((fa4 as any) as Either<L, R>)\n    if (fa5.isLeft()) return ((fa5 as any) as Either<L, R>)\n    if (fa6.isLeft()) return ((fa6 as any) as Either<L, R>)\n    return Right(f(fa1._rightRef, fa2._rightRef, fa3._rightRef, fa4._rightRef, fa5._rightRef, fa6._rightRef))\n  }\n\n  /**\n   * Keeps calling `f` until a `Right(b)` is returned.\n   *\n   * Based on Phil Freeman's\n   * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.\n   *\n   * Described in `FlatMap.tailRecM`.\n   */\n  static tailRecM<L, A, B>(a: A, f: (a: A) => Either<L, Either<A, B>>): Either<L, B> {\n    let cursor = a\n    while (true) {\n      const result = f(cursor)\n      if (result.isLeft()) return result as any\n\n      const some = result.get()\n      if (some.isRight()) return Right(some.get())\n      cursor = some.swap().get()\n    }\n  }\n}\n\n/**\n * The `Left` data constructor represents the left side of the\n * [[Either]] disjoint union, as opposed to the [[Right]] side.\n */\nexport function Left<L>(value: L): Either<L, never> {\n  return new (Either as any)(value, null as never, false)\n}\n\n/**\n * The `Right` data constructor represents the right side of the\n * [[Either]] disjoint union, as opposed to the [[Left]] side.\n */\nexport function Right<R>(value: R): Either<never, R> {\n  return new (Either as any)(null as never, value, true)\n}\n\n/**\n * Represents optional values, inspired by Scala's `Option` and by\n * Haskell's `Maybe` data types.\n *\n * Option is an immutable data type, represented as a sum type, being\n * either a [[Some]], in case it contains a single element, or a [[None]],\n * in case it is empty.\n *\n * The most idiomatic way to use an `Option` instance is to treat it\n * as a collection or monad and use `map`,`flatMap`, `filter`,\n * or `forEach`.\n *\n * @final\n */\nexport class Option<A> implements std.IEquals<Option<A>> {\n  // tslint:disable-next-line:variable-name\n  private _isEmpty: boolean\n  private _ref: A\n\n  private constructor(ref: A, isEmpty?: boolean) {\n    /* tslint:disable-next-line:strict-type-predicates */\n    this._isEmpty = isEmpty != null ? isEmpty : (ref === null || ref === undefined)\n    this._ref = ref\n  }\n\n  /**\n   * Returns the option's value.\n   *\n   * WARNING!\n   *\n   * This function is partial, the option must be non-empty, otherwise\n   * a runtime exception will get thrown. Use with care.\n   *\n   * @throws [[NoSuchElementError]] in case the option is empty\n   */\n  get(): A {\n    if (!this._isEmpty) return this._ref\n    else throw new NoSuchElementError(\"Option.get\")\n  }\n\n  /**\n   * Returns the option's value if the option is nonempty, otherwise\n   * return the given `fallback`.\n   *\n   * See [[Option.getOrElseL]] for a lazy alternative.\n   */\n  getOrElse<AA>(fallback: AA): A | AA {\n    if (!this._isEmpty) return this._ref\n    else return fallback\n  }\n\n  /**\n   * Returns the option's value if the option is nonempty, otherwise\n   * return `null`.\n   * ```\n   */\n  orNull(): A | null {\n    return !this._isEmpty ? this._ref : null\n  }\n\n  /**\n   * Returns the option's value if the option is nonempty, otherwise\n   * return `undefined`.\n   */\n  orUndefined(): A | undefined {\n    return !this._isEmpty ? this._ref : undefined\n  }\n\n  /**\n   * Returns the option's value if the option is nonempty, otherwise\n   * return the result of evaluating `thunk`.\n   *\n   * See [[Option.getOrElse]] for a strict alternative.\n   */\n  getOrElseL<AA>(thunk: () => AA): A | AA {\n    if (!this._isEmpty) return this._ref\n    else return thunk()\n  }\n\n  /**\n   * Returns this option if it is nonempty, otherwise returns the\n   * given `fallback`.\n   */\n  orElse<AA>(fallback: Option<AA>): Option<A | AA> {\n    if (!this._isEmpty) return this\n    else return fallback\n  }\n\n  /**\n   * Returns this option if it is nonempty, otherwise returns the\n   * given result of evaluating the given `thunk`.\n   *\n   * @param thunk a no-params function that gets evaluated and\n   *        whose result is returned in case this option is empty\n   */\n  orElseL<AA>(thunk: () => Option<AA>): Option<A | AA> {\n    if (!this._isEmpty) return this\n    else return thunk()\n  }\n\n  /**\n   * Returns `true` if the option is empty, `false` otherwise.\n   */\n  isEmpty(): boolean { return this._isEmpty }\n\n  /**\n   * Returns `true` if the option is not empty, `false` otherwise.\n   */\n  nonEmpty(): boolean { return !this._isEmpty }\n\n  /**\n   * Returns an option containing the result of applying `f` to\n   * this option's value, or an empty option if the source is empty.\n   *\n   * NOTE: this is similar with `flatMap`, except with `map` the\n   * result of `f` doesn't need to be wrapped in an `Option`.\n   *\n   * @param f the mapping function that will transform the value\n   *          of this option if nonempty.\n   *\n   * @return a new option instance containing the value of the\n   *         source mapped by the given function\n   */\n  map<B>(f: (a: A) => B): Option<B> {\n    return this._isEmpty ? None : Some(f(this._ref))\n  }\n\n  /**\n   * Returns an optioning containing the result of the source mapped\n   * by the given function `f`.\n   *\n   * Similar to `map`, except that if the mapping function `f` returns\n   * `null`, then the final result returned will be [[Option.none]].\n   *\n   * Comparison:\n   *\n   * ```typescript\n   * Option.of(1).mapN(x => null) // None\n   * Option.of(1).map(x => null)  // Some(null)\n   *\n   * Option.of(1).mapN(x => x+1)  // 2\n   * Option.of(1).map(x => x+1)   // 2\n   * ```\n   *\n   * What this operation does is to allow for safe chaining of multiple\n   * method calls or functions that might produce `null` results:\n   *\n   * ```typescript\n   * Option.of(user)\n   *   .mapN(_ => _.contacts)\n   *   .mapN(_ => _.length)\n   * ```\n   */\n  mapN<B>(f: (a: A) => B | null | undefined): Option<B> {\n    return this._isEmpty ? None : Option.of(f(this._ref))\n  }\n\n  /**\n   * Returns the result of applying `f` to this option's value if\n   * the option is nonempty, otherwise returns an empty option.\n   *\n   * NOTE: this is similar with `map`, except that `flatMap` the\n   * result returned by `f` is expected to be boxed in an `Option`\n   * already.\n   *\n   * Example:\n   *\n   * ```typescript\n   * const opt = Option.of(10)\n   *\n   * opt.flatMap(num => {\n   *   if (num % 2 == 0)\n   *     Some(num + 1)\n   *   else\n   *     None\n   * })\n   * ```\n   *\n   * @param f the mapping function that will transform the value\n   *          of this option if nonempty.\n   *\n   * @return a new option instance containing the value of the\n   *         source mapped by the given function\n   */\n  flatMap<B>(f: (a: A) => Option<B>): Option<B> {\n    if (this._isEmpty) return None\n    else return f(this._ref)\n  }\n\n  /** Alias for [[flatMap]]. */\n  chain<B>(f: (a: A) => Option<B>): Option<B> {\n    return this.flatMap(f)\n  }\n\n  /**\n   * Returns this option if it is nonempty AND applying the\n   * predicate `p` to the underlying value yields `true`,\n   * otherwise return an empty option.\n   *\n   * @param p is the predicate function that is used to\n   *        apply filtering on the option's value\n   *\n   * @return a new option instance containing the value of the\n   *         source filtered with the given predicate\n   */\n  filter(p: (a: A) => boolean): Option<A> {\n    if (this._isEmpty || !p(this._ref)) return None\n    else return this\n  }\n\n  /**\n   * Returns the result of applying `f` to this option's value,\n   * or in case the option is empty, the return the result of\n   * evaluating the `fallback` function.\n   *\n   * This function is equivalent with:\n   *\n   * ```typescript\n   * opt.map(f).getOrElseL(fallback)\n   * ```\n   *\n   * @param fallback is the function to be evaluated in case this\n   *        option is empty\n   *\n   * @param f is the mapping function for transforming this option's\n   *        value in case it is nonempty\n   */\n  fold<B>(fallback: () => B, f: (a: A) => B): B {\n    if (this._isEmpty) return fallback()\n    else return f(this._ref)\n  }\n\n  /**\n   * Returns true if this option is nonempty and the value it\n   * holds is equal to the given `elem`.\n   */\n  contains(elem: A): boolean {\n    return !this._isEmpty && std.is(this._ref, elem)\n  }\n\n  /**\n   * Returns `true` if this option is nonempty and the given\n   * predicate returns `true` when applied on this option's value.\n   *\n   * @param p is the predicate function to test\n   */\n  exists(p: (a: A) => boolean): boolean {\n    return !this._isEmpty && p(this._ref)\n  }\n\n  /**\n   * Returns true if this option is empty or the given predicate\n   * returns `true` when applied on this option's value.\n   *\n   * @param p is the predicate function to test\n   */\n  forAll(p: (a: A) => boolean): boolean {\n    return this._isEmpty || p(this._ref)\n  }\n\n  /**\n   * Apply the given procedure `cb` to the option's value if\n   * this option is nonempty, otherwise do nothing.\n   *\n   * @param cb the procedure to apply\n   */\n  forEach(cb: (a: A) => void): void {\n    if (!this._isEmpty) cb(this._ref)\n  }\n\n  // Implemented from IEquals\n  equals(that: Option<A>): boolean {\n    // tslint:disable-next-line:strict-type-predicates\n    if (that == null) return false\n    if (this.nonEmpty() && that.nonEmpty()) {\n      const l = this.get()\n      const r = that.get()\n      return std.is(l, r)\n    }\n    return this.isEmpty() && that.isEmpty()\n  }\n\n  // Implemented from IEquals\n  hashCode(): number {\n    if (this._isEmpty) return 2433880\n    else if (this._ref == null) return 2433881 << 2\n    else return std.hashCode(this._ref) << 2\n  }\n\n  // Implements HK<F, A>\n  /** @hidden */ readonly _funKindF: Option<any>\n  /** @hidden */ readonly _funKindA: A\n\n  // Implements Constructor<T>\n  /** @hidden */ static readonly _funErasure: Option<any>\n\n  /**\n   * Builds an [[Option]] reference that contains the given value.\n   *\n   * If the given value is `null` or `undefined` then the returned\n   * option will be empty.\n   */\n  static of<A>(value: A | null | undefined): Option<A> {\n    return value != null ? Some(value) : None\n  }\n\n  /**\n   * Builds an [[Option]] reference that contains the given reference.\n   *\n   * Note that `value` is allowed to be `null` or `undefined`, the\n   * returned option will still be non-empty. Use [[Option.of]]\n   * if you want to avoid this problem. This means:\n   *\n   * ```typescript\n   * const opt = Some<number | null>(null)\n   *\n   * opt.isEmpty()\n   * //=> false\n   *\n   * opt.get()\n   * //=> null\n   * ```\n   */\n  static some<A>(value: A): Option<A> {\n    return new Option(value, false)\n  }\n\n  /**\n   * Returns an empty [[Option]].\n   *\n   * NOTE: Because `Option` is immutable, this function returns the\n   * same cached reference is on different calls.\n   */\n  static none(): Option<never> {\n    return None\n  }\n\n  /**\n   * Returns an empty [[Option]].\n   *\n   * Similar to [[Option.none]], but this one allows specifying a\n   * type parameter (in the context of TypeScript or Flow or other\n   * type system).\n   *\n   * NOTE: Because `Option` is immutable, this function returns the\n   * same cached reference is on different calls.\n   */\n  static empty<A>(): Option<A> {\n    return None\n  }\n\n  /**\n   * Alias for [[Some]].\n   */\n  static pure<A>(value: A): Option<A> { return Some(value) }\n\n  /**\n   * Maps 2 optional values by the mapping function, returning a new\n   * optional reference that is `Some` only if both option values are\n   * `Some`, otherwise it returns a `None`.\n   *\n   * ```typescript\n   * // Yields Some(3)\n   * Option.map2(Some(1), Some(2),\n   *   (a, b) => a + b\n   * )\n   *\n   * // Yields None, because the second arg is None\n   * Option.map2(Some(1), None,\n   *   (a, b) => a + b\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map2`.\n   */\n  static map2<A1,A2,R>(fa1: Option<A1>, fa2: Option<A2>,\n                       f: (a1: A1, a2: A2) => R): Option<R> {\n\n    return fa1.nonEmpty() && fa2.nonEmpty()\n      ? Some(f(fa1.get(), fa2.get()))\n      : None\n  }\n\n  /**\n   * Maps 3 optional values by the mapping function, returning a new\n   * optional reference that is `Some` only if all 3 option values are\n   * `Some`, otherwise it returns a `None`.\n   *\n   * ```typescript\n   * // Yields Some(6)\n   * Option.map3(Some(1), Some(2), Some(3),\n   *   (a, b, c) => a + b + c\n   * )\n   *\n   * // Yields None, because the second arg is None\n   * Option.map3(Some(1), None, Some(3),\n   *   (a, b, c) => a + b + c\n   * )\n   * ```\n   */\n  static map3<A1,A2,A3,R>(fa1: Option<A1>, fa2: Option<A2>, fa3: Option<A3>,\n                          f: (a1: A1, a2: A2, a3: A3) => R): Option<R> {\n\n    return fa1.nonEmpty() && fa2.nonEmpty() && fa3.nonEmpty()\n      ? Some(f(fa1.get(), fa2.get(), fa3.get()))\n      : None\n  }\n\n  /**\n   * Maps 4 optional values by the mapping function, returning a new\n   * optional reference that is `Some` only if all 4 option values are\n   * `Some`, otherwise it returns a `None`.\n   *\n   * ```typescript\n   * // Yields Some(10)\n   * Option.map4(Some(1), Some(2), Some(3), Some(4),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   *\n   * // Yields None, because the second arg is None\n   * Option.map4(Some(1), None, Some(3), Some(4),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   * ```\n   */\n  static map4<A1,A2,A3,A4,R>(\n    fa1: Option<A1>, fa2: Option<A2>, fa3: Option<A3>, fa4: Option<A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R): Option<R> {\n\n    return fa1.nonEmpty() && fa2.nonEmpty() && fa3.nonEmpty() && fa4.nonEmpty()\n      ? Some(f(fa1.get(), fa2.get(), fa3.get(), fa4.get()))\n      : None\n  }\n\n  /**\n   * Maps 5 optional values by the mapping function, returning a new\n   * optional reference that is `Some` only if all 5 option values are\n   * `Some`, otherwise it returns a `None`.\n   *\n   * ```typescript\n   * // Yields Some(15)\n   * Option.map5(Some(1), Some(2), Some(3), Some(4), Some(5),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   *\n   * // Yields None, because the second arg is None\n   * Option.map5(Some(1), None, Some(3), Some(4), Some(5),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   * ```\n   */\n  static map5<A1,A2,A3,A4,A5,R>(\n    fa1: Option<A1>, fa2: Option<A2>, fa3: Option<A3>, fa4: Option<A4>, fa5: Option<A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R): Option<R> {\n\n    return fa1.nonEmpty() && fa2.nonEmpty() && fa3.nonEmpty() && fa4.nonEmpty() && fa5.nonEmpty()\n      ? Some(f(fa1.get(), fa2.get(), fa3.get(), fa4.get(), fa5.get()))\n      : None\n  }\n\n  /**\n   * Maps 6 optional values by the mapping function, returning a new\n   * optional reference that is `Some` only if all 6 option values are\n   * `Some`, otherwise it returns a `None`.\n   *\n   * ```typescript\n   * // Yields Some(21)\n   * Option.map6(Some(1), Some(2), Some(3), Some(4), Some(5), Some(6),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   *\n   * // Yields None, because the second arg is None\n   * Option.map6(Some(1), None, Some(3), Some(4), Some(5), Some(6),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   * ```\n   */\n  static map6<A1,A2,A3,A4,A5,A6,R>(\n    fa1: Option<A1>, fa2: Option<A2>, fa3: Option<A3>, fa4: Option<A4>, fa5: Option<A5>, fa6: Option<A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R): Option<R> {\n\n    return fa1.nonEmpty() && fa2.nonEmpty() && fa3.nonEmpty() && fa4.nonEmpty() && fa5.nonEmpty() && fa6.nonEmpty()\n      ? Some(f(fa1.get(), fa2.get(), fa3.get(), fa4.get(), fa5.get(), fa6.get()))\n      : None\n  }\n\n  /**\n   * Keeps calling `f` until a `Right(b)` is returned.\n   *\n   * Based on Phil Freeman's\n   * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.\n   *\n   * Described in `FlatMap.tailRecM`.\n   */\n  static tailRecM<A, B>(a: A, f: (a: A) => Option<Either<A, B>>): Option<B> {\n    let cursor = a\n    while (true) {\n      const result = f(cursor)\n      if (result.isEmpty()) return None\n\n      const some = result.get()\n      if (some.isRight()) return Some(some.get())\n      cursor = some.swap().get()\n    }\n  }\n}\n\n/**\n * The `Some<A>` data constructor for [[Option]] represents existing\n * values of type `A`.\n *\n * Using this function is equivalent with [[Option.some]].\n */\nexport function Some<A>(value: A): Option<A> {\n  return new (Option as any)(value, false)\n}\n\n/** @Hidden */\nfunction emptyOptionRef() {\n  // Ugly workaround to get around the limitation of\n  // Option's private constructor\n  const F: any = Option\n  return new F(null, true) as Option<never>\n}\n\n/**\n * The `None` data constructor for [[Option]] represents non-existing\n * values for any type.\n *\n * Using this reference directly is equivalent with [[Option.none]].\n */\nexport const None: Option<never> = emptyOptionRef()\n\n/**\n * The `Try` type represents a computation that may either result in an\n * exception, or return a successfully computed value. It's similar to,\n * but semantically different from the [[Either]] type.\n *\n * `Try` is a sum type and so instances of `Try` are either instances\n * of [[Success]] or of [[Failure]].\n *\n * For example, `Try` can be used to perform division on a user-defined\n * input, without the need to do explicit exception-handling in all of\n * the places that an exception might occur.\n *\n * Example:\n *\n * ```typescript\n * function divide(dividendS: string, divisorS: string): string {\n *   const dividend = Try(() => parseInt(dividendS))\n *     .filter(_ => _ === _) // filter out NaN\n *   const divisor = Try(() => parseInt(divisorS))\n *     .filter(_ => _ === _)  // filter out NaN\n *\n *   // map2 executes the given function only if both results are\n *   // successful; we could also express this with flatMap / chain\n *   const result = Try.map2(dividend, divisor,\n *     (a, b) => a / b\n *   )\n *\n *   result.fold(\n *     error => `failure: ${error}`\n *     result => `result: ${result}`\n *   )\n * }\n * ```\n *\n * An important property of `Try` is its ability to pipeline, or chain,\n * operations, catching exceptions along the way. The `flatMap` and `map`\n * combinators each essentially pass off either their successfully completed\n * value, wrapped in the [[Success]] type for it to be further operated upon\n * by the next combinator in the chain, or the exception wrapped in the\n * [[Failure]] type usually to be simply passed on down the chain.\n * Combinators such as `recover` and `recoverWith` are designed to provide\n * some type of global behavior in the case of failure.\n *\n * NOTE: all `Try` combinators will catch exceptions and return failure\n * unless otherwise specified in the documentation.\n */\nexport class Try<A> implements std.IEquals<Try<A>> {\n  private _isSuccess: boolean\n  private _successRef: A\n  private _failureRef: Throwable\n\n  private constructor(_success: A, _failure: Throwable, _isSuccess: boolean) {\n    this._isSuccess = _isSuccess\n    if (_isSuccess) this._successRef = _success\n    else this._failureRef = _failure\n  }\n\n  /**\n   * Returns `true` if the source is a [[Success]] result,\n   * or `false` in case it is a [[Failure]].\n   */\n  isSuccess(): boolean { return this._isSuccess }\n\n  /**\n   * Returns `true` if the source is a [[Failure]],\n   * or `false` in case it is a [[Success]] result.\n   */\n  isFailure(): boolean { return !this._isSuccess }\n\n  /**\n   * Returns a Try's successful value if it's a [[Success]] reference,\n   * otherwise throws an exception if it's a [[Failure]].\n   *\n   * WARNING!\n   *\n   * This function is partial, the option must be non-empty, otherwise\n   * a runtime exception will get thrown. Use with care.\n   */\n  get(): A {\n    if (!this._isSuccess) throw this._failureRef\n    return this._successRef\n  }\n\n  /**\n   * Returns the value from a `Success` or the given `fallback`\n   * value if this is a `Failure`.\n   *\n   * ```typescript\n   * Success(10).getOrElse(27) // 10\n   * Failure(\"error\").getOrElse(27)  // 27\n   * ```\n   */\n  getOrElse<AA>(fallback: AA): A | AA {\n    return this._isSuccess ? this._successRef : fallback\n  }\n\n  /**\n   * Returns the value from a `Success` or the value generated\n   * by a given `thunk` in case this is a `Failure`.\n   *\n   * ```typescript\n   * Success(10).getOrElseL(() => 27) // 10\n   * Failure(\"error\").getOrElseL(() => 27)  // 27\n   * ```\n   */\n  getOrElseL<AA>(thunk: () => AA): A | AA {\n    return this._isSuccess ? this._successRef : thunk()\n  }\n\n  /**\n   * Returns the current value if it's a [[Success]], or\n   * if the source is a [[Failure]] then return `null`.\n   *\n   * ```typescript\n   * Success(10).orNull()      // 10\n   * Failure(\"error\").orNull() // null\n   * ```\n   *\n   * This can be useful for use-cases such as:\n   *\n   * ```typescript\n   * Try.of(() => dict.user.profile.name).orNull()\n   * ```\n   */\n  orNull(): A | null {\n    return this._isSuccess ? this._successRef : null\n  }\n\n  /**\n   * Returns the current value if it's a [[Success]], or\n   * if the source is a [[Failure]] then return `undefined`.\n   *\n   * ```typescript\n   * Success(10).orUndefined()      // 10\n   * Failure(\"error\").orUndefined() // undefined\n   * ```\n   *\n   * This can be useful for use-cases such as:\n   *\n   * ```typescript\n   * Try.of(() => dict.user.profile.name).orUndefined()\n   * ```\n   */\n  orUndefined(): A | undefined {\n    return this._isSuccess ? this._successRef : undefined\n  }\n\n  /**\n   * Returns the current value if it's a [[Success]], or if\n   * the source is a [[Failure]] then return the `fallback`.\n   *\n   * ```typescript\n   * Success(10).orElse(Success(17))      // 10\n   * Failure(\"error\").orElse(Success(17)) // 17\n   * ```\n   */\n  orElse<AA>(fallback: Try<AA>): Try<A | AA> {\n    if (this._isSuccess) return this\n    return fallback\n  }\n\n  /**\n   * Returns the current value if it's a [[Success]], or if the source\n   * is a [[Failure]] then return the value generated by the given\n   * `thunk`.\n   *\n   * ```typescript\n   * Success(10).orElseL(() => Success(17))      // 10\n   * Failure(\"error\").orElseL(() => Success(17)) // 17\n   * ```\n   */\n  orElseL<AA>(thunk: () => Try<AA>): Try<A | AA> {\n    if (this._isSuccess) return this\n    return thunk()\n  }\n\n  /**\n   * Inverts this `Try`. If this is a [[Failure]], returns its exception wrapped\n   * in a [[Success]]. If this is a `Success`, returns a `Failure` containing a\n   * [[NoSuchElementError]].\n   */\n  failed(): Try<Throwable> {\n    return this._isSuccess\n      ? Failure(new NoSuchElementError(\"try.failed()\"))\n      : Success(this._failureRef)\n  }\n\n  /**\n   * Applies the `failure` function to [[Failure]] values, and the\n   * `success` function to [[Success]] values and returns the result.\n   *\n   * ```typescript\n   * const maybeNum: Try<number> =\n   *   tryParseInt(\"not a number\")\n   *\n   * const result: string =\n   *   maybeNum.fold(\n   *     error => `Could not parse string: ${error}`,\n   *     num => `Success: ${num}`\n   *   )\n   * ```\n   */\n  fold<R>(failure: (error: Throwable) => R, success: (a: A) => R): R {\n    return this._isSuccess\n      ? success(this._successRef)\n      : failure(this._failureRef)\n  }\n\n  /**\n   * Returns a [[Failure]] if the source is a [[Success]], but the\n   * given `p` predicate is not satisfied.\n   *\n   * @throws NoSuchElementError in case the predicate doesn't hold\n   */\n  filter(p: (a: A) => boolean): Try<A> {\n    if (!this._isSuccess) return this\n    try {\n      if (p(this._successRef)) return this\n      return Failure(\n        new NoSuchElementError(\n          `Predicate does not hold for ${this._successRef}`\n        ))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Returns the given function applied to the value if this is\n   * a [[Success]] or returns `this` if this is a [[Failure]].\n   *\n   * This operation is the monadic \"bind\" operation.\n   * It can be used to *chain* multiple `Try` references.\n   *\n   * ```typescript\n   * Try.of(() => parse(s1)).flatMap(num1 =>\n   *   Try.of(() => parse(s2)).map(num2 =>\n   *     num1 / num2\n   *   ))\n   * ```\n   */\n  flatMap<B>(f: (a: A) => Try<B>): Try<B> {\n    if (!this._isSuccess) return this as any\n    try {\n      return f(this._successRef)\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /** Alias for [[flatMap]]. */\n  chain<B>(f: (a: A) => Try<B>): Try<B> {\n    return this.flatMap(f)\n  }\n\n  /**\n   * Returns a `Try` containing the result of applying `f` to\n   * this option's value, but only if it's a `Success`, or\n   * returns the current `Failure` without any modifications.\n   *\n   * NOTE: this is similar with `flatMap`, except with `map` the\n   * result of `f` doesn't need to be wrapped in a `Try`.\n   *\n   * @param f the mapping function that will transform the value\n   *          of this `Try` if successful.\n   *\n   * @return a new `Try` instance containing the value of the\n   *         source mapped by the given function\n   */\n  map<B>(f: (a: A) => B): Try<B> {\n    return this._isSuccess\n      ? Try.of(() => f(this._successRef))\n      : ((this as any) as Try<B>)\n  }\n\n  /**\n   * Applies the given function `cb` if this is a [[Success]], otherwise\n   * returns `void` if this is a [[Failure]].\n   */\n  forEach(cb: (a: A) => void): void {\n    if (this._isSuccess) cb(this._successRef)\n  }\n\n  /**\n   * Applies the given function `f` if this is a `Failure`, otherwise\n   * returns `this` if this is a `Success`.\n   *\n   * This is like `map` for the exception.\n   *\n   * In the following example, if the `user.profile.email` exists,\n   * then it is returned as a successful value, otherwise\n   *\n   * ```typescript\n   * Try.of(() => user.profile.email).recover(e => {\n   *   // Access error? Default to empty.\n   *   if (e instanceof TypeError) return \"\"\n   *   throw e // We don't know what it is, rethrow\n   * })\n   *\n   * Note that on rethrow, the error is being caught in `recover` and\n   * it still returns it as a `Failure(e)`.\n   * ```\n   */\n  recover<AA>(f: (error: Throwable) => AA): Try<A | AA> {\n    return this._isSuccess ? this : Try.of(() => f(this._failureRef))\n  }\n\n  /**\n   * Applies the given function `f` if this is a `Failure`, otherwise\n   * returns `this` if this is a `Success`.\n   *\n   * This is like `map` for the exception.\n   *\n   * In the following example, if the `user.profile.email` exists,\n   * then it is returned as a successful value, otherwise\n   *\n   * ```typescript\n   * Try.of(() => user.profile.email).recover(e => {\n   *   // Access error? Default to empty.\n   *   if (e instanceof TypeError) return \"\"\n   *   throw e // We don't know what it is, rethrow\n   * })\n   *\n   * Note that on rethrow, the error is being caught in `recover` and\n   * it still returns it as a `Failure(e)`.\n   * ```\n   */\n  recoverWith<AA>(f: (error: Throwable) => Try<AA>): Try<A | AA> {\n    try {\n      return this._isSuccess ? this : f(this._failureRef)\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Transforms the source into an [[Option]].\n   *\n   * In case the source is a `Success(v)`, then it gets translated\n   * into a `Some(v)`. If the source is a `Failure(e)`, then a `None`\n   * value is returned.\n   *\n   * ```typescript\n   * Success(\"value\").toOption() // Some(\"value\")\n   * Failure(\"error\").toOption() // None\n   * ```\n   */\n  toOption(): Option<A> {\n    return this._isSuccess ? Some(this._successRef) : None\n  }\n\n  /**\n   * Transforms the source into an [[Either]].\n   *\n   * In case the source is a `Success(v)`, then it gets translated\n   * into a `Right(v)`. If the source is a `Failure(e)`, then a `Left(e)`\n   * value is returned.\n   *\n   * ```typescript\n   * Success(\"value\").toEither() // Right(\"value\")\n   * Failure(\"error\").toEither() // Left(\"error\")\n   * ```\n   */\n  toEither(): Either<Throwable, A> {\n    return this._isSuccess\n      ? Right(this._successRef)\n      : Left(this._failureRef)\n  }\n\n  // Implemented from IEquals\n  equals(that: Try<A>): boolean {\n    // tslint:disable-next-line:strict-type-predicates\n    if (that == null) return false\n    return this._isSuccess\n      ? that._isSuccess && std.is(this._successRef, that._successRef)\n      : !that._isSuccess && std.is(this._failureRef, that._failureRef)\n  }\n\n  // Implemented from IEquals\n  hashCode(): number {\n    return this._isSuccess\n      ? std.hashCode(this._successRef)\n      : std.hashCode(this._failureRef)\n  }\n\n  // Implements HK<F, A>\n  /** @hidden */ readonly _funKindF: Try<any>\n  /** @hidden */ readonly _funKindA: A\n\n  // Implements Constructor<T>\n  /** @hidden */ static readonly _funErasure: Try<any>\n\n  /**\n   * Evaluates the given `thunk` and returns either a [[Success]],\n   * in case the evaluation succeeded, or a [[Failure]], in case\n   * an exception was thrown.\n   *\n   * Example:\n   *\n   * ```typescript\n   * let effect = 0\n   *\n   * const e = Try.of(() => { effect += 1; return effect })\n   * e.get() // 1\n   * ```\n   */\n  static of<A>(thunk: () => A): Try<A> {\n    try {\n      return Success(thunk())\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /** Alias of [[Try.success]]. */\n  static pure<A>(value: A): Try<A> {\n    return Try.success(value)\n  }\n\n  /**\n   * Shorthand for `now(undefined as void)`, always returning\n   * the same reference as optimization.\n   */\n  static unit(): Try<void> {\n    return tryUnitRef\n  }\n\n  /**\n   * Returns a [[Try]] reference that represents a successful result\n   * (i.e. wrapped in [[Success]]).\n   */\n  static success<A>(value: A): Try<A> {\n    return Success(value)\n  }\n\n  /**\n   * Returns a [[Try]] reference that represents a failure\n   * (i.e. an exception wrapped in [[Failure]]).\n   */\n  static failure<A = never>(e: Throwable): Try<A> {\n    return Failure(e)\n  }\n\n  /**\n   * Alias for {@link Try.failure} and {@link Failure},\n   * wrapping any throwable into a `Try` value.\n   */\n  static raise<A = never>(e: Throwable): Try<A> {\n    return Failure(e)\n  }\n\n  /**\n   * Maps 2 `Try` values by the mapping function, returning a new\n   * `Try` reference that is a `Success` only if both `Try` values are\n   * a `Success`, otherwise it returns the first `Failure` noticed.\n   *\n   * ```typescript\n   * // Yields Success(3)\n   * Try.map2(Success(1), Success(2),\n   *   (a, b) => a + b\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Try.map2(Success(1), Failure(\"error\"),\n   *   (a, b) => a + b\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map2`.\n   */\n  static map2<A1,A2,R>(\n    fa1: Try<A1>, fa2: Try<A2>,\n    f: (a1: A1, a2: A2) => R): Try<R> {\n\n    if (fa1.isFailure()) return ((fa1 as any) as Try<R>)\n    if (fa2.isFailure()) return ((fa2 as any) as Try<R>)\n    try {\n      return Success(f(fa1._successRef, fa2._successRef))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Maps 3 `Try` values by the mapping function, returning a new\n   * `Try` reference that is a `Success` only if all 3 `Try` values are\n   * a `Success`, otherwise it returns the first `Failure` noticed.\n   *\n   * ```typescript\n   * // Yields Success(6)\n   * Try.map3(Success(1), Success(2), Success(3),\n   *   (a, b, c) => {\n   *     return a + b + c\n   *   }\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Try.map3(\n   *   Success(1),\n   *   Failure(\"error\"),\n   *   Success(3),\n   *\n   *   (a, b, c) => {\n   *     return a + b + c\n   *   }\n   * )\n   * ```\n   */\n  static map3<A1,A2,A3,R>(\n    fa1: Try<A1>, fa2: Try<A2>, fa3: Try<A3>,\n    f: (a1: A1, a2: A2, a3: A3) => R): Try<R> {\n\n    if (fa1.isFailure()) return ((fa1 as any) as Try<R>)\n    if (fa2.isFailure()) return ((fa2 as any) as Try<R>)\n    if (fa3.isFailure()) return ((fa3 as any) as Try<R>)\n    try {\n      return Success(f(\n        fa1._successRef,\n        fa2._successRef,\n        fa3._successRef))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Maps 4 `Try` values by the mapping function, returning a new\n   * `Try` reference that is a `Success` only if all 4 `Try` values are\n   * a `Success`, otherwise it returns the first `Failure` noticed.\n   *\n   * ```typescript\n   * // Yields Success(10)\n   * Try.map4(Success(1), Success(2), Success(3), Success(4),\n   *   (a, b, c, d) => {\n   *     return a + b + c + d\n   *   }\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Try.map3(\n   *   Success(1),\n   *   Failure(\"error\"),\n   *   Success(3),\n   *   Success(4),\n   *\n   *   (a, b, c, d) => {\n   *     return a + b + c + d\n   *   }\n   * )\n   * ```\n   */\n  static map4<A1,A2,A3,A4,R>(\n    fa1: Try<A1>, fa2: Try<A2>, fa3: Try<A3>, fa4: Try<A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R): Try<R> {\n\n    if (fa1.isFailure()) return ((fa1 as any) as Try<R>)\n    if (fa2.isFailure()) return ((fa2 as any) as Try<R>)\n    if (fa3.isFailure()) return ((fa3 as any) as Try<R>)\n    if (fa4.isFailure()) return ((fa4 as any) as Try<R>)\n    try {\n      return Success(f(\n        fa1._successRef,\n        fa2._successRef,\n        fa3._successRef,\n        fa4._successRef))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Maps 5 `Try` values by the mapping function, returning a new\n   * `Try` reference that is a `Success` only if all 5 `Try` values are\n   * a `Success`, otherwise it returns the first `Failure` noticed.\n   *\n   * ```typescript\n   * // Yields Success(15)\n   * Try.map5(\n   *   Success(1),\n   *   Success(2),\n   *   Success(3),\n   *   Success(4),\n   *   Success(5),\n   *\n   *   (a, b, c, d, e) => {\n   *     return a + b + c + d + e\n   *   }\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Try.map5(\n   *   Success(1),\n   *   Failure(\"error\"),\n   *   Success(3),\n   *   Success(4),\n   *   Success(5),\n   *\n   *   (a, b, c, d, e) => {\n   *     return a + b + c + d + e\n   *   }\n   * )\n   * ```\n   */\n  static map5<A1,A2,A3,A4,A5,R>(\n    fa1: Try<A1>, fa2: Try<A2>, fa3: Try<A3>, fa4: Try<A4>, fa5: Try<A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R): Try<R> {\n\n    if (fa1.isFailure()) return ((fa1 as any) as Try<R>)\n    if (fa2.isFailure()) return ((fa2 as any) as Try<R>)\n    if (fa3.isFailure()) return ((fa3 as any) as Try<R>)\n    if (fa4.isFailure()) return ((fa4 as any) as Try<R>)\n    if (fa5.isFailure()) return ((fa5 as any) as Try<R>)\n    try {\n      return Success(f(\n        fa1._successRef,\n        fa2._successRef,\n        fa3._successRef,\n        fa4._successRef,\n        fa5._successRef))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Maps 6 `Try` values by the mapping function, returning a new\n   * `Try` reference that is a `Success` only if all 6 `Try` values are\n   * a `Success`, otherwise it returns the first `Failure` noticed.\n   *\n   * ```typescript\n   * // Yields Success(21)\n   * Try.map6(\n   *   Success(1),\n   *   Success(2),\n   *   Success(3),\n   *   Success(4),\n   *   Success(5),\n   *   Success(6),\n   *\n   *   (a, b, c, d, e, f) => {\n   *     return a + b + c + d + e + f\n   *   }\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Try.map6(\n   *   Success(1),\n   *   Failure(\"error\"),\n   *   Success(3),\n   *   Success(4),\n   *   Success(5),\n   *   Success(6),\n   *\n   *   (a, b, c, d, e, f) => {\n   *     return a + b + c + d + e + f\n   *   }\n   * )\n   * ```\n   */\n  static map6<A1,A2,A3,A4,A5,A6,R>(\n    fa1: Try<A1>, fa2: Try<A2>, fa3: Try<A3>, fa4: Try<A4>, fa5: Try<A5>, fa6: Try<A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R): Try<R> {\n\n    if (fa1.isFailure()) return ((fa1 as any) as Try<R>)\n    if (fa2.isFailure()) return ((fa2 as any) as Try<R>)\n    if (fa3.isFailure()) return ((fa3 as any) as Try<R>)\n    if (fa4.isFailure()) return ((fa4 as any) as Try<R>)\n    if (fa5.isFailure()) return ((fa5 as any) as Try<R>)\n    if (fa6.isFailure()) return ((fa6 as any) as Try<R>)\n    try {\n      return Success(f(\n        fa1._successRef,\n        fa2._successRef,\n        fa3._successRef,\n        fa4._successRef,\n        fa5._successRef,\n        fa6._successRef))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Keeps calling `f` until a `Right(b)` is returned.\n   *\n   * Based on Phil Freeman's\n   * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.\n   *\n   * Described in `FlatMap.tailRecM`.\n   */\n  static tailRecM<A, B>(a: A, f: (a: A) => Try<Either<A, B>>): Try<B> {\n    let cursor = a\n    while (true) {\n      try {\n        const result = f(cursor) as Try<Either<A, B>>\n        if (result.isFailure()) return result as any\n\n        const some = result.get()\n        if (some.isRight()) return Success(some.get())\n        cursor = some.swap().get()\n      } catch (e) {\n        return Failure(e)\n      }\n    }\n  }\n}\n\n/**\n * The `Success` data constructor is for building [[Try]] values that\n * are successful results of computations, as opposed to [[Failure]].\n */\nexport function Success<A>(value: A): Try<A> {\n  return new (Try as any)(value, null, true)\n}\n\n/**\n * The `Failure` data constructor is for building [[Try]] values that\n * represent failures, as opposed to [[Success]].\n */\nexport function Failure(e: Throwable): Try<never> {\n  return new (Try as any)(null as never, e, false)\n}\n\n/**\n * Reusable reference, to use in {@link Try.unit}.\n *\n * @private\n */\nconst tryUnitRef: Try<void> = Success(undefined)\n"],"names":["ref","equals","hashCode","lh","rh","valueOf","lh2","rh2","isValueObject","is","v","hashCodeOfString","String","str","hash","length","i","character","charCodeAt","a","derivedCtor","baseCtors","forEach","getOwnPropertyNames","baseCtor","prototype","name","errors","reasons","slice","e","message","Error","errorsRef","self","constructor","CompositeError","__proto__","DummyError","NoSuchElementError","IllegalInheritanceError","IllegalStateError","IllegalArgumentError","NotImplementedError","TimeoutError","_leftRef","_rightRef","_isRight","elem","std","p","zero","Left","f","left","right","fallback","thunk","Right","cb","Option","some","none","other","value","fa1","fa2","isLeft","fa3","fa4","fa5","fa6","cursor","result","get","isRight","swap","Either","isEmpty","_isEmpty","undefined","_ref","None","Some","of","flatMap","that","nonEmpty","l","r","F","emptyOptionRef","_success","_failure","_isSuccess","_successRef","_failureRef","Failure","Success","failure","success","Try","tryUnitRef","isFailure"],"mappings":"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"}