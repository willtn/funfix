{"version":3,"file":"es5.js","sources":["../src/internals.ts","../src/eval.ts","../../funfix-exec/src/cancelable.ts","../../funfix-exec/src/time.ts","../../funfix-exec/src/ref.ts","../../funfix-exec/src/internals.ts","../../funfix-exec/src/scheduler.ts","../../funfix-exec/src/future.ts","../src/io.ts"],"sourcesContent":["/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * We don't need the full power of JS's iterators, just a way\n * to traverse data structures.\n *\n * @hidden\n */\nexport interface IteratorLike<A> {\n  next(): { done: boolean, value?: A }\n}\n\n/**\n * Reusable empty `IteratorLike` reference.\n *\n * @hidden\n */\nexport const emptyIteratorRef: IteratorLike<never> =\n  { next: () => ({ done: true }) }\n\n/**\n * Given an array or an `Iterable`, returns a simple iterator type\n * that we can use to traverse the given list lazily.\n *\n * @hidden\n */\nexport function iteratorOf<A>(list: A[] | Iterable<A>): IteratorLike<A> {\n  if (!list) return emptyIteratorRef\n  if (Object.prototype.toString.call(list) !== \"[object Array]\")\n    return list[Symbol.iterator]()\n\n  const array = list as A[]\n  if (array.length === 0) return emptyIteratorRef\n\n  let cursor = 0\n  const next = () => {\n    const value = array[cursor++]\n    const done = cursor >= array.length\n    return { done, value }\n  }\n\n  return { next }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Either, Throwable } from \"funfix-core\"\nimport {\n  IteratorLike,\n  iteratorOf\n} from \"./internals\"\n\n/**\n * Eval is a monad which controls evaluation.\n *\n * This type wraps a value (or an expression that produces a value)\n * and can produce it on command via the {@link Eval.get get()}\n * method.\n *\n * There are three basic evaluation strategies:\n *\n *  - {@link Eval.now}: for describing strict values, evaluated\n *    immediately\n *  - {@link Eval.once}: evaluated only once when the value is needed,\n *    with the result memoized (cached) for subsequent evaluations\n *  - [[Eval.always]]: evaluated every time the value is needed,\n *    being equivalent to a function\n *\n * Eval supports stack-safe lazy computation via the {@link Eval.map .map}\n * and {@link Eval.flatMap .flatMap} methods, which use an internal\n * trampoline to avoid stack overflows. Computation done within `map`\n * and `flatMap` is always done lazily, even when applied to an\n * `Eval.now` instance.\n *\n * Use `map` and `flatMap` to chain computation, and use `get()` to\n * get the result when needed. It is also not good style to create\n * `Eval` instances whose computation involves calling `get()` on\n * another `Eval` instance -- this can defeat the trampolining and\n * lead to stack overflows.\n *\n * ```typescript\n * const rndInt = Eval.of(() => {\n *   const nr = Math.random() * 1000000\n *   return nr & nr\n * })\n *\n * const evenInt = () =>\n *   rndInt.flatMap(int => {\n *     if (i % 2 == 0)\n *       return Eval.now(i)\n *     else // Retry until we have an even number!\n *       return evenInt()\n *   })\n *\n * const cached = evenInt().memoize()\n *\n * // Nothing happens until now, this triggers the\n * // actual evaluation:\n * const n: number = cached.get()\n * ```\n *\n * ## Versus IO\n *\n * For dealing with lazy evaluation, the other alternative is\n * the {@link IO} data type.\n *\n * Differences between `Eval` and `IO`:\n *\n * 1. `IO` is capable of describing asynchronous computations as well\n * 2. `IO` is capable of error handling (it implements `MonadError`),\n *    whereas `Eval` does not provide error handling capabilities,\n *    being meant to be used for pure expressions (it implements\n *    `Comonad`, which is incompatible with `MonadError`)\n *\n * So if you need error handling capabilities\n * (i.e. `MonadError<Throwable, ?>`), or if you need to describe\n * asynchronous processes, then {@link IO} is for you. `Eval`\n * is a simpler data type with the sole purpose of controlling the\n * evaluation of expressions (i.e. strict versus lazy).\n *\n * ## Credits\n *\n * This type is inspired by `cats.Eval` from\n * {@link http://typelevel.org/cats/|Typelevel Cats}\n * and by `monix.eval.Coeval` from {@link https://monix.io|Monix}.\n *\n * @final\n */\nexport class Eval<A> {\n  /**\n   * Evaluates the source `Eval` and returns the result.\n   *\n   * ```typescript\n   * const ref = Eval.always(() => 100 * 2)\n   *\n   * ref.get() // 200\n   * ```\n   */\n  get(): A { return evalRunLoop(this) }\n\n  /**\n   * Returns a new `Eval` that applies the mapping function to the\n   * successful result emitted by the source.\n   *\n   * ```typescript\n   * Eval.now(111).map(_ => _ * 2).get() // 222\n   * ```\n   */\n  map<B>(f: (a: A) => B): Eval<B> {\n    return new FlatMap(this, (a: A) => Eval.now(f(a)))\n  }\n\n  /**\n   * Creates a new `Eval` by applying a function to the successful\n   * result of the source, and returns a new instance equivalent to\n   * the result of the function.\n   *\n   * ```typescript\n   * const rndInt = Eval.of(() => {\n   *   const nr = Math.random() * 1000000\n   *   return nr & nr\n   * })\n   *\n   * const evenInt = () =>\n   *   rndInt.flatMap(int => {\n   *     if (i % 2 == 0)\n   *       return Eval.now(i)\n   *     else // Retry until we have an even number!\n   *       return evenInt()\n   *   })\n   * ```\n   */\n  flatMap<B>(f: (a: A) => Eval<B>): Eval<B> {\n    return new FlatMap(this, f)\n  }\n\n  /**\n   * Alias for {@link Eval.flatMap .flatMap}.\n   */\n  chain<B>(f: (a: A) => Eval<B>): Eval<B> {\n    return this.flatMap(f)\n  }\n\n  /**\n   * Memoizes (caches) the result of the source on the first\n   * evaluation and reuses it on subsequent invocations of `get()`.\n   *\n   * The resulting `Eval` will be idempotent, meaning that\n   * evaluating it multiple times will have the same effect\n   * as evaluating it once.\n   */\n  memoize(): Eval<A> {\n    switch (this._funADType) {\n      case \"now\":\n      case \"once\":\n        return this\n      case \"always\":\n        return new Once(this.get)\n      default:\n        return new Once(() => this.get())\n    }\n  }\n\n  /**\n   * Returns a new `Eval` that upon evaluation will execute the given\n   * function for the generated element, transforming the source into\n   * an `Eval<void>`.\n   *\n   * Similar in spirit with normal {@link Eval.forEach .forEach},\n   * but lazy, as obviously nothing gets executed at this point.\n   */\n  forEachL(cb: (a: A) => void): Eval<void> {\n    return this.map(cb)\n  }\n\n  /**\n   * Triggers the evaluation of the source, executing the given\n   * function for the generated element.\n   *\n   * The application of this function has strict behavior, as the\n   * coeval is immediately executed.\n   */\n  forEach(cb: (a: A) => void): void {\n    this.forEachL(cb).get()\n  }\n\n  /**\n   * Identifies the `Eval` reference type, useful for debugging and\n   * for pattern matching in the implementation.\n   *\n   * @hidden\n   */\n  readonly _funADType: \"now\" | \"always\" | \"once\" | \"suspend\" | \"flatMap\"\n\n  // Implements HK<F, A>\n  /** @hidden */ readonly _funKindF: Eval<any>\n  /** @hidden */ readonly _funKindA: A\n\n  // Implements Constructor<T>\n  /** @hidden */ static readonly _funErasure: Eval<any>\n\n  /**\n   * Alias for {@link Eval.always}.\n   */\n  static of<A>(thunk: () => A): Eval<A> {\n    return Eval.always(thunk)\n  }\n\n  /**\n   * Lifts a value into the `Eval` context.\n   *\n   * Alias for {@link Eval.now}.\n   */\n  static pure<A>(value: A): Eval<A> { return Eval.now(value) }\n\n  /**\n   * Returns an `Eval` that on execution is always successful,\n   * emitting the given strict value.\n   */\n  static now<A>(value: A): Eval<A> { return new Now(value) }\n\n  /**\n   * Shorthand for `now(undefined as void)`, always returning\n   * the same reference as optimization.\n   */\n  static unit(): Eval<void> {\n    return evalUnitRef\n  }\n\n  /**\n   * Promote a `thunk` function to an `Eval`, catching exceptions in\n   * the process.\n   *\n   * Note that since `Eval` is not memoized by global, this will\n   * recompute the value each time the `Eval` is executed.\n   */\n  static always<A>(thunk: () => A): Eval<A> {\n    return new Always(thunk)\n  }\n\n  /**\n   * Promote a `thunk` function to a `Coeval` that is memoized on the\n   * first evaluation, the result being then available on subsequent\n   * evaluations.\n   *\n   * Note this is equivalent with:\n   *\n   * ```typescript\n   * Eval.always(thunk).memoize()\n   * ```\n   */\n  static once<A>(thunk: () => A): Eval<A> {\n    return new Once(thunk)\n  }\n\n  /**\n   * Promote a `thunk` function generating `Eval` results to an `Eval`\n   * of the same type.\n   */\n  static suspend<A>(thunk: () => Eval<A>): Eval<A> {\n    return new Suspend(thunk)\n  }\n\n  /**\n   * Promote a `thunk` function generating `Eval` results to an `Eval`\n   * of the same type.\n   *\n   * Alias for {@link Eval.suspend}.\n   */\n  static defer<A>(thunk: () => Eval<A>): Eval<A> {\n    return Eval.suspend(thunk)\n  }\n\n  /**\n   * Keeps calling `f` until a `Right(b)` is returned.\n   *\n   * Based on Phil Freeman's\n   * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.\n   *\n   * Described in `FlatMap.tailRecM`.\n   */\n  static tailRecM<A, B>(a: A, f: (a: A) => Eval<Either<A, B>>): Eval<B> {\n    return f(a).flatMap(either => {\n      if (either.isRight()) {\n        return Eval.now(either.get())\n      } else {\n        // Recursive call\n        return Eval.tailRecM(either.swap().get(), f)\n      }\n    })\n  }\n\n  /**\n   * Transforms a list of `Eval` values into an `Eval` of a list.\n   *\n   * Sample:\n   *\n   * ```typescript\n   * const io1 = Eval.of(() => 1)\n   * const io2 = Eval.of(() => 2)\n   * const io3 = Eval.of(() => 3)\n   *\n   * // Yields [1, 2, 3]\n   * const all: Eval<number[]> = Eval.sequence([f1, f2, f3])\n   * ```\n   */\n  static sequence<A>(list: Eval<A>[] | Iterable<Eval<A>>): Eval<A[]> {\n    return evalSequence(list)\n  }\n\n  /**\n   * Maps 2 `Eval` values by the mapping function, returning a new\n   * `Eval` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * ```typescript\n   * const fa1 = Eval.of(() => 1)\n   * const fa2 = Eval.of(() => 2)\n   *\n   *\n   * // Yields Success(3)\n   * Eval.map2(fa1, fa2, (a, b) => a + b)\n   * ```\n   *\n   * This operation is the `Applicative.map2`.\n   */\n  static map2<A1, A2, R>(\n    fa1: Eval<A1>, fa2: Eval<A2>,\n    f: (a1: A1, a2: A2) => R): Eval<R> {\n\n    const fl: Eval<any[]> = Eval.sequence([fa1, fa2] as any[])\n    return fl.map(lst => f(lst[0], lst[1]))\n  }\n\n  /**\n   * Maps 3 `Eval` values by the mapping function, returning a new\n   * `Eval` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * ```typescript\n   * const fa1 = Eval.of(() => 1)\n   * const fa2 = Eval.of(() => 2)\n   * const fa3 = Eval.of(() => 3)\n   *\n   *\n   * // Yields Success(6)\n   * Eval.map3(fa1, fa2, fa3, (a, b, c) => a + b + c)\n   * ```\n   */\n  static map3<A1, A2, A3, R>(\n    fa1: Eval<A1>, fa2: Eval<A2>, fa3: Eval<A3>,\n    f: (a1: A1, a2: A2, a3: A3) => R): Eval<R> {\n\n    const fl: Eval<any[]> = Eval.sequence([fa1, fa2, fa3] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2]))\n  }\n\n  /**\n   * Maps 4 `Eval` values by the mapping function, returning a new\n   * `Eval` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * ```typescript\n   * const fa1 = Eval.of(() => 1)\n   * const fa2 = Eval.of(() => 2)\n   * const fa3 = Eval.of(() => 3)\n   * const fa4 = Eval.of(() => 4)\n   *\n   * // Yields Success(10)\n   * Eval.map4(fa1, fa2, fa3, fa4, (a, b, c, d) => a + b + c + d)\n   * ```\n   */\n  static map4<A1, A2, A3, A4, R>(\n    fa1: Eval<A1>, fa2: Eval<A2>, fa3: Eval<A3>, fa4: Eval<A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R): Eval<R> {\n\n    const fl: Eval<any[]> = Eval.sequence([fa1, fa2, fa3, fa4] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3]))\n  }\n\n  /**\n   * Maps 5 `Eval` values by the mapping function, returning a new\n   * `Eval` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * ```typescript\n   * const fa1 = Eval.of(() => 1)\n   * const fa2 = Eval.of(() => 2)\n   * const fa3 = Eval.of(() => 3)\n   * const fa4 = Eval.of(() => 4)\n   * const fa5 = Eval.of(() => 5)\n   *\n   * // Yields Success(15)\n   * Eval.map5(fa1, fa2, fa3, fa4, fa5,\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   * ```\n   */\n  static map5<A1, A2, A3, A4, A5, R>(\n    fa1: Eval<A1>, fa2: Eval<A2>, fa3: Eval<A3>, fa4: Eval<A4>, fa5: Eval<A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R): Eval<R> {\n\n    const fl: Eval<any[]> = Eval.sequence([fa1, fa2, fa3, fa4, fa5] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3], lst[4]))\n  }\n\n  /**\n   * Maps 6 `Eval` values by the mapping function, returning a new\n   * `Eval` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * ```typescript\n   * const fa1 = Eval.of(() => 1)\n   * const fa2 = Eval.of(() => 2)\n   * const fa3 = Eval.of(() => 3)\n   * const fa4 = Eval.of(() => 4)\n   * const fa5 = Eval.of(() => 5)\n   * const fa6 = Eval.of(() => 6)\n   *\n   * // Yields Success(21)\n   * Eval.map6(\n   *   fa1, fa2, fa3, fa4, fa5, fa6,\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   * ```\n   */\n  static map6<A1, A2, A3, A4, A5, A6, R>(\n    fa1: Eval<A1>, fa2: Eval<A2>, fa3: Eval<A3>, fa4: Eval<A4>, fa5: Eval<A5>, fa6: Eval<A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R): Eval<R> {\n\n    const fl: Eval<any[]> = Eval.sequence([fa1, fa2, fa3, fa4, fa5, fa6] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3], lst[4], lst[5]))\n  }\n}\n\n/**\n * `Now` is an internal `Eval` state that wraps any strict\n * value in an `Eval` reference. Returned by [[Eval.now]].\n *\n * @private\n */\nclass Now<A> extends Eval<A> {\n  readonly _funADType: \"now\" = \"now\"\n\n  /**\n   * @param value is the value that's going to be returned\n   * when `get()` is called.\n   */\n  constructor(public readonly value: A) { super() }\n\n  get(): A { return this.value }\n  toString(): string { return `Eval.now(${JSON.stringify(this.value)})` }\n}\n\n/**\n * Reusable reference, to use in {@link Eval.unit}.\n *\n * @private\n */\nconst evalUnitRef: Now<void> = new Now(undefined)\n\n/**\n * `Once` is an internal `Eval` state that executes the given `thunk`\n * only once, upon calling `get()` and then memoize its result for\n * subsequent invocations.\n *\n * Returned by [[Eval.once]].\n *\n * @private\n */\nclass Once<A> extends Eval<A> {\n  readonly _funADType: \"once\" = \"once\"\n\n  private _thunk: () => A\n  private _cache?: Throwable | A\n  private _isError?: boolean\n\n  constructor(thunk: () => A) {\n    super()\n    this._thunk = thunk\n  }\n\n  get(): A {\n    if (this._thunk) {\n      try {\n        this._cache = this._thunk()\n        this._isError = false\n      } catch (e) {\n        this._cache = e\n        this._isError = true\n      }\n      // GC purposes\n      delete this._thunk\n    }\n\n    if (this._isError) throw this._cache\n    return this._cache as A\n  }\n\n  toString(): string { return `Eval.once([thunk])` }\n}\n\n/**\n * `Always` is an internal `Eval` state that executes the given `thunk`\n * every time the call to `get()` happens. Returned by [[Eval.always]].\n *\n * @private\n */\nclass Always<A> extends Eval<A> {\n  readonly _funADType: \"always\" = \"always\"\n\n  constructor(thunk: () => A) {\n    super()\n    this.get = thunk\n  }\n\n  toString(): string { return `Eval.always([thunk])` }\n}\n\n/**\n * `Suspend` is an internal `Eval` state that represents a factory of\n * `Eval` values. Returned by [[Eval.suspend]].\n *\n * @private\n */\nclass Suspend<A> extends Eval<A> {\n  readonly _funADType: \"suspend\" = \"suspend\"\n\n  constructor(public readonly thunk: () => Eval<A>) { super() }\n  toString(): string { return `Eval.suspend([thunk])` }\n}\n\n/**\n * `FlatMap` is an internal `Eval` state that represents a\n * [[Eval.flatMap .flatMap]], [[Eval.map .map]], [[Eval.transform .transform]]\n * or a [[Eval.transformWith .transformWith]] operation, all of them\n * being expressed with this state.\n *\n * @private\n */\nclass FlatMap<A, B> extends Eval<B> {\n  readonly _funADType: \"flatMap\" = \"flatMap\"\n\n  constructor(\n    public readonly source: Eval<A>,\n    public readonly f: (a: A) => Eval<B>) { super() }\n\n  toString(): string {\n    return `Eval#FlatMap(${String(this.source)}, [function])`\n  }\n}\n\n/** @hidden */\ntype Current = Eval<any>\n/** @hidden */\ntype Bind = ((a: any) => Eval<any>)\n/** @hidden */\ntype CallStack = Array<Bind>\n\n/** @hidden */\nfunction _popNextBind(bFirst: Bind | null, bRest: CallStack | null): Bind | undefined | null {\n  if (bFirst) return bFirst\n  if (bRest && bRest.length > 0) return bRest.pop()\n  return null\n}\n\n/** @hidden */\nfunction evalRunLoop<A>(start: Eval<A>): A {\n  let current: Current = start\n  let bFirst: Bind | null = null\n  let bRest: CallStack | null = null\n\n  while (true) {\n    switch (current._funADType) {\n      case \"now\":\n        const now = current as Now<A>\n        const bind = _popNextBind(bFirst, bRest)\n        if (!bind) return now.value\n        bFirst = null\n        current = bind(now.value)\n        break\n\n      case \"always\":\n      case \"once\":\n        current = new Now(current.get())\n        break\n\n      case \"suspend\":\n        current = (current as Suspend<A>).thunk()\n        break\n\n      case \"flatMap\":\n        if (bFirst) {\n          if (!bRest) bRest = []\n          bRest.push(bFirst)\n        }\n        const fm = current as FlatMap<any, any>\n        bFirst = fm.f\n        current = fm.source\n        break\n    }\n  }\n}\n\n/**\n * Implementation for `Eval.sequence`.\n * @hidden\n */\nfunction evalSequence<A>(list: Eval<A>[] | Iterable<Eval<A>>): Eval<A[]> {\n  return Eval.of(() => iteratorOf(list))\n    .flatMap(cursor => evalSequenceLoop([], cursor))\n}\n\n/**\n * Recursive loop that goes through the given `cursor`, element by\n * element, gathering the results of all generated `Eval` elements.\n *\n * @hidden\n */\nfunction evalSequenceLoop<A>(acc: A[], cursor: IteratorLike<Eval<A>>): Eval<A[]> {\n  while (true) {\n    const elem = cursor.next()\n    const isDone = elem.done\n\n    if (elem.value) {\n      const io: Eval<A> = elem.value\n      return io.flatMap(a => {\n        acc.push(a)\n        if (isDone) return Eval.pure(acc)\n        return evalSequenceLoop(acc, cursor)\n      })\n    } else {\n      /* istanbul ignore else */\n      if (isDone) return Eval.pure(acc)\n    }\n  }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  CompositeError,\n  IllegalStateError,\n  IllegalArgumentError\n} from \"funfix-core\"\n\n/**\n * `ICancelable` represents a one-time idempotent action that can be\n * used to cancel async computations, or to release resources that\n * active data sources are holding.\n *\n * It is similar in spirit to `java.io.Closeable`, but without the I/O\n * focus, or to `IDisposable` in Microsoft .NET.\n *\n * ```typescript\n * // Scheduling execution with a 10 seconds delay\n * const ref = setTimeout(() => console.log(\"Hello1\"), 10000)\n * const task = Cancelable.of(() => clearTimeout(ref))\n *\n * // If we change our mind\n * task.cancel()\n * ```\n *\n * In case some API requires the return of an `ICancelable` reference,\n * but there isn't anything that can be canceled, then\n * {@link Cancelable.empty} can be used to return a reusable reference\n * that doesn't do anything when canceled.\n *\n * ```typescript\n * const task = Cancelable.empty()\n *\n * // It's a no-op, doesn't do anything\n * task.cancel()\n * ```\n *\n * Implementation sample:\n *\n * ```typescript\n * class MyCancelable implements ICancelable {\n *   // Idempotency guard\n *   private _isCanceled: boolean = false\n *\n *   cancel() {\n *     // We need an idempotency guarantee, any side-effects\n *     // need to happen only once\n *     if (!this._isCanceled) {\n *       this._isCanceled = true\n *       console.log(\"Was canceled!\")\n *     }\n *   }\n * }\n * ```\n */\nexport interface ICancelable {\n  cancel(): void\n}\n\n/**\n * `Cancelable` is an {@link ICancelable} class providing useful\n * builders for simple cancelable references.\n */\nexport abstract class Cancelable implements ICancelable {\n  abstract cancel(): void\n\n  /**\n   * Lifts any callback into a `Cancelable` reference.\n   *\n   * ```typescript\n   * const task = Cancelable.of(() => {\n   *   console.log(\"I was canceled!\")\n   * })\n   *\n   * task.cancel()\n   * //=> I was canceled!\n   * ```\n   *\n   * The returned reference has guaranteed idempotence, so\n   * calling it multiple times will trigger the given\n   * callback only once.\n   */\n  static of(cb: () => void): Cancelable {\n    return new WrapFn(cb)\n  }\n\n  /**\n   * Returns a reusable `Cancelable` reference that doesn't\n   * do anything on `cancel`.\n   */\n  static empty(): Cancelable {\n    return Empty\n  }\n\n  /**\n   * Returns a [[Cancelable]] implementation that represents an\n   * immutable list of [[Cancelable]] references which can be canceled\n   * as a group.\n   *\n   * ```typescript\n   * const list = Cancelable.collection(\n   *   Cancelable.of(() => console.log(\"Cancelled #1\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #2\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #3\"))\n   * )\n   *\n   * list.cancel()\n   * //=> Cancelled #1\n   * //=> Cancelled #2\n   * //=> Cancelled #3\n   * ```\n   *\n   * @param refs is the array of references to cancel when\n   *        cancellation is triggered\n   */\n  static collection(...refs: Array<ICancelable>): Cancelable {\n    return new CollectionCancelable(refs)\n  }\n\n  /**\n   * Utility that cancels a list of cancelable references, delaying\n   * any thrown exceptions until all references have been cancelled.\n   *\n   * In case multiple exceptions are caught, then the thrown exception\n   * is going to be a `CompositeError`.\n   */\n  static cancelAll(refs: Cancelable[]): void {\n    let errors: any[] | null = null\n    for (const c of refs) {\n      try {\n        c.cancel()\n      } catch (e) {\n        if (!errors) errors = [e]\n        else errors.push(e)\n      }\n    }\n\n    if (!errors)\n      return\n    else if (errors.length === 1)\n      throw errors[0]\n    else\n      throw new CompositeError(errors)\n  }\n}\n\n/**\n * Concrete [[Cancelable]] implementation that wraps a callback.\n *\n * Implementation is package private, use {@link Cancelable.of}\n * to instantiate it.\n *\n * @Private\n * @Hidden\n */\nclass WrapFn extends Cancelable {\n  protected thunk: null | (() => void)\n\n  constructor(cb: () => void) {\n    super()\n    this.thunk = cb\n  }\n\n  cancel() {\n    if (this.thunk !== null) {\n      const ref = this.thunk\n      this.thunk = null\n      ref()\n    }\n  }\n}\n\n/**\n * A `DummyCancelable` is for {@link ICancelable} references that\n * don't do anything on `cancel()` and thus can be ignored.\n *\n * The common supertype of {@link Cancelable.empty} and\n * {@link BoolCancelable.alreadyCanceled}.\n */\nexport class DummyCancelable implements ICancelable {\n  protected readonly _funIsDummy = true\n\n  cancel(): void {\n  }\n}\n\n/**\n * Reusable [[Cancelable]] reference that doesn't do anything on\n * cancel.\n *\n * Implementation is package private, to access it use\n * [[Cancelable.empty]].\n *\n * @Hidden\n */\nconst Empty: ICancelable =\n  new DummyCancelable()\n\n/**\n * `IBoolCancelable` represents a {@link ICancelable} that can be queried\n * for the canceled status.\n */\nexport interface IBoolCancelable extends ICancelable {\n  /**\n   * Return `true` in case this cancelable hasn't been canceled,\n   * or `false` otherwise.\n   *\n   * ```typescript\n   * const ref = BoolCancelable.of()\n   *\n   * ref.isCanceled() // false\n   * ref.cancel()\n   * ref.isCanceled() // true\n   * ```\n   */\n  isCanceled(): boolean\n}\n\n/**\n * `BoolCancelable` is an {@link IBoolCancelable} class providing useful\n * builders for cancelable references that can be queried for their\n * canceled status.\n */\nexport abstract class BoolCancelable implements IBoolCancelable {\n  /** Inherited from {@link IBoolCancelable.isCanceled}. */\n  abstract isCanceled(): boolean\n\n  /** Inherited from {@link ICancelable.cancel}. */\n  abstract cancel(): void\n\n  /**\n   * Lifts any callback into a `BoolCancelable` reference.\n   *\n   * ```typescript\n   * const task = BoolCancelable.of(() => {\n   *   console.log(\"I was canceled!\")\n   * })\n   *\n   * task.isCanceled()\n   * //=> false\n   *\n   * task.cancel()\n   * //=> I was canceled!\n   *\n   * task.isCanceled()\n   * //=> true\n   * ```\n   *\n   * The returned reference has guaranteed idempotence, so\n   * calling it multiple times will trigger the given\n   * callback only once.\n   */\n  public static of(cb: () => void): BoolCancelable {\n    return new BoolWrapFn(cb)\n  }\n\n  /**\n   * Returns a [[BoolCancelable]] implementation that doesn't do\n   * anything on `cancel` except for changing the status of `isCanceled`\n   * from `false` to `true`.\n   *\n   * ```typescript\n   * const task = BoolCancelable.empty()\n   *\n   * task.isCanceled()\n   * //=> false\n   *\n   * task.cancel()\n   * task.isCanceled()\n   * //=> true\n   * ```\n   */\n  public static empty(): BoolCancelable {\n    return new BoolEmpty()\n  }\n\n  /**\n   * Returns a [[BoolCancelable]] reference that is already canceled.\n   *\n   * ```typescript\n   * const ref = BoolCancelable.alreadyCanceled()\n   *\n   * ref.isCanceled()\n   * //=> true\n   *\n   * // Doesn't do anything, it's a no-op\n   * ref.cancel()\n   * ```\n   *\n   * The implementation returns the same reusable reference.\n   */\n  public static alreadyCanceled(): BoolCancelable {\n    return AlreadyCanceledRef\n  }\n\n  /**\n   * Returns a [[BoolCancelable]] implementation that represents an\n   * immutable list of [[Cancelable]] references which can be\n   * canceled as a group.\n   *\n   * ```typescript\n   * const list = BoolCancelable.collection(\n   *   Cancelable.of(() => console.log(\"Cancelled #1\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #2\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #3\"))\n   * )\n   *\n   * list.cancel()\n   * //=> Cancelled #1\n   * //=> Cancelled #2\n   * //=> Cancelled #3\n   * ```\n   *\n   * @param refs is the array of references to cancel when\n   *        cancellation is triggered\n   */\n  public static collection(...refs: Array<ICancelable>): BoolCancelable {\n    return new CollectionCancelable(refs)\n  }\n}\n\n/**\n * [[Cancelable]] implementation that represents an immutable list of\n * [[Cancelable]] references which can be canceled as a group.\n *\n * Implementation is package private, to access it use\n * [[Cancelable.collection]].\n *\n * @Hidden\n */\nclass CollectionCancelable extends BoolCancelable {\n  private _refs?: ICancelable[]\n\n  constructor(refs: ICancelable[]) {\n    super()\n    this._refs = refs\n  }\n\n  public isCanceled(): boolean {\n    return !this._refs\n  }\n\n  public cancel(): void {\n    if (this._refs)\n      try {\n        Cancelable.cancelAll(this._refs)\n      } finally {\n        delete this._refs\n      }\n  }\n}\n\n/**\n * Concrete [[BoolCancelable]] implementation that wraps a callback.\n *\n * Implementation is package private, use [[BoolCancelable.of]]\n * to instantiate it.\n *\n * @Hidden\n */\nclass BoolWrapFn extends WrapFn implements BoolCancelable {\n  isCanceled() {\n    return this.thunk === null\n  }\n}\n\n/**\n * Concrete [[BoolCancelable]] implementation that doesn't do\n * anything on `cancel` except for changing the status of `isCanceled`\n * from `false` to `true`.\n *\n * Implementation is package private, use [[BoolCancelable.empty]]\n * to instantiate it.\n *\n * @Hidden\n */\nclass BoolEmpty extends BoolCancelable {\n  private canceled: boolean = false\n\n  isCanceled(): boolean {\n    return this.canceled\n  }\n\n  public cancel(): void {\n    this.canceled = true\n  }\n}\n\n/**\n * Implementation for {@link BoolCancelable.alreadyCanceled}.\n *\n * @Hidden\n */\nclass AlreadyCanceledBoolCancelable\n  extends DummyCancelable implements IBoolCancelable {\n\n  isCanceled() {\n    return true\n  }\n}\n\n/**\n * Reusable [[BoolCancelable]] reference that's already canceled.\n *\n * Implementation is package private, to access it use\n * [[BoolCancelable.alreadyCanceled]].\n *\n * @Hidden\n */\nconst AlreadyCanceledRef: BoolCancelable =\n  new AlreadyCanceledBoolCancelable()\n\n/**\n * Represents a type of [[ICancelable]] that can hold\n * an internal reference to another cancelable (and thus\n * has to support the `update` operation).\n *\n * On assignment, if this cancelable is already\n * canceled, then no assignment should happen and the update\n * reference should be canceled as well.\n */\nexport interface IAssignCancelable extends IBoolCancelable {\n  /**\n   * Updates the internal reference of this assignable cancelable\n   * to the given value.\n   *\n   * If this cancelable is already canceled, then `value` is\n   * going to be canceled on assignment as well.\n   */\n  update(value: ICancelable): this\n}\n\n/**\n * `AssignCancelable` is an {@link IAssignCancelable} class providing\n * useful builders for cancelable references that can be assigned.\n */\nexport abstract class AssignCancelable implements IAssignCancelable {\n  /** Inherited from {@link IAssignCancelable.update}. */\n  abstract update(value: ICancelable): this\n\n  /** Inherited from {@link IBoolCancelable.isCanceled}. */\n  abstract isCanceled(): boolean\n\n  /** Inherited from {@link ICancelable.cancel}. */\n  abstract cancel(): void\n\n  /**\n   * Returns an [[AssignCancelable]] reference that is already\n   * canceled.\n   *\n   * ```typescript\n   * const ref = AssignCancelable.alreadyCanceled()\n   * ref.isCanceled() //=> true\n   *\n   * const c = BooleanCancelable.empty()\n   * ref.update(c) // cancels c\n   * c.isCanceled() // true\n   * ```\n   *\n   * The implementation returns the same reusable reference.\n   */\n  public static alreadyCanceled(): AssignCancelable {\n    return AlreadyCanceledAssignCancelableRef\n  }\n\n  /**\n   * Returns a new [[AssignCancelable]] that's empty.\n   *\n   * The returned reference is an instance of\n   * [[MultiAssignCancelable]], but this is an implementation\n   * detail that may change in the future.\n   */\n  public static empty(): AssignCancelable {\n    return MultiAssignCancelable.empty()\n  }\n\n  /**\n   * Initiates an [[AssignCancelable]] reference and assigns it\n   * a reference that wraps the given `cb` callback.\n   *\n   * So this code:\n   *\n   * ```typescript\n   * AssignCancelable.of(() => console.log(\"cancelled\"))\n   * ```\n   *\n   * Is equivalent to this:\n   *\n   * ```typescript\n   * const ref = AssignCancelable.empty()\n   * ref.update(Cancelable.of(() => console.log(\"cancelled\")))\n   * ```\n   */\n  public static of(cb: () => void): AssignCancelable {\n    return MultiAssignCancelable.of(cb)\n  }\n}\n\n/**\n * Internal reusable class for an {@link IAssignCancelable} that\n * is already cancelled.\n *\n * @Hidden\n */\nclass AlreadyCanceledAssignCancelable\n  extends DummyCancelable implements IAssignCancelable {\n\n  isCanceled() { return true }\n  cancel() {}\n\n  update(value: ICancelable) {\n    value.cancel()\n    return this\n  }\n}\n\n/**\n * Internal reusable reference for an {@link IAssignCancelable} that\n * is already cancelled.\n *\n * @Hidden\n */\nconst AlreadyCanceledAssignCancelableRef: AssignCancelable =\n  new AlreadyCanceledAssignCancelable()\n\n/**\n * The `MultiAssignCancelable` is an {@link IAssignCancelable} whose\n * underlying cancelable reference can be swapped for another.\n *\n * Example:\n *\n * ```typescript\n * const ref = MultiAssignCancelable()\n * ref.update(c1) // sets the underlying cancelable to c1\n * ref.update(c2) // swaps the underlying cancelable to c2\n *\n * ref.cancel() // also cancels c2\n * ref := c3 // also cancels c3, because s is already canceled\n * ```\n *\n * Also see [[SerialCancelable]], which is similar, except that it\n * cancels the old cancelable upon assigning a new cancelable.\n */\nexport class MultiAssignCancelable implements IAssignCancelable {\n  private _underlying?: ICancelable\n  private _canceled: boolean\n\n  constructor(initial?: ICancelable) {\n    this._underlying = initial\n    this._canceled = false\n  }\n\n  /** @inheritdoc */\n  public update(value: ICancelable): this {\n    if (this._canceled) value.cancel()\n    else this._underlying = value\n    return this\n  }\n\n  /** @inheritdoc */\n  public isCanceled(): boolean {\n    return this._canceled\n  }\n\n  /** @inheritdoc */\n  public cancel(): void {\n    if (!this._canceled) {\n      this._canceled = true\n      if (this._underlying) {\n        this._underlying.cancel()\n        delete this._underlying\n      }\n    }\n  }\n\n  /**\n   * In case the underlying reference is also a `MultiAssignCancelable`, then\n   * collapse its state into this one.\n   *\n   * ```typescript\n   * const c = Cancelable.of(() => console.info(\"Cancelled!\"))\n   *\n   * const mc1 = new MultiAssignCancelable()\n   * mc1.update(c)\n   *\n   * const mc2 = new MultiAssignCancelable()\n   * mc2.update(mc1)\n   *\n   * // After this the underlying reference of `mc2` becomes `c`\n   * mc2.collapse()\n   * ```\n   */\n  public collapse(): this {\n    if (this._underlying && this._underlying instanceof MultiAssignCancelable) {\n      const ref = this._underlying\n      this._underlying = ref._underlying\n      this._canceled = ref._canceled\n    }\n    return this\n  }\n\n  /**\n   * Sets the underlying cancelable reference to `undefined`,\n   * useful for garbage-collecting purposes.\n   */\n  public clear(): this {\n    if (!this._canceled) this._underlying = undefined\n    return this\n  }\n\n  /**\n   * Returns a new [[MultiAssignCancelable]] that's empty.\n   */\n  public static empty(): MultiAssignCancelable {\n    return new MultiAssignCancelable()\n  }\n\n  /**\n   * Initiates an [[MultiAssignCancelable]] reference and assigns it\n   * a reference that wraps the given `cb` callback.\n   *\n   * So this code:\n   *\n   * ```typescript\n   * MultiAssignCancelable.of(() => console.log(\"cancelled\"))\n   * ```\n   *\n   * Is equivalent to this:\n   *\n   * ```typescript\n   * const ref = MultiAssignCancelable.empty()\n   * ref.update(Cancelable.of(() => console.log(\"cancelled\")))\n   * ```\n   */\n  public static of(cb: () => void): MultiAssignCancelable {\n    return new MultiAssignCancelable(Cancelable.of(cb))\n  }\n}\n\n/**\n * The `SerialCancelable` is an {@link IAssignCancelable} whose underlying\n * cancelable reference can be swapped for another and on each\n * swap the previous reference gets canceled.\n *\n * Example:\n *\n * ```typescript\n * const ref = SerialCancelable()\n * ref.update(c1) // sets the underlying cancelable to c1\n * ref.update(c2) // cancels c1, swaps the underlying cancelable to c2\n *\n * ref.cancel() // also cancels c2\n * ref := c3 // also cancels c3, because s is already canceled\n * ```\n *\n * Also see [[SerialCancelable]], which is similar, except that it\n * cancels the old cancelable upon assigning a new cancelable.\n */\nexport class SerialCancelable implements IAssignCancelable {\n  private _underlying?: ICancelable\n  private _canceled: boolean\n\n  constructor(initial?: ICancelable) {\n    this._underlying = initial\n    this._canceled = false\n  }\n\n  public update(value: ICancelable): this {\n    if (this._canceled) value.cancel(); else {\n      if (this._underlying) this._underlying.cancel()\n      this._underlying = value\n    }\n    return this\n  }\n\n  public isCanceled(): boolean {\n    return this._canceled\n  }\n\n  public cancel(): void {\n    if (!this._canceled) {\n      this._canceled = true\n      if (this._underlying) {\n        this._underlying.cancel()\n        delete this._underlying\n      }\n    }\n  }\n\n  /**\n   * Returns a new [[SerialCancelable]] that's empty.\n   */\n  public static empty(): SerialCancelable {\n    return new SerialCancelable()\n  }\n\n  /**\n   * Initiates an [[SerialCancelable]] reference and assigns it\n   * a reference that wraps the given `cb` callback.\n   *\n   * So this code:\n   *\n   * ```typescript\n   * SerialCancelable.of(() => console.log(\"cancelled\"))\n   * ```\n   *\n   * Is equivalent to this:\n   *\n   * ```typescript\n   * const ref = SerialCancelable.empty()\n   * ref.update(Cancelable.of(() => console.log(\"cancelled\")))\n   * ```\n   */\n  public static of(cb: () => void): SerialCancelable {\n    return new SerialCancelable(Cancelable.of(cb))\n  }\n}\n\n/**\n * The `SingleAssignCancelable` is a [[Cancelable]] that can be\n * assigned only once to another cancelable reference.\n *\n * Example:\n *\n * ```typescript\n * const ref = SingleAssignCancelable()\n * ref.update(c1) // sets the underlying cancelable to c1\n *\n * ref.update(c2) // throws IllegalStateError\n * ```\n *\n * See [[MultiAssignCancelable]] for a similar type that can be\n * assigned multiple types.\n */\nexport class SingleAssignCancelable implements IAssignCancelable {\n  private _wasAssigned: boolean\n  private _canceled: boolean\n  private _underlying?: ICancelable\n\n  constructor() {\n    this._canceled = false\n    this._wasAssigned = false\n  }\n\n  /** @inheritdoc */\n  public update(value: ICancelable): this {\n    if (this._wasAssigned)\n      throw new IllegalStateError(\"SingleAssignCancelable#update multiple times\")\n\n    this._wasAssigned = true\n    if (this._canceled) value.cancel()\n    else this._underlying = value\n    return this\n  }\n\n  /** @inheritdoc */\n  public isCanceled(): boolean {\n    return this._canceled\n  }\n\n  /** @inheritdoc */\n  public cancel(): void {\n    if (!this._canceled) {\n      this._canceled = true\n      if (this._underlying) {\n        this._underlying.cancel()\n        delete this._underlying\n      }\n    }\n  }\n\n  /**\n   * Returns a new [[SingleAssignCancelable]] that's empty.\n   */\n  public static empty(): SingleAssignCancelable {\n    return new SingleAssignCancelable()\n  }\n\n  /**\n   * Initiates an [[SingleAssignCancelable]] reference and assigns it\n   * a reference that wraps the given `cb` callback.\n   *\n   * So this code:\n   *\n   * ```typescript\n   * SingleAssignCancelable.of(() => console.log(\"cancelled\"))\n   * ```\n   *\n   * Is equivalent to this:\n   *\n   * ```typescript\n   * const ref = SingleAssignCancelable.empty()\n   * ref.update(Cancelable.of(() => console.log(\"cancelled\")))\n   * ```\n   */\n  public static of(cb: () => void): SingleAssignCancelable {\n    const ref = new SingleAssignCancelable()\n    ref.update(Cancelable.of(cb))\n    return ref\n  }\n}\n\n/**\n * Represents a composite of cancelable references that are stacked,\n * so you can push a new reference, or pop an existing one and when\n * it gets canceled, then the whole stack gets canceled.\n *\n * The references are pushed and popped in a FIFO order.\n *\n * Used in the implementation of `Task`.\n *\n * @final\n */\nexport class StackedCancelable implements IBoolCancelable {\n  private _refs?: ICancelable[]\n\n  constructor(initial?: ICancelable[]) {\n    this._refs = initial ? initial.slice(0) : []\n  }\n\n  cancel(): void {\n    if (this._refs)\n      try {\n        Cancelable.cancelAll(this._refs)\n      } finally {\n        delete this._refs\n      }\n  }\n\n  isCanceled(): boolean {\n    return !this._refs\n  }\n\n  /**\n   * Pushes a cancelable reference on the stack, to be popped or\n   * cancelled later in FIFO order.\n   */\n  push(value: ICancelable): this {\n    if (this._refs) {\n      this._refs.push(value)\n    } else {\n      value.cancel()\n    }\n    return this\n  }\n\n  /**\n   * Removes a cancelable reference from the stack in FIFO order.\n   *\n   * @return the cancelable reference that was removed.\n   */\n  pop(): ICancelable {\n    if (!this._refs) return Cancelable.empty()\n    return this._refs.pop() || Cancelable.empty()\n  }\n\n  /**\n   * Returns a new {@link StackedCancelable} that's empty.\n   */\n  static empty(): StackedCancelable {\n    return new StackedCancelable()\n  }\n\n  /**\n   * Returns a {@link StackedCancelable} that's initialized with\n   * the given list of cancelable references.\n   *\n   * ```typescript\n   * const list = StackedCancelable.collection(\n   *   Cancelable.of(() => console.log(\"Cancelled #1\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #2\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #3\"))\n   * )\n   *\n   * // Popping cancelable no. 3 from the stack\n   * list.pop()\n   *\n   * list.cancel()\n   * //=> Cancelled #1\n   * //=> Cancelled #2\n   * ```\n   *\n   * @param refs is the array of references to cancel when\n   *        cancellation is triggered\n   */\n  static collection(...refs: Array<ICancelable>): StackedCancelable {\n    return new StackedCancelable(refs)\n  }\n}\n\n/**\n * Represents an {@link IAssignCancelable} whose underlying\n * cancelable reference can be swapped for another. It can\n * be \"chained\" to another `ChainedCancelable`, forwarding all\n * operations to it.\n *\n * For most purposes it works like a {@link MultiAssignCancelable}:\n *\n * ```typescript\n *   const s = ChainedCancelable.empty()\n *   s.update(c1) // sets the underlying cancelable to c1\n *   s.update(c2) // swaps the underlying cancelable to c2\n *\n *   s.cancel() // also cancels c2\n *   s.update(c3) // also cancels c3, because s is already canceled\n * ```\n *\n * However it can also be linked to another `ChainedCancelable`\n * reference, forwarding all requests to it:\n *\n * ```typescript\n *   const source = ChainedCancelable.empty()\n *   const child1 = ChainedCancelable.empty()\n *   const child2 = ChainedCancelable.empty()\n *\n *   // Hence forth forwards all operations on `child1` to `source`\n *   child1.chainTo(source)\n *\n *   // Also forwarding all `child2` operations to `source`.\n *   // This happens because `child1` was linked to `source` first\n *   // but order matters, as `child2` will be linked directly\n *   // to `source` and not to `child1`, in order for `child1` to\n *   // be garbage collected if it goes out of scope ;-)\n *   child2.chainTo(child1)\n *\n *   // Source will be updated with a new Cancelable ref\n *   child1.update(Cancelable.from(() => println(\"Cancelling (1)\")))\n *\n *   // Source will be updated with another Cancelable ref\n *   child2.update(Cancelable.from(() => println(\"Cancelling (2)\")))\n *\n *   source.cancel()\n *   //=> Cancelling (2)\n * ```\n *\n * This implementation is a special purpose {@link IAssignCancelable},\n * much like {@link StackedCancelable}, to be used in `flatMap`\n * implementations that need it.\n *\n * The problem that it solves in Funfix's codebase is that various\n * `flatMap` implementations need to be memory safe.\n * By \"chaining\" cancelable references, we allow the garbage collector\n * to get rid of references created in a `flatMap` loop, the goal\n * being to consume a constant amount of memory. Thus this\n * implementation is used for the {@link Future} implementation.\n *\n * If unsure about what to use, then you probably don't need\n * {@link ChainedCancelable}. Use {@link MultiAssignCancelable} or\n * {@link SingleAssignCancelable} for most purposes.\n */\nexport class ChainedCancelable implements IAssignCancelable {\n  private _underlying?: ICancelable\n  private _chained: boolean\n\n  constructor(initial?: ICancelable) {\n    // Reference cannot be null, because that signals a cancelled `this`\n    this._underlying = initial || Empty\n    this._chained = false\n  }\n\n  update(value: ICancelable): this {\n    if (!value) throw new IllegalArgumentError(`cannot update to null value`)\n    // A null underlying value signals a canceled `this`\n    if (!this._underlying) {\n      value.cancel()\n      return this\n    }\n    else if (this._chained) {\n      (this._underlying as ChainedCancelable).update(value)\n      return this\n    }\n    else {\n      this._underlying = value\n      return this\n    }\n  }\n\n  cancel(): void {\n    if (this._underlying) {\n      this._underlying.cancel()\n      this._chained = false\n      delete this._underlying\n    }\n  }\n\n  /**\n   * Clears the underlying reference, resetting it to a dummy\n   * reference.\n   *\n   * To be used for garbage collecting purposes.\n   */\n  clear(): void {\n    if (this._underlying) {\n      this._underlying = Empty\n      this._chained = false\n    }\n  }\n\n  isCanceled(): boolean {\n    return !this._underlying || (\n      this._chained && (this._underlying as ChainedCancelable).isCanceled())\n  }\n\n  /**\n   * Chains this `ChainedCancelable` to another reference,\n   * such that all operations are forwarded to `other`.\n   *\n   * ```typescript\n   * const source = ChainedCancelable.empty()\n   * const child1 = ChainedCancelable.empty()\n   * const child2 = ChainedCancelable.empty()\n   *\n   * // Hence forth forwards all operations on `child1` to `source`\n   * child1.chainTo(source)\n   *\n   * // Also forwarding all `child2` operations to `source`\n   * // (this happens because `child1` was linked to `source` first\n   * // but order matters ;-))\n   * child2.chainTo(child1)\n   *\n   * // Source will be updated with a new Cancelable ref\n   * child1.update( Cancelable.of(() => console.log(\"Cancelling (1)\")) )\n   *\n   * // Source will be updated with another Cancelable ref\n   * child2.update( Cancelable.of (() => console.log(\"Cancelling (2)\")) )\n   *\n   * source.cancel()\n   * //=> Cancelling (2)\n   * ```\n   */\n  chainTo(other: ChainedCancelable): this {\n    if (!other) throw new IllegalArgumentError(`cannot chain to null value`)\n    // Short-circuit in case we have the same reference\n    if (other === this) return this\n\n    if (!this._underlying) {\n      other.cancel()\n      return this\n    }\n\n    // Getting the last ChainedCancelable reference in the\n    // chain, since that's the reference that we care about!\n    let ref: ChainedCancelable | undefined = other\n    let keepSearching = true\n\n    while (ref && keepSearching) {\n      if (ref._chained) {\n        const ref2: ICancelable | undefined = ref._underlying\n        // Interrupt infinite loop if we see the same reference\n        if (ref2 === this) return this\n        ref = ref2 as ChainedCancelable\n        keepSearching = !!ref2\n      } else {\n        if (!ref._underlying) ref = undefined\n        keepSearching = false\n      }\n    }\n\n    // A null or undefined reference means that `other` is already\n    // cancelled, therefore we are cancelling `this` as well\n    if (!ref) {\n      this.cancel()\n    } else {\n      const prev = this._underlying\n      this._underlying = ref\n      this._chained = true\n\n      if (!(prev instanceof DummyCancelable))\n        ref.update(prev)\n    }\n    return this\n  }\n\n  /**\n   * Returns a new, empty [[ChainedCancelable]].\n   */\n  public static empty(): ChainedCancelable {\n    return new ChainedCancelable()\n  }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IEquals, IllegalArgumentError } from \"funfix-core\"\n\n/**\n * A `TimeUnit` represents time durations at a given unit of\n * granularity and provides utility methods to convert across units,\n * and to perform timing and delay operations in these units.\n *\n * A `TimeUnit` does not maintain time information, but only helps\n * organize and use time representations that may be maintained\n * separately across various contexts. A nanosecond is defined as one\n * thousandth of a microsecond, a microsecond as one thousandth of a\n * millisecond, a millisecond as one thousandth of a second, a minute\n * as sixty seconds, an hour as sixty minutes, and a day as twenty\n * four hours.\n *\n * `TimeUnit` is an enumeration and in usage the already defined\n * constants should be used:\n *\n *  - [[NANOSECONDS]]\n *  - [[MICROSECONDS]]\n *  - [[MILLISECONDS]]\n *  - [[SECONDS]]\n *  - [[MINUTES]]\n *  - [[HOURS]]\n *  - [[DAYS]]\n *\n * Example:\n *\n * ```typescript\n * // Converting 10 minutes to nanoseconds\n * MINUTES.toNanos(10)\n * // Equivalent with the above:\n * NANOSECONDS.convert(10, MINUTES)\n * ```\n */\nexport abstract class TimeUnit {\n  /**\n   * Converts the given time duration in the given unit to this unit.\n   * Conversions from finer to coarser granularities truncate, so lose\n   * precision. For example, converting `999` milliseconds to seconds\n   * results in `0`. Conversions from coarser to finer granularities\n   * with arguments that would numerically overflow saturate to\n   * `Number.MAX_VALUE` if negative or `MAX_VALUE` if positive.\n   *\n   * For example, to convert 10 minutes to milliseconds, use:\n   *\n   * ```typescript\n   * MILLISECONDS.convert(10, MINUTES)\n   * // ... or ...\n   * MINUTES.toMillis(10)\n   * ```\n   *\n   * @param duration the time duration in the given `unit`\n   * @param unit the unit of the `duration` argument\n   *\n   * @return the converted duration in this unit, or `Number.MIN_VALUE`\n   * if conversion would negatively overflow, or `Number.MAX_VALUE`\n   * if it would positively overflow\n   */\n  abstract convert(duration: number, unit: TimeUnit): number\n\n  /**\n   * Converts the given `d` value to nanoseconds.\n   *\n   * Equivalent with `NANOSECONDS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toNanos(d: number): number\n\n  /**\n   * Converts the given `d` value to microseconds.\n   *\n   * Equivalent with `MICROSECONDS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toMicros(d: number): number\n\n  /**\n   * Converts the given `d` value to milliseconds.\n   *\n   * Equivalent with `MILLISECONDS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toMillis(d: number): number\n\n  /**\n   * Converts the given `d` value to seconds.\n   *\n   * Equivalent with `SECONDS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toSeconds(d: number): number\n\n  /**\n   * Converts the given `d` value to minutes.\n   *\n   * Equivalent with `MINUTES.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toMinutes(d: number): number\n\n  /**\n   * Converts the given `d` value to hours.\n   *\n   * Equivalent with `HOURS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toHours(d: number): number\n\n  /**\n   * Converts the given `d` value to days.\n   *\n   * Equivalent with `DAYS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toDays(d: number): number\n\n  /**\n   * A number representing the unit's ordering in the `TimeUnit`\n   * enumeration, useful for doing comparisons to find out which unit\n   * is more coarse grained.\n   *\n   * ```typescript\n   * MINUTES.ord < DAYS.ord // true\n   * SECONDS.ord > MICROSECONDS.org // true\n   * ```\n   */\n  abstract ord: number\n\n  /**\n   * A human readable label for this unit.\n   */\n  abstract label: string\n\n  /** Override for `Object.toString`. */\n  toString(): string {\n    return this.label.toUpperCase()\n  }\n}\n\n/** @hidden */ const C0 = 1\n/** @hidden */ const C1 = C0 * 1000\n/** @hidden */ const C2 = C1 * 1000\n/** @hidden */ const C3 = C2 * 1000\n/** @hidden */ const C4 = C3 * 60\n/** @hidden */ const C5 = C4 * 60\n/** @hidden */ const C6 = C5 * 24\n\n/** @hidden */ const MIN = -9007199254740992\n/** @hidden */ const MAX = 9007199254740992\n\n/** @hidden */\nconst trunc: (x: number) => number = Math.trunc ||\n  /* istanbul ignore next */\n  function (x) {\n    if (isNaN(x)) return NaN\n    if (x > 0) return Math.floor(x)\n    return Math.ceil(x)\n  }\n\n/** @hidden */\nfunction x(d: number, m: number, over: number): number {\n  if (d > over) return MAX\n  if (d < -over) return MIN\n  return d * m\n}\n\n/** @hidden */\nclass Nanoseconds extends TimeUnit {\n  ord: number = 0\n  label = \"nanoseconds\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toNanos(duration) }\n  toNanos(d: number): number { return d }\n  toMicros(d: number): number { return trunc(d / (C1 / C0)) }\n  toMillis(d: number): number { return trunc(d / (C2 / C0)) }\n  toSeconds(d: number): number { return trunc(d / (C3 / C0)) }\n  toMinutes(d: number): number { return trunc(d / (C4 / C0)) }\n  toHours(d: number): number { return trunc(d / (C5 / C0)) }\n  toDays(d: number): number { return trunc(d / (C6 / C0)) }\n}\n\n /**\n  * Time unit for representing nanoseconds, where 1 nanosecond is\n  * one thousandth of a microsecond.\n  */\nexport const NANOSECONDS: TimeUnit =\n  new Nanoseconds()\n\n/** @hidden */\nclass Microseconds extends TimeUnit {\n  ord: number = 1\n  label = \"microseconds\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toMicros(duration) }\n  toNanos(d: number): number { return x(d, C1 / C0, trunc(MAX / (C1 / C0))) }\n  toMicros(d: number): number { return d }\n  toMillis(d: number): number { return trunc(d / (C2 / C1)) }\n  toSeconds(d: number): number { return trunc(d / (C3 / C1)) }\n  toMinutes(d: number): number { return trunc(d / (C4 / C1)) }\n  toHours(d: number): number { return trunc(d / (C5 / C1)) }\n  toDays(d: number): number { return trunc(d / (C6 / C1)) }\n}\n\n /**\n  * Time unit for representing microseconds, where 1 microsecond is\n  * one thousandth of a millisecond.\n  */\nexport const MICROSECONDS: TimeUnit =\n  new Microseconds()\n\n/** @hidden */\nclass Milliseconds extends TimeUnit {\n  ord: number = 2\n  label = \"milliseconds\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toMillis(duration) }\n  toNanos(d: number): number { return x(d, C2 / C0, trunc(MAX / (C2 / C0))) }\n  toMicros(d: number): number { return x(d, C2 / C1, trunc(MAX / (C2 / C1))) }\n  toMillis(d: number): number { return d }\n  toSeconds(d: number): number { return trunc(d / (C3 / C2)) }\n  toMinutes(d: number): number { return trunc(d / (C4 / C2)) }\n  toHours(d: number): number { return trunc(d / (C5 / C2)) }\n  toDays(d: number): number { return trunc(d / (C6 / C2)) }\n}\n\n /**\n  * Time unit for representing milliseconds, where 1 millisecond is\n  * one thousandth of a second.\n  */\nexport const MILLISECONDS: TimeUnit =\n  new Milliseconds()\n\n/** @hidden */\nclass Seconds extends TimeUnit {\n  ord: number = 3\n  label = \"seconds\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toSeconds(duration) }\n  toNanos(d: number): number { return x(d, C3 / C0, trunc(MAX / (C3 / C0))) }\n  toMicros(d: number): number { return x(d, C3 / C1, trunc(MAX / (C3 / C1))) }\n  toMillis(d: number): number { return x(d, C3 / C2, trunc(MAX / (C3 / C2))) }\n  toSeconds(d: number): number { return d }\n  toMinutes(d: number): number { return trunc(d / (C4 / C3)) }\n  toHours(d: number): number { return trunc(d / (C5 / C3)) }\n  toDays(d: number): number { return trunc(d / (C6 / C3)) }\n}\n\n /**\n  * Time unit for representing seconds.\n  */\nexport const SECONDS: TimeUnit =\n  new Seconds()\n\n/** @hidden */\nclass Minutes extends TimeUnit {\n  ord: number = 4\n  label = \"minutes\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toMinutes(duration) }\n  toNanos(d: number): number { return x(d, C4 / C0, trunc(MAX / (C4 / C0))) }\n  toMicros(d: number): number { return x(d, C4 / C1, trunc(MAX / (C4 / C1))) }\n  toMillis(d: number): number { return x(d, C4 / C2, trunc(MAX / (C4 / C2))) }\n  toSeconds(d: number): number { return x(d, C4 / C3, trunc(MAX / (C4 / C3))) }\n  toMinutes(d: number): number { return d }\n  toHours(d: number): number { return trunc(d / (C5 / C4)) }\n  toDays(d: number): number { return trunc(d / (C6 / C4)) }\n}\n\n /**\n  * Time unit for representing minutes.\n  */\nexport const MINUTES: TimeUnit =\n  new Minutes()\n\n/** @hidden */\nclass Hours extends TimeUnit {\n  ord: number = 5\n  label = \"hours\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toHours(duration) }\n  toNanos(d: number): number { return x(d, C5 / C0, trunc(MAX / (C5 / C0))) }\n  toMicros(d: number): number { return x(d, C5 / C1, trunc(MAX / (C5 / C1))) }\n  toMillis(d: number): number { return x(d, C5 / C2, trunc(MAX / (C5 / C2))) }\n  toSeconds(d: number): number { return x(d, C5 / C3, trunc(MAX / (C5 / C3))) }\n  toMinutes(d: number): number { return x(d, C5 / C4, trunc(MAX / (C5 / C4))) }\n  toHours(d: number): number { return d }\n  toDays(d: number): number { return trunc(d / (C6 / C5)) }\n}\n\n /**\n  * Time unit for representing hours.\n  */\nexport const HOURS: TimeUnit =\n  new Hours()\n\n/** @hidden */\nclass Days extends TimeUnit {\n  ord: number = 6\n  label = \"days\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toDays(duration) }\n  toNanos(d: number): number { return x(d, C6 / C0, trunc(MAX / (C6 / C0))) }\n  toMicros(d: number): number { return x(d, C6 / C1, trunc(MAX / (C6 / C1))) }\n  toMillis(d: number): number { return x(d, C6 / C2, trunc(MAX / (C6 / C2))) }\n  toSeconds(d: number): number { return x(d, C6 / C3, trunc(MAX / (C6 / C3))) }\n  toMinutes(d: number): number { return x(d, C6 / C4, trunc(MAX / (C6 / C4))) }\n  toHours(d: number): number { return x(d, C6 / C5, trunc(MAX / (C6 / C5))) }\n  toDays(d: number): number { return d }\n}\n\n /**\n  * Time unit for representing days.\n  */\nexport const DAYS: TimeUnit =\n  new Days()\n\n/**\n * A simple representation for time durations, based on [[TimeUnit]].\n */\nexport class Duration implements IEquals<Duration> {\n  public duration: number\n  public unit: TimeUnit\n\n  constructor(duration: number, unit: TimeUnit) {\n    if (isNaN(duration)) {\n      throw new IllegalArgumentError(\"NaN is not supported for a Duration\")\n    }\n    // Only integers allowed\n    this.duration = trunc(duration)\n    this.unit = unit\n  }\n\n  /**\n   * This method returns `true` if this duration is finite,\n   * or `false otherwise.\n   */\n  isFinite(): boolean { return isFinite(this.duration) }\n\n  /**\n   * Calculates the nanoseconds described by the source [[Duration]].\n   */\n  toNanos(): number {\n    return NANOSECONDS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the microseconds described by the source [[Duration]].\n   */\n  toMicros(): number {\n    return MICROSECONDS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the milliseconds described by the source [[Duration]].\n   */\n  toMillis(): number {\n    return MILLISECONDS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the seconds described by the source [[Duration]].\n   */\n  toSeconds(): number {\n    return SECONDS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the minutes described by the source [[Duration]].\n   */\n  toMinutes(): number {\n    return MINUTES.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the hours described by the source [[Duration]].\n   */\n  toHours(): number {\n    return HOURS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the days described by the source [[Duration]].\n   */\n  toDays(): number {\n    return DAYS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Returns a new `Duration` value that represents `this` converted\n   * to use the given `unit`.\n   *\n   * Note that this may be a lossy conversion, e.g. when converting\n   * 27 hours to 1 day, there's a loss of fidelity.\n   */\n  convertTo(unit: TimeUnit): Duration {\n    return new Duration(unit.convert(this.duration, this.unit), unit)\n  }\n\n  /**\n   * Negates `this` duration, by changing the sign.\n   */\n  negate(): Duration {\n    switch (this.duration) {\n      case Infinity: return Duration.negInf()\n      case -Infinity: return Duration.inf()\n      default:\n        return new Duration(-this.duration, this.unit)\n    }\n  }\n\n  /**\n   * Return the sum of `this` duration and `other`.\n   *\n   * Note that the `unit` used for the result will be the\n   * more finer grained one out of the two.\n   *\n   * ```typescript\n   * // Result will be 27 hours\n   * Duration.days(1).plus(Duration.hours(3))\n   * ```\n   */\n  plus(other: Duration): Duration {\n    if (!isFinite(this.duration)) {\n      if (!isFinite(other.duration) && this.duration !== other.duration) {\n        throw new IllegalArgumentError(\n          \"cannot deal with two infinities with different signs, \" +\n          \"as that would be a NaN\")\n      }\n      return this\n    } else if (other.duration === 0) {\n      return this\n    } else if (this.duration === 0) {\n      return other\n    }\n\n    if (!isFinite(other.duration)) return other\n\n    let d1: Duration = this\n    let d2: Duration = other\n    if (d2.unit.ord < d1.unit.ord) { d1 = other; d2 = this }\n\n    d2 = d2.convertTo(d1.unit)\n    return new Duration(d1.duration + d2.duration, d1.unit)\n  }\n\n  /**\n   * Subtracts the `other` duration from `this`.\n   *\n   * Note that the `unit` used for the result will be the\n   * more finer grained one out of the two:\n   *\n   * ```typescript\n   * // Result will be 21 hours\n   * Duration.days(1).minus(Duration.hours(3))\n   * ```\n   */\n  minus(other: Duration): Duration {\n    return this.plus(other.negate())\n  }\n\n  /** @inheritdoc */\n  equals(other: Duration): boolean {\n    function cmp(s: Duration, o: Duration) {\n      const n = s.unit.convert(o.duration, o.unit)\n      return n === s.duration\n    }\n\n    if (!isFinite(this.duration)) {\n      return !isFinite(other.duration) &&\n        this.duration === other.duration\n    }\n    return this.unit.ord <= other.unit.ord\n      ? cmp(this, other) : cmp(other, this)\n  }\n\n  /** @inheritdoc */\n  hashCode(): number {\n    if (this.isFinite()) {\n      return this.toNanos()\n    } else if (this.duration === Infinity) {\n      return 7540833725118015\n    } else {\n      return 422082410550358\n    }\n  }\n\n  toString(): string {\n    if (this.isFinite())\n      return `${this.duration} ${this.unit.label}`\n    else if (this.duration >= 0)\n      return \"[end of time]\"\n    else\n      return \"[beginning of time]\"\n  }\n\n  /**\n   * Wraps the argument in a `Duration.millis` reference, in case it's\n   * a number, otherwise returns the argument as is.\n   *\n   * In Javascript code it is customary to express durations with\n   * numbers representing milliseconds and in functions it's good\n   * to still allow developers to do that because it's the standard\n   * convention.\n   *\n   * Thus one can work with a union type like `number | Duration`.\n   * And in case a `number` is given, then it is interpreted as\n   * milliseconds.\n   *\n   * Usage:\n   *\n   * ```typescript\n   * function delay(d: number | Duration, r: () => {}) {\n   *   const millis = Duration.of(d).toMillis()\n   *   return setTimeout(r, millis)\n   * }\n   * ```\n   */\n  static of(value: number | Duration): Duration {\n    return typeof value === \"number\"\n      ? Duration.millis(value)\n      : value\n  }\n\n  /** Returns a zero length duration. */\n  static zero(): Duration {\n    return new Duration(0, DAYS)\n  }\n\n  /** Returns a [[Duration]] representing positive infinite. */\n  static inf(): Duration {\n    return new Duration(Infinity, DAYS)\n  }\n\n  /** Returns a [[Duration]] representing negative infinite. */\n  static negInf(): Duration {\n    return new Duration(-Infinity, DAYS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * nanoseconds.\n   */\n  static nanos(d: number): Duration {\n    return new Duration(d, NANOSECONDS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * microseconds.\n   */\n  static micros(d: number): Duration {\n    return new Duration(d, MICROSECONDS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * milliseconds.\n   */\n  static millis(d: number): Duration {\n    return new Duration(d, MILLISECONDS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * seconds.\n   */\n  static seconds(d: number): Duration {\n    return new Duration(d, SECONDS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * minutes.\n   */\n  static minutes(d: number): Duration {\n    return new Duration(d, MINUTES)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * hours.\n   */\n  static hours(d: number): Duration {\n    return new Duration(d, HOURS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * days.\n   */\n  static days(d: number): Duration {\n    return new Duration(d, DAYS)\n  }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * `DynamicRef` provides a binding mechanism where the current value is\n * found through dynamic scope, but where access to the variable itself is\n * resolved through static scope.\n *\n * The current value can be retrieved with the {@link DynamicRef.get} method.\n * New values should be pushed using the {@link DynamicRef.bind} method.\n *\n * Values pushed via `bind` only stay valid while its second argument,\n * a parameterless function (the `thunk`), executes. When that thunk finishes\n * execution, the reference reverts to the previous value.\n *\n * See {@link DynamicRef.bind} for a usage sample.\n *\n * @final\n */\nexport class DynamicRef<A> {\n  /** Previous states of the ref, to use in `revert`. */\n  private _previous: (() => A)[] = []\n\n  /** Returns the current value of this `DynamicRef`. */\n  get: () => A\n\n  private constructor(fn: () => A) {\n    this.get = fn\n  }\n\n  /**\n   * Updates the underlying of this `DynamicRef` to the given `value`.\n   *\n   * Note that the previous state can be reverted with\n   * [revert]{@link DynamicRef.revert}:\n   *\n   * ```typescript\n   * const ref = DynamicRef.of(() => \"initial\")\n   *\n   * ref.set(\"another\")\n   * ref.get() // another\n   *\n   * ref.revert()\n   * ref.get() // initial\n   * ```\n   */\n  set(value: A): void {\n    return this.setL(() => value)\n  }\n\n  /**\n   * Updates the underlying of this `DynamicRef` to values generated by the\n   * given `thunk`.\n   *\n   * Note that the previous state can be reverted with\n   * [revert]{@link DynamicRef.revert}:\n   *\n   * ```typescript\n   * const ref = DynamicRef.of(() => \"initial\")\n   *\n   * ref.setL(() => \"another\")\n   * ref.get() // another\n   *\n   * ref.revert()\n   * ref.get() // initial\n   * ```\n   */\n  setL(thunk: () => A): void {\n    this._previous.push(this.get)\n    this.get = thunk\n  }\n\n  /**\n   * Reverts this `DynamicRef` to a previous state, if a previous\n   * state is available due to calling [set]{@link DynamicRef.set} or\n   * [setL]{@link DynamicRef.setL}.\n   *\n   * ```typescript\n   * const ref = DynamicRef.of(() => \"initial\")\n   *\n   * ref.set(\"state 2\")\n   * ref.set(\"state 3\")\n   * ref.get() // Yields: state 3\n   *\n   * ref.revert()\n   * ref.get() // Yields: state 2\n   *\n   * ref.revert()\n   * ref.get() // Yields: initial\n   *\n   * ref.revert() // No-op\n   * ref.get() // Yields: initial\n   * ```\n   */\n  revert(): void {\n    const thunk = this._previous.pop()\n    if (thunk) this.get = thunk\n  }\n\n  /**\n   * Binds this `DynamicRef` to a different (strict) `value` that's going to be\n   * visible while executing `thunk` and then it will get reverted to\n   * its previous value.\n   *\n   * Sample:\n   *\n   * ```typescript\n   * const ref = DynamicRef.of(() => \"original\")\n   *\n   * ref.get() // original\n   *\n   * ref.bind(\"modified\", () => {\n   *   ref.get() // modified\n   * })\n   *\n   * ref.get() // original\n   * ```\n   *\n   * @see [bindL]{@link DynamicRef.bindL} for binding a non-strict value instead.\n   *\n   * @param value is the value to bind to this reference within `thunk`'s execution\n   * @param thunk is a parameterless function to execute\n   *\n   * @return the result of executing `thunk`\n   */\n  bind<R>(value: A, thunk: () => R): R {\n    return this.bindL(() => value, thunk)\n  }\n\n  /**\n   * Binds this `DynamicRef` to a different (non-strict) `value` that's going\n   * to be visible while executing `thunk` and then it will get reverted to\n   * its previous value.\n   *\n   * Sample:\n   *\n   * ```typescript\n   * const ref = DynamicRef.of(() => \"original\")\n   *\n   * ref.get() // original\n   *\n   * ref.bindL(() => \"modified\", () => {\n   *   ref.get() // modified\n   * })\n   *\n   * ref.get() // original\n   * ```\n   *\n   * @see [bind]{@link DynamicRef.bindL} for binding a strict value instead.\n   *\n   * @param value is the value generator to bind to this reference within `thunk`'s execution\n   * @param thunk is a parameterless function to execute\n   *\n   * @return the result of executing `thunk`\n   */\n  bindL<R>(value: () => A, thunk: () => R): R {\n    const oldFn = this.get\n    const oldPrev = this._previous.slice(0)\n    const ta = this as any\n    try {\n      ta.get = value\n      return thunk()\n    } finally {\n      ta.get = oldFn\n      ta._previous = oldPrev\n    }\n  }\n\n  /**\n   * Builds a {@link DynamicRef}, where the given parameterless function\n   * is going to be the generator for the default value of the returned\n   *\n   *\n   */\n  static of<A>(fn: () => A): DynamicRef<A> {\n    return new DynamicRef(fn)\n  }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IllegalArgumentError } from \"funfix-core\"\n\n/**\n * Given a sorted array, searches for an insert position for a given search\n * element such that, if inserted in the array at the returned position,\n * the array would remain sorted.\n *\n * @Hidden\n */\nexport function arrayBSearchInsertPos<A>(array: Array<A>, f: (a: A) => number):\n  ((search: number) => number) {\n\n  return search => {\n    let minIndex = 0\n    let maxIndex = array.length - 1\n\n    while (minIndex <= maxIndex) {\n      const index = (minIndex + maxIndex) / 2 | 0\n      const current = f(array[index])\n      const next = index + 1 <= maxIndex ? f(array[index + 1]) : undefined\n\n      if (current <= search && (next === undefined || search < next)) {\n        return index + 1\n      } else if (current <= search) {\n        minIndex = index + 1\n      } else { /* if (current > search) */\n        maxIndex = index - 1\n      }\n    }\n\n    return 0\n  }\n}\n\n/**\n * Internal utility that builds an iterator out of an `Iterable` or an `Array`.\n *\n * @hidden\n */\nexport function iterableToArray<A>(values: Iterable<A>): A[] {\n  if (!values) return []\n  if (Object.prototype.toString.call(values) === \"[object Array]\")\n    return values as A[]\n\n  const cursor = values[Symbol.iterator]()\n  const arr: A[] = []\n\n  while (true) {\n    const item = cursor.next()\n    if (item.value) arr.push(item.value)\n    if (item.done) return arr\n  }\n}\n\n/**\n * Natural log of 2.\n * @hidden\n */\nexport const lnOf2 = Math.log(2)\n\n/**\n * Calculates the base 2 logarithm of the given argument.\n *\n * @hidden\n * @return a number such that 2^nr^ is equal to our argument.\n */\nexport function log2(x: number): number {\n  return Math.log(x) / lnOf2\n}\n\n/**\n * The maximum number that can be returned by {@link nextPowerOf2}.\n * @hidden\n */\nexport const maxPowerOf2: number = 1 << 30\n\n/**\n * Given a positive integer, returns the next power of 2 that is bigger\n * than our argument, or the maximum that this function can\n * return which is 2^30^ (or 1,073,741,824).\n *\n * @return an integer that is a power of 2, that is bigger or\n *        equal with our argument and that is \"closest\" to it.\n *\n * @hidden\n */\nexport function nextPowerOf2(nr: number): number {\n  if (nr < 0) throw new IllegalArgumentError(\"nr must be positive\")\n  const bit = Math.ceil(log2(nr))\n  return 1 << (bit > 30 ? 30 : (bit & bit))\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IEquals, hashCodeOfString, NotImplementedError, Throwable } from \"funfix-core\"\nimport { Duration } from \"./time\"\nimport { ICancelable, Cancelable, IAssignCancelable, MultiAssignCancelable } from \"./cancelable\"\nimport { DynamicRef } from \"./ref\"\nimport { arrayBSearchInsertPos, maxPowerOf2, nextPowerOf2 } from \"./internals\"\n\n/**\n * A `Scheduler` is an execution context that can execute units of\n * work asynchronously, with a delay or periodically.\n *\n * It replaces Javascript's `setTimeout`, which is desirable due to\n * the provided utilities and because special behavior might be needed\n * in certain specialized contexts (e.g. tests), even if the\n * [[Scheduler.global]] reference is implemented with `setTimeout`.\n */\nexport abstract class Scheduler {\n  /**\n   *  The {@link ExecutionModel} is a specification of how run-loops\n   * and producers should behave in regards to executing tasks\n   * either synchronously or asynchronously.\n   */\n  public readonly executionModel: ExecutionModel\n\n  /**\n   * Index of the current cycle, incremented automatically (modulo\n   * the batch size) when doing execution by means of\n   * {@link Scheduler.executeBatched} and the `Scheduler` is\n   * configured with {@link ExecutionModel.batched}.\n   *\n   * When observed as being zero, it means an async boundary just\n   * happened.\n   */\n  batchIndex: number = 0\n\n  /**\n   * @param em the {@link ExecutionModel} to use for\n   *        {@link Scheduler.executionModel}, should default to\n   *        {@link ExecutionModel.global}\n   */\n  protected constructor(em: ExecutionModel) {\n    this.executionModel = em\n\n    // Building an optimized executeBatched\n    switch (em.type) {\n      case \"alwaysAsync\":\n        this.executeBatched = this.executeAsync\n        break\n\n      case \"synchronous\":\n        this.executeBatched = this.trampoline\n        break\n\n      case \"batched\":\n        const modulus = em.recommendedBatchSize - 1\n\n        this.executeBatched = (r) => {\n          const next = (this.batchIndex + 1) & modulus\n          if (next) {\n            this.batchIndex = next\n            return this.trampoline(r)\n          } else {\n            return this.executeAsync(r)\n          }\n        }\n    }\n  }\n\n  /**\n   * Executes tasks in batches, according to the rules set by the\n   * given {@link ExecutionModel}.\n   *\n   * The rules, depending on the chosen `ExecutionModel`:\n   *\n   * - if `synchronous`, then all tasks are executed with\n   *   {@link Scheduler.trampoline}\n   * - if `asynchronous`, then all tasks are executed with\n   *   {@link Scheduler.executeAsync}\n   * - if `batched(n)`, then `n` tasks will be executed\n   *   with `Scheduler.trampoline` and then the next execution\n   *   will force an asynchronous boundary by means of\n   *   `Scheduler.executeAsync`\n   *\n   * Thus, in case of batched execution, an internal counter gets\n   * incremented to keep track of how many tasks where executed\n   * immediately (trampolined), a counter that's reset when reaching\n   * the threshold or when an `executeAsync` happens.\n   */\n  public readonly executeBatched: (runnable: () => void) => void\n\n  /**\n   * Schedules the given `command` for async execution.\n   *\n   * In [[GlobalScheduler]] this method uses\n   * [setImmediate]{@link https://developer.mozilla.org/en/docs/Web/API/Window/setImmediate}\n   * when available. But given that `setImmediate` is a very\n   * non-standard operation that is currently implemented only by\n   * IExplorer and Node.js, on non-supporting environments we fallback\n   * on `setTimeout`. See\n   * [the W3C proposal]{@link https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html}.\n   *\n   * @param runnable is the thunk to execute asynchronously\n   */\n  public abstract executeAsync(runnable: () => void): void\n\n  /**\n   * Execute the given `runnable` on the current call stack by means\n   * of a \"trampoline\", preserving stack safety.\n   *\n   * This is an alternative to {@link executeAsync} for triggering\n   * light asynchronous boundaries.\n   */\n  public abstract trampoline(runnable: () => void): void\n\n  /** Reports that an asynchronous computation failed. */\n  public abstract reportFailure(e: Throwable): void\n\n  /**\n   * Returns the current time in milliseconds.  Note that while the\n   * unit of time of the return value is a millisecond, the\n   * granularity of the value depends on the underlying operating\n   * system and may be larger.  For example, many operating systems\n   * measure time in units of tens of milliseconds.\n   *\n   * It's the equivalent of `Date.now()`. When wanting to measure\n   * time, do not use `Date.now()` directly, prefer this method\n   * instead, because then it can be mocked for testing purposes,\n   * or overridden for better precision.\n   */\n  public abstract currentTimeMillis(): number\n\n  /**\n   * Schedules a task to run in the future, after `delay`.\n   *\n   * For example the following schedules a message to be printed to\n   * standard output after 5 minutes:\n   *\n   * ```typescript\n   * const task =\n   *   scheduler.scheduleOnce(Duration.minutes(5), () => {\n   *     console.log(\"Hello, world!\")\n   *   })\n   *\n   * // later if you change your mind ... task.cancel()\n   * ```\n   *\n   * @param delay is the time to wait until the execution happens; if\n   *        specified as a `number`, then it's interpreted as milliseconds;\n   *        for readability, prefer passing [[Duration]] values\n   * @param runnable is the callback to be executed\n   *\n   * @return a [[Cancelable]] that can be used to cancel the created\n   *         task before execution.\n   */\n  public abstract scheduleOnce(delay: number | Duration, runnable: () => void): ICancelable\n\n  /**\n   * Given a function that will receive the underlying\n   * {@link ExecutionModel}, returns a new {@link Scheduler}\n   * reference, based on the source that exposes the new\n   * `ExecutionModel` value when queried by means of the\n   * {@link Scheduler.executionModel} property.\n   *\n   * This method enables reusing global scheduler references in\n   * a local scope, but with a modified execution model to inject.\n   *\n   * The contract of this method (things you can rely on):\n   *\n   *  1. the source `Scheduler` must not be modified in any way\n   *  2. the implementation should wrap the source efficiently, such\n   *     that the result mirrors the implementation of the source\n   *     `Scheduler` in every way except for the execution model\n   *\n   * Sample:\n   *\n   * ```typescript\n   * import { Scheduler, ExecutionModel } from \"funfix\"\n   *\n   * const scheduler = Schedule.global()\n   *   .withExecutionModel(ExecutionModel.trampolined())\n   * ```\n   */\n  public abstract withExecutionModel(em: ExecutionModel): Scheduler\n\n  /**\n   * Schedules for execution a periodic task that is first executed\n   * after the given initial delay and subsequently with the given\n   * delay between the termination of one execution and the\n   * commencement of the next.\n   *\n   * For example the following schedules a message to be printed to\n   * standard output every 10 seconds with an initial delay of 5\n   * seconds:\n   *\n   * ```typescript\n   * const task =\n   *   s.scheduleWithFixedDelay(Duration.seconds(5), Duration.seconds(10), () => {\n   *     console.log(\"repeated message\")\n   *   })\n   *\n   * // later if you change your mind ...\n   * task.cancel()\n   * ```\n   *\n   * @param initialDelay is the time to wait until the first execution happens\n   * @param delay is the time to wait between 2 successive executions of the task\n   * @param runnable is the thunk to be executed\n   * @return a cancelable that can be used to cancel the execution of\n   *         this repeated task at any time.\n   */\n  public scheduleWithFixedDelay(initialDelay: number | Duration, delay: number | Duration, runnable: () => void): ICancelable {\n    const loop = (self: Scheduler, ref: IAssignCancelable, delayNow: number | Duration) =>\n      ref.update(self.scheduleOnce(delayNow, () => {\n        runnable()\n        loop(self, ref, delay)\n      }))\n\n    const task = MultiAssignCancelable.empty()\n    return loop(this, task, initialDelay)\n  }\n\n  /**\n   * Schedules a periodic task that becomes enabled first after the given\n   * initial delay, and subsequently with the given period. Executions will\n   * commence after `initialDelay` then `initialDelay + period`, then\n   * `initialDelay + 2 * period` and so on.\n   *\n   * If any execution of the task encounters an exception, subsequent executions\n   * are suppressed. Otherwise, the task will only terminate via cancellation or\n   * termination of the scheduler. If any execution of this task takes longer\n   * than its period, then subsequent executions may start late, but will not\n   * concurrently execute.\n   *\n   * For example the following schedules a message to be printed to standard\n   * output approximately every 10 seconds with an initial delay of 5 seconds:\n   *\n   * ```typescript\n   * const task =\n   *   s.scheduleAtFixedRate(Duration.seconds(5), Duration.seconds(10), () => {\n   *     console.log(\"repeated message\")\n   *   })\n   *\n   *   // later if you change your mind ...\n   *   task.cancel()\n   * ```\n   *\n   * @param initialDelay is the time to wait until the first execution happens\n   * @param period is the time to wait between 2 successive executions of the task\n   * @param runnable is the thunk to be executed\n   * @return a cancelable that can be used to cancel the execution of\n   *         this repeated task at any time.\n   */\n  public scheduleAtFixedRate(initialDelay: number | Duration, period: number | Duration, runnable: () => void): ICancelable {\n    const loop = (self: Scheduler, ref: IAssignCancelable, delayNowMs: number, periodMs: number) =>\n      ref.update(self.scheduleOnce(delayNowMs, () => {\n        // Benchmarking the duration of the runnable\n        const startAt = self.currentTimeMillis()\n        runnable()\n        // Calculating the next delay based on the current execution\n        const elapsedMs = self.currentTimeMillis() - startAt\n        const nextDelayMs = Math.max(0, periodMs - elapsedMs)\n        loop(self, ref, periodMs, nextDelayMs)\n      }))\n\n    const task = MultiAssignCancelable.empty()\n    return loop(this, task,\n      typeof initialDelay === \"number\" ? initialDelay : initialDelay.toMillis(),\n      typeof period === \"number\" ? period : period.toMillis()\n    )\n  }\n\n  /**\n   * Exposes a reusable [[GlobalScheduler]] reference by means of a\n   * {@link DynamicRef}, which allows for lexically scoped bindings to happen.\n   *\n   * ```typescript\n   * const myScheduler = new GlobalScheduler(false)\n   *\n   * Scheduler.global.bind(myScheduler, () => {\n   *   Scheduler.global.get() // myScheduler\n   * })\n   *\n   * Scheduler.global.get() // default instance\n   * ```\n   */\n  static readonly global: DynamicRef<Scheduler> =\n    DynamicRef.of(() => globalSchedulerRef)\n}\n\n/**\n * The `ExecutionModel` is a specification for how potentially asynchronous\n * run-loops should execute, imposed by the `Scheduler`.\n *\n * When executing tasks, a run-loop can always execute tasks\n * asynchronously (by forking logical threads), or it can always\n * execute them synchronously (same thread and call-stack, by\n * using an internal trampoline), or it can do a mixed mode\n * that executes tasks in batches before forking.\n *\n * The specification is considered a recommendation for how\n * run loops should behave, but ultimately it's up to the client\n * to choose the best execution model. This can be related to\n * recursive loops or to events pushed into consumers.\n */\nexport class ExecutionModel implements IEquals<ExecutionModel> {\n  /**\n   * Recommended batch size used for breaking synchronous loops in\n   * asynchronous batches. When streaming value from a producer to\n   * a synchronous consumer it's recommended to break the streaming\n   * in batches as to not hold the current thread or run-loop\n   * indefinitely.\n   *\n   * This is rounded to the next power of 2, because then for\n   * applying the modulo operation we can just do:\n   *\n   * ```typescript\n   * const modulus = recommendedBatchSize - 1\n   * // ...\n   * nr = (nr + 1) & modulus\n   * ```\n   */\n  public recommendedBatchSize: number\n\n  /**\n   * The type of the execution model, which can be:\n   *\n   * - `batched`: the default, specifying an mixed execution\n   *   mode under which tasks are executed synchronously in\n   *   batches up to a maximum size; after a batch of\n   *   {@link recommendedBatchSize} is executed, the next\n   *   execution should be asynchronous.\n   * - `synchronous`: specifies that execution should be\n   *   synchronous (immediate / trampolined) for as long as\n   *   possible.\n   * - `alwaysAsync`: specifies a run-loop should always do\n   *   async execution of tasks, triggering asynchronous\n   *   boundaries on each step.\n   */\n  public type: \"batched\" | \"synchronous\" | \"alwaysAsync\"\n\n  private constructor(type: \"batched\" | \"synchronous\" | \"alwaysAsync\", batchSize?: number) {\n    this.type = type\n    switch (type) {\n      case \"synchronous\":\n        this.recommendedBatchSize = maxPowerOf2\n        break\n      case \"alwaysAsync\":\n        this.recommendedBatchSize = 1\n        break\n      case \"batched\":\n        this.recommendedBatchSize = nextPowerOf2(batchSize || 128)\n        break\n    }\n  }\n\n  /** Implements `IEquals.equals`. */\n  equals(other: ExecutionModel): boolean {\n    return this.type === other.type &&\n      this.recommendedBatchSize === other.recommendedBatchSize\n  }\n\n  /** Implements `IEquals.hashCode`. */\n  hashCode(): number {\n    return hashCodeOfString(this.type) * 47 + this.recommendedBatchSize\n  }\n\n  /**\n   * An {@link ExecutionModel} that specifies that execution should be\n   * synchronous (immediate, trampolined) for as long as possible.\n   */\n  static synchronous(): ExecutionModel {\n    return new ExecutionModel(\"synchronous\")\n  }\n\n  /**\n   * An {@link ExecutionModel} that specifies a run-loop should always do\n   * async execution of tasks, thus triggering asynchronous boundaries on\n   * each step.\n   */\n  static alwaysAsync(): ExecutionModel {\n    return new ExecutionModel(\"alwaysAsync\")\n  }\n\n  /**\n   * Returns an {@link ExecutionModel} that specifies a mixed execution\n   * mode under which tasks are executed synchronously in batches up to\n   * a maximum size, the `recommendedBatchSize`.\n   *\n   * After such a batch of {@link recommendedBatchSize} is executed, the\n   * next execution should have a forced asynchronous boundary.\n   */\n  static batched(recommendedBatchSize?: number): ExecutionModel {\n    return new ExecutionModel(\"batched\", recommendedBatchSize)\n  }\n\n  /**\n   * The default {@link ExecutionModel} that should be used whenever\n   * an execution model isn't explicitly specified.\n   */\n  static readonly global: DynamicRef<ExecutionModel> =\n    DynamicRef.of(() => ExecutionModel.batched())\n}\n\n/**\n * Internal trampoline implementation used for implementing\n * {@link Scheduler.trampoline}.\n *\n * @final\n * @hidden\n */\nclass Trampoline {\n  private readonly _reporter: (e: Throwable) => void\n  private readonly _queue: (() => void)[]\n  private _isActive: boolean\n\n  constructor(reporter: (e: Throwable) => void) {\n    this._isActive = false\n    this._queue = []\n    this._reporter = reporter\n  }\n\n  execute(r: () => void) {\n    if (!this._isActive) {\n      this.runLoop(r)\n    } else {\n      this._queue.push(r)\n    }\n  }\n\n  private runLoop(r: () => void) {\n    this._isActive = true\n    try {\n      let cursor: (() => void) | undefined = r\n      while (cursor) {\n        try { cursor() } catch (e) { this._reporter(e) }\n        cursor = this._queue.pop()\n      }\n    } finally {\n      this._isActive = false\n    }\n  }\n}\n\n/**\n * `GlobalScheduler` is a [[Scheduler]] implementation based on Javascript's\n * [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout}\n * and (if available and configured)\n * [setImmediate]{@link https://developer.mozilla.org/en/docs/Web/API/Window/setImmediate}.\n */\nexport class GlobalScheduler extends Scheduler {\n  /**\n   * If `true`, then `setImmediate` is used in `execute`.\n   */\n  private readonly _useSetImmediate: boolean\n\n  /**\n   * {@link Trampoline} used for immediate execution in\n   * {@link Scheduler.trampoline}.\n   */\n  private readonly _trampoline: Trampoline\n\n  /**\n   * @param canUseSetImmediate is a boolean informing the\n   *        `GlobalScheduler` implementation that it can use the\n   *        nonstandard `setImmediate` for scheduling asynchronous\n   *        tasks without extra delays.\n   *\n   * @param em the {@link ExecutionModel} to use for\n   *        {@link Scheduler.executionModel}, should default to\n   *        {@link ExecutionModel.global}\n   *\n   * @param reporter is the reporter to use for reporting uncaught\n   *        errors, defaults to `console.error`\n   */\n  constructor(\n    canUseSetImmediate: boolean = false,\n    em: ExecutionModel = ExecutionModel.global.get(),\n    reporter?: (e: Throwable) => void) {\n\n    super(em)\n    if (reporter) this.reportFailure = reporter\n    this._trampoline = new Trampoline(this.reportFailure)\n    // tslint:disable:strict-type-predicates\n    this._useSetImmediate = (canUseSetImmediate || false) && (typeof setImmediate === \"function\")\n\n    this.executeAsync = this._useSetImmediate\n      ? r => setImmediate(safeRunnable(r, this.reportFailure))\n      : r => setTimeout(safeRunnable(r, this.reportFailure))\n  }\n\n  /* istanbul ignore next */\n  executeAsync(runnable: () => void): void {\n    /* istanbul ignore next */\n    throw new NotImplementedError(\"Constructor of GlobalScheduler wasn't executed\")\n  }\n\n  trampoline(runnable: () => void): void {\n    return this._trampoline.execute(runnable)\n  }\n\n  /* istanbul ignore next */\n  reportFailure(e: Throwable): void {\n    console.error(e)\n  }\n\n  currentTimeMillis(): number {\n    return Date.now()\n  }\n\n  scheduleOnce(delay: number | Duration, runnable: () => void): ICancelable {\n    const r = () => {\n      this.batchIndex = 0\n      try { runnable() } catch (e) { this.reportFailure(e) }\n    }\n\n    const ms = Math.max(0, Duration.of(delay).toMillis())\n    const task = setTimeout(r, ms)\n    return Cancelable.of(() => clearTimeout(task))\n  }\n\n  withExecutionModel(em: ExecutionModel) {\n    return new GlobalScheduler(this._useSetImmediate, em)\n  }\n}\n\n/**\n * The `TestScheduler` is a {@link Scheduler} type meant for testing purposes,\n * being capable of simulating asynchronous execution and the passage of time.\n *\n * Example:\n *\n * ```typescript\n * const s = new TestScheduler()\n *\n * s.execute(() => { console.log(\"Hello, world!\") })\n *\n * // Triggers actual execution\n * s.tick()\n *\n * // Simulating delayed execution\n * const task = s.scheduleOnce(Duration.seconds(10), () => {\n *   console.log(\"Hello, delayed!\")\n * })\n *\n * // We can cancel a delayed task if we want\n * task.cancel()\n *\n * // Or we can execute it by moving the internal clock forward in time\n * s.tick(Duration.seconds(10))\n * ```\n */\nexport class TestScheduler extends Scheduler {\n  private _reporter: (error: any) => void\n  private _trampoline: Trampoline\n  private _stateRef?: TestSchedulerState\n\n  /**\n   * @param reporter is an optional function that will be called\n   *        whenever {@link Scheduler.reportFailure} is invoked.\n   *\n   * @param em the {@link ExecutionModel} to use for\n   *        the {@link Scheduler.executionModel}, defaults to\n   *        `\"synchronous\"` for `TestScheduler`\n   */\n  constructor(reporter?: (error: any) => void, em: ExecutionModel = ExecutionModel.synchronous()) {\n    super(em)\n    this._reporter = reporter || (_ => {})\n    this._trampoline = new Trampoline(this.reportFailure.bind(this))\n  }\n\n  private _state() {\n    if (!this._stateRef) {\n      this._stateRef = new TestSchedulerState()\n      this._stateRef.updateTasks([])\n    }\n    return this._stateRef\n  }\n\n  /**\n   * Returns a list of triggered errors, if any happened during\n   * the {@link tick} execution.\n   */\n  public triggeredFailures(): Array<any> { return this._state().triggeredFailures }\n\n  /**\n   * Returns `true` if there are any tasks left to execute, `false`\n   * otherwise.\n   */\n  public hasTasksLeft(): boolean { return this._state().tasks.length > 0 }\n\n  public executeAsync(runnable: () => void): void {\n    this._state().tasks.push([this._state().clock, runnable])\n  }\n\n  public trampoline(runnable: () => void): void {\n    this._trampoline.execute(runnable)\n  }\n\n  public reportFailure(e: Throwable): void {\n    this._state().triggeredFailures.push(e)\n    this._reporter(e)\n  }\n\n  public currentTimeMillis(): number {\n    return this._state().clock\n  }\n\n  public scheduleOnce(delay: number | Duration, runnable: () => void): ICancelable {\n    const d = Math.max(0, Duration.of(delay).toMillis())\n    const state = this._state()\n    const scheduleAt = state.clock + d\n    const insertAt = state.tasksSearch(-scheduleAt)\n    const ref: [number, () => void] = [scheduleAt, runnable]\n    state.tasks.splice(insertAt, 0, ref)\n\n    return Cancelable.of(() => {\n      const filtered: Array<[number, () => void]> = []\n      for (const e of state.tasks) {\n        if (e !== ref) filtered.push(e)\n      }\n      state.updateTasks(filtered)\n    })\n  }\n\n  public withExecutionModel(em: ExecutionModel): TestScheduler {\n    const ec2 = new TestScheduler(this._reporter, em)\n    ec2._stateRef = this._state()\n    return ec2\n  }\n\n  /**\n   * Executes the current batch of tasks that are pending, relative\n   * to [currentTimeMillis]{@link TestScheduler.currentTimeMillis}.\n   *\n   * ```typescript\n   * const s = new TestScheduler()\n   *\n   * // Immediate execution\n   * s.executeAsync(() => console.log(\"A\"))\n   * s.executeAsync(() => console.log(\"B\"))\n   * // Delay with 1 second from now\n   * s.scheduleOnce(Duration.seconds(1), () => console.log(\"C\"))\n   * s.scheduleOnce(Duration.seconds(1), () => console.log(\"D\"))\n   * // Delay with 2 seconds from now\n   * s.scheduleOnce(Duration.seconds(2), () => console.log(\"E\"))\n   * s.scheduleOnce(Duration.seconds(2), () => console.log(\"F\"))\n   *\n   * // Actual execution...\n   *\n   * // Prints A, B\n   * s.tick()\n   * // Prints C, D\n   * s.tick(Duration.seconds(1))\n   * // Prints E, F\n   * s.tick(Duration.seconds(1))\n   * ```\n   *\n   * @param duration is an optional timespan to user for incrementing\n   * [currentTimeMillis]{@link TestScheduler.currentTimeMillis}, thus allowing\n   * the execution of tasks scheduled to execute with a delay.\n   *\n   * @return the number of executed tasks\n   */\n  public tick(duration?: number | Duration): number {\n    const state = this._state()\n    let toExecute = []\n    let jumpMs = Duration.of(duration || 0).toMillis()\n    let executed = 0\n\n    while (true) {\n      const peek = state.tasks.length > 0\n        ? state.tasks[state.tasks.length - 1]\n        : undefined\n\n      if (peek && peek[0] <= state.clock) {\n        toExecute.push(state.tasks.pop())\n      } else if (toExecute.length > 0) {\n        // Executing current batch, randomized\n        while (toExecute.length > 0) {\n          const index = Math.floor(Math.random() * toExecute.length)\n          const elem = toExecute[index] as any\n          try {\n            toExecute.splice(index, 1)\n            this.batchIndex = 0\n            elem[1]()\n          } catch (e) {\n            this.reportFailure(e)\n          } finally {\n            executed += 1\n          }\n        }\n      } else if (jumpMs > 0) {\n        const nextTaskJump = peek && (peek[0] - state.clock) || jumpMs\n        const add = Math.min(nextTaskJump, jumpMs)\n        state.clock += add\n        jumpMs -= add\n      } else {\n        break\n      }\n    }\n    return executed\n  }\n\n  /**\n   * Executes the task that's at the top of the stack, in case we\n   * have a task to execute that doesn't require a jump in time.\n   *\n   * ```typescript\n   * const ec = new TestScheduler()\n   *\n   * ec.execute(() => console.log(\"A\"))\n   * ec.execute(() => console.log(\"B\"))\n   *\n   * // Prints B\n   * ec.tickOne()\n   * // Prints A\n   * ec.tickOne()\n   * ```\n   */\n  public tickOne(): boolean {\n    const state = this._state()\n    const peek = state.tasks.length > 0\n      ? state.tasks[state.tasks.length - 1]\n      : undefined\n\n    if (!peek || peek[0] > state.clock) return false\n    this._state().tasks.pop()\n    this.batchIndex = 0\n    try { peek[1]() } catch (e) { this.reportFailure(e) }\n    return true\n  }\n}\n\nclass TestSchedulerState {\n  public clock: number\n  public triggeredFailures: Array<any>\n  public tasks: Array<[number, () => void]>\n  public tasksSearch: (search: number) => number\n\n  constructor() {\n    this.clock = 0\n    this.triggeredFailures = []\n    this.updateTasks([])\n  }\n\n  updateTasks(tasks: Array<[number, () => void]>) {\n    this.tasks = tasks\n    this.tasksSearch = arrayBSearchInsertPos(this.tasks, e => -e[0])\n  }\n}\n\n/**\n * Internal, reusable [[GlobalScheduler]] reference.\n *\n * @Hidden\n */\nconst globalSchedulerRef = new GlobalScheduler(true)\n\n/**\n * Internal utility wrapper a runner in an implementation that\n * reports errors with the provided `reporter` callback.\n *\n * @Hidden\n */\nfunction safeRunnable(r: () => void, reporter: (error: any) => void): () => void {\n  return () => { try { r() } catch (e) { reporter(e) } }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Try, Success, Failure, Option, Some, None, Either, Left, Right,\n  IllegalStateError, IllegalArgumentError, TimeoutError, Throwable\n} from \"funfix-core\"\n\nimport { Scheduler } from \"./scheduler\"\nimport { Duration } from \"./time\"\nimport { ICancelable, Cancelable, ChainedCancelable, DummyCancelable } from \"./cancelable\"\nimport { iterableToArray } from \"./internals\"\n\n/**\n * `IPromiseLike` represents objects that have a `then` method complying with\n * the [Promises/A+](https://promisesaplus.com/) specification.\n */\nexport interface IPromiseLike<T> {\n  /**\n   * Attaches callbacks for the resolution and/or rejection of the promise.\n   *\n   * See [MDN: Promise.then]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then}.\n   *\n   * @param onFulfilled The callback to execute when the promise is resolved.\n   * @param onRejected The callback to execute when the promise is rejected.\n   *\n   * @returns A promise for the completion of which ever callback is executed.\n   */\n  then(onFulfilled?: (value: T) => any, onRejected?: (reason: Throwable) => any): IPromiseLike<any>\n}\n\n/**\n * A `Future` represents a value which may or may not *currently* be available, but will be\n * available at some point, or an exception if the operation producing the result fails.\n *\n * `Future<A>` is a Promise-like alternative data type, that's cancelable and lawful,\n * inspired by Scala's `Future[A]`.\n *\n * You can easily build futures out of functions, that will execute asynchronously\n * (e.g. not on the current call stack) by means of `Future.of`:\n *\n * ```typescript\n * Future.of(() => 1 + 1)\n * ```\n *\n * Such computations use the [[Scheduler.global]] reference for execution, which\n * can be overridden, many times in the function call, being an optional parameter\n * (e.g. in `Future.of`), or in the local context, because it is exposed as a\n * [[DynamicRef]], which allows for localised overrides:\n *\n * ```typescript\n * import { Scheduler, GlobalScheduler, Future } from \"funfix\"\n *\n * // Custom Scheduler reference that we want to use\n * const ec = new GlobalScheduler(false)\n *\n * Future.of(() => x + y, ec)\n *\n * // ... is equivalent with ...\n *\n * Scheduler.global.bind(ec, () => {\n *   Future.of(() => x + y)\n * })\n * ```\n *\n * To create a `Future` out of an actual asynchronous computation, you can\n * use `Future.create`. Here's an example that takes a function and executes\n * it with an initial delay, returning a cancelable `Future`:\n *\n * ```typescript\n * import { Scheduler, Future, Try, Duration, Cancelable } from \"funfix\"\n *\n * const delay = <A>(d: Duration, f: () => A, ec: Scheduler = Scheduler.global.get()) =>\n *   Future.create<A>(\n *     cb => {\n *       const task = ec.scheduleOnce(d, () => cb(Try.of(f)))\n *\n *       return Cancelable.of(() => {\n *         console.warn(\"Delayed task was cancelled\")\n *         task.cancel()\n *       })\n *     },\n *     ec\n *   )\n * ```\n *\n * Normally you can `await` on functions returning `Future<A>` values:\n *\n * ```typescript\n * async function asyncSample(n: number): Promise<number> {\n *   let sum = 0\n *   for (let i = 0; i < n; i++) {\n *     sum += await Future.of(() => i)\n *   }\n *   return sum\n * }\n * ```\n *\n * Such functions do need to return a `Promise`, because JavaScript\n * generates code that uses `Promise`'s constructor. But a `Future`\n * is \"thenable\", so you can await on functions returning `Future`\n * just fine.\n */\nexport abstract class Future<A> implements IPromiseLike<A>, ICancelable {\n  /**\n   * Reference to the current {@link Scheduler} available for subsequent\n   * data transformations. Can be set in `Future`'s constructors, or by\n   * transforming the source by {@link withScheduler}.\n   *\n   * Protected, because it shouldn't be public API, being meant for\n   * `Future` implementations.\n   *\n   * @protected\n   */\n  protected readonly _scheduler: Scheduler\n\n  /**\n   * Reference to the current {@link ICancelable} available for\n   * subsequent data transformations.\n   *\n   * Protected, because it shouldn't be public API, being meant for\n   * `Future` implementations.\n   *\n   * @protected\n   */\n  protected _cancelable?: ICancelable\n\n  /**\n   * Extracts the completed value for this `Future`, returning `Some(result)`\n   * if this `Future` is already complete or `None` in case the `Future` wasn't\n   * completed yet.\n   *\n   * ```typescript\n   * const f1 = Future.of(() => 1)\n   *\n   * // Given the async execution of `Future.of`, the immediate invocations of\n   * // `value()` will yield `None`, but after complete it will yield\n   * // `Some(Success(1))`\n   * f1.value()\n   *\n   * const f2 = Future.raise(new DummyError())\n   *\n   * // Immediately yields Some(Failure(DummyError))\n   * f2.value()\n   * ```\n   */\n  abstract value(): Option<Try<A>>\n\n  /**\n   * Given a callback, calls it with this `Future`'s result when that result\n   * is ready.\n   *\n   * The execution of this callback is always trampolined (for already completed\n   * futures), or asynchronous, which means that modeling loops based on it is\n   * memory safe.\n   *\n   * ```typescript\n   * Future.of(() => \"John\").complete(r => {\n   *   r.fold(\n   *    error => console.info(\"Error: \" + error),\n   *    success => console.info(\"Hello, \" + John)\n   *   )\n   * })\n   * ```\n   */\n  abstract onComplete(f: (a: Try<A>) => void): void\n\n  /**\n   * In case this `Future` isn't complete, then send it a cancel signal.\n   *\n   * Depending on the computation that will complete this future, its execution\n   * might be interrupted.\n   *\n   * Execution has the same properties of {@link ICancelable}, being idempotent\n   * (calling it multiple times has the same effect as calling it once).\n   *\n   * In order to create a cancelable `Future`, use {@link Future.create}.\n   */\n  abstract cancel(): void\n\n  /**\n   * Sets the {@link Scheduler} reference that's going to get used for\n   * subsequent data transformations.\n   *\n   * `Future` references have a {@link Scheduler} reference attached at build\n   * time, that's going to get used for data transformations. This method\n   * returns a new `Future` reference that's going to mirror the source,\n   * but that's going to use the given `Scheduler` for subsequent operations\n   * like `map`, `flatMap`, `transformWith`, etc.\n   *\n   * ```typescript\n   * const ec1 = new GlobalScheduler(true)\n   *\n   * // The default Scheduler is global (that second parameter is optiona)\n   * const f1 = Future.create(f, ec1)\n   *\n   * // The `f1` future is going to get executed by `ec1`, however\n   * // this subsequent `flatMap` is getting evaluated by `ec2`\n   * const ec2 = new GlobalScheduler(false)\n   * const f2 = f1.withScheduler(ec2).flatMap(x => Future.pure(x * 2))\n   * ```\n   *\n   * When no `Scheduler` is specified, the default is assumed to be\n   * {@link Scheduler.global}.\n   *\n   * @param ec is the scheduler that's going to get used asynchronous execution\n   *        of subsequent operations\n   */\n  abstract withScheduler(ec: Scheduler): Future<A>\n\n  /**\n   * Transforms the source, regardless if the result is a failure or a success.\n   *\n   * This function is a combination of {@link flatMap} and {@link recoverWith},\n   * being the (type safe) alternative to JavaScript's\n   * [then]{@link IPromiseLike.then} from the\n   * [Promises/A+](https://promisesaplus.com/) specification.\n   *\n   * NOTE: in Funfix these fold-like methods, by convention, take as the\n   * first parameter the function that transforms the failure (the left),\n   * whereas the second parameter is the function that transforms the\n   * successful result (the right). Think of `Either<Error, A>`.\n   *\n   * ```typescript\n   * const randomInt = (max: number) =>\n   *   Future.of(() => {\n   *     const n = Math.random() * max\n   *     n & n\n   *   })\n   *\n   * const randomEvenInt = (max: number) =>\n   *   randomInt(max).transformWith(\n   *     err => Future.pure(9),\n   *     value => (\n   *       // retry until we have an even value\n   *       value % 2 == 0 ? Future.pure(value) : randomEvenInt()\n   *     )\n   *   )\n   * ```\n   *\n   * Also see {@link transform}.\n   *\n   * @param failure is the function that's going to get executed in case the\n   *        source signals a failure\n   *\n   * @param success is the function that's going to get executed in case the\n   *        source signals a successful result\n   */\n  abstract transformWith<B>(failure: (e: Throwable) => Future<B>, success: (a: A) => Future<B>): Future<B>\n\n  /**\n   * Transforms the sources, regardless if the result is a failure or a success.\n   *\n   * This function is a combination of {@link map} and {@link recover},\n   * being the (type safe) alternative to JavaScript's\n   * [then]{@link IPromiseLike.then} from the\n   * [Promises/A+](https://promisesaplus.com/) specification.\n   *\n   * Example:\n   *\n   * ```typescript\n   * import { Left, Right } from \"funfix\"\n   *\n   * // Expose errors by lifting them to an Either<Error, A>\n   * future.transform<Either<Throwable, A>>(Left, Right)\n   * ```\n   *\n   * Also see {@link transformWith}.\n   *\n   * @param failure is the function that's going to get executed in case the\n   *        source signals a failure\n   *\n   * @param success is the function that's going to get executed in case the\n   *        source signals a successful result\n   */\n  transform<B>(failure: (e: Throwable) => B, success: (a: A) => B): Future<B> {\n    return this.transformWith(\n      e => Future.pure(failure(e), this._scheduler),\n      a => Future.pure(success(a), this._scheduler))\n  }\n\n  /**\n   * Exposes underlying errors by lifting both successful and failed\n   * results into an `Either` value.\n   *\n   * Given that errors are short-circuiting the processing of {@link flatMap}\n   * chains, this method is useful for exposing errors such that you can\n   * `flatMap` over them.\n   *\n   * ```typescript\n   * const f: Future<number> = Future.raise(new DummyError)\n   *\n   * // Yields a successful Left(DummyError) on completion\n   * const fe: Future<Either<Throwable, number>> = f.attempt()\n   *\n   * // Yields a Right(1) on completion\n   * const fr: Future<Either<Throwable, number>> = Future.pure(1).attempt()\n   * ```\n   */\n  attempt(): Future<Either<Throwable, A>> {\n    return this.transform<Either<Throwable, A>>(Left, Right)\n  }\n\n  /**\n   * Chains asynchronous operations.\n   *\n   * Creates a new future by applying a function to the successful result of\n   * the source and returns the result of the function as the new future.\n   * If this future is completed with an exception then the new future will\n   * also contain this exception.\n   *\n   * This operation is the monadic bind (e.g. `Monad.flatMap`).\n   *\n   * ```typescript\n   * const fa = Future.of(() => 3)\n   * const fb = Future.of(() => 5)\n   *\n   * // Yields 3 + 5\n   * fa.flatMap(a => fb.map(b => a + b))\n   * ```\n   */\n  flatMap<B>(f: (a: A) => Future<B>): Future<B> {\n    return this.transformWith(Future.raise, f)\n  }\n\n  /**\n   * Given a mapping function, transforms the successful result of the source.\n   *\n   * If the source is completed with an exception, then the new future will\n   * also be completed in an error.\n   *\n   * This operation is the functor map (e.g. `Functor.map`).\n   *\n   * ```typescript\n   * const f = Future.of(() => \"The future\")\n   *\n   * const g = f.map(x => x + \" is now!\")\n   * ```\n   */\n  map<B>(f: (a: A) => B): Future<B> {\n    return this.transformWith(Future.raise,\n      a => Future.pure(f(a), this._scheduler))\n  }\n\n  /**\n   * Creates a new future that will handle any matching throwable that this\n   * future might contain by assigning it a value of another future.\n   *\n   * If there is no match, or if this future contains a valid result then the\n   * new future will contain the same result.\n   *\n   * This operation is the equivalent of {@link flatMap} for handling errors.\n   * Also see {@link transformWith}, which can handle both successful results\n   * and failures.\n   *\n   * ```typescript\n   * const f = Future.of<number>(() => { throw new DummyError() })\n   *\n   * f.recoverWith(e => e instanceof DummyError\n   *   ? Future.pure(10) // Fallback\n   *   : Future.raise(e) // Re-throw\n   * )\n   * ```\n   */\n  recoverWith<AA>(f: (e: Throwable) => Future<AA>): Future<A | AA> {\n    return this.transformWith<A | AA>(f, Future.pure)\n  }\n\n  /**\n   *\n   *\n   * ```typescript\n   * const f = Future.of<number>(() => { throw new DummyError() })\n   *\n   * f.recover(e => {\n   *   if (e instanceof DummyError) return 10\n   *   // Don't re-throw exceptions like this, use `recoverWith` instead!\n   *   throw e\n   * })\n   * ```\n   */\n  recover<AA>(f: (e: Throwable) => AA): Future<A | AA> {\n    return this.transformWith<A | AA>(\n      e => Future.pure(f(e), this._scheduler),\n      a => Future.pure(a, this._scheduler))\n  }\n\n  then<TResult1, TResult2>(\n    onFulfilled?: ((value: A) => (IPromiseLike<TResult1> | TResult1)) | undefined | null,\n    onRejected?: ((reason: Throwable) => (IPromiseLike<TResult2> | TResult2)) | undefined | null): Future<TResult2 | TResult1> {\n\n    if (!onFulfilled && !onRejected) return this as any\n    const ec = this._scheduler\n    return this.transformWith(\n      promiseThen(onRejected, e => Future.raise(e, ec), ec),\n      promiseThen(onFulfilled, a => Future.pure(a, ec), ec)\n    ) as any\n  }\n\n  /**\n   * Transforms this `Future<A>` reference into a standard JavaScript `Promise<A>`\n   * reference.\n   *\n   * Normally a `Future` is \"thenable\", so JavaScript should have no problem\n   * working with it, however in certain contexts this conversion is useful for\n   * working with type definitions that don't recognize the structural typing\n   * defined by the Promises/A+ specification.\n   */\n  toPromise(): Promise<A> {\n    return new Promise<A>((resolve, reject) => {\n      this.onComplete(_ => _.fold(reject, resolve))\n    })\n  }\n\n  /**\n   * Delays signaling the result of this `Future` by the specified duration.\n   *\n   * It works for successful results:\n   *\n   * ```typescript\n   * const fa = Future.of(() => \"Alex\")\n   *\n   * // Delays the signaling by 1 second\n   * fa.delayResult(1000).flatMap\n   * ```\n   *\n   * And for failures as well:\n   *\n   * ```typescript\n   * Future.raise(new TimeoutError()).delayResult(1000)\n   * ```\n   *\n   * @param delay is the duration to wait before signaling the final result\n   */\n  delayResult(delay: number | Duration): Future<A> {\n    return this.transformWith(\n      err => Future.delayedTick(delay, this._scheduler).flatMap(_ => Future.raise(err, this._scheduler)),\n      a => Future.delayedTick(delay, this._scheduler).map(_ => a)\n    )\n  }\n\n  /**\n   * Returns a future that mirrors the source in case the result of the source\n   * is signaled within the required `after` duration, otherwise it\n   * fails with a `TimeoutError`, cancelling the source.\n   *\n   * ```typescript\n   * const fa = Future.of(() => 1).delayResult(10000)\n   *\n   * // Will fail with a TimeoutError\n   * fa.timeout(1000)\n   * ```\n   *\n   * @param after is the duration to wait until it triggers the timeout error\n   */\n  timeout(after: number | Duration): Future<A> {\n    // Creating the exception immediately, to get a good stack trace\n    const fb = Future.raise(new TimeoutError(Duration.of(after).toString()), this._scheduler)\n    return this.timeoutTo(after, () => fb)\n  }\n\n  /**\n   * Returns a future that mirrors the source in case the result of the source\n   * is signaled within the required `after` duration, otherwise it\n   * triggers the execution of the given `fallback` after the duration has\n   * passed, cancelling the source.\n   *\n   * This is literally the implementation of {@link Future.timeout}:\n   *\n   * ```typescript\n   * const fa = Future.of(() => 1).delayResult(10000)\n   *\n   * fa.timeoutTo(1000, () => Future.raise(new TimeoutError()))\n   * ```\n   *\n   * @param after is the duration to wait until it triggers the `fallback`\n   * @param fallback is a thunk generating a fallback `Future` to timeout to\n   */\n  timeoutTo<AA>(after: number | Duration, fallback: () => Future<AA>): Future<A | AA> {\n    const other = Future.delayedTick(after, this._scheduler).flatMap(_ => fallback())\n    const lst: Future<A | AA>[] = [this, other]\n    return Future.firstCompletedOf(lst, this._scheduler)\n  }\n\n  // Implements HK<F, A>\n  /** @hidden */ readonly _funKindF: Future<any>\n  /** @hidden */ readonly _funKindA: A\n\n  // Implements Constructor<T>\n  /** @hidden */ static readonly _funErasure: Future<any>\n\n  /**\n   * Given a function that executes immediately, executes it asynchronously\n   * and returns a `Future` that will complete when the result is ready.\n   *\n   * ```typescript\n   * const sum = (x: number, y: number) =>\n   *   Future.of(() => x + y)\n   * ```\n   *\n   * @param thunk is the function to execute asynchronously\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static of<A>(thunk: () => A, ec: Scheduler = Scheduler.global.get()): Future<A> {\n    const ref = FutureMaker.empty<A>(ec)\n    ec.executeAsync(() => ref.tryComplete(Try.of(thunk)))\n    return ref.future()\n  }\n\n  /**\n   * Lifts a pure value into the `Future` context, returning a `Future`\n   * reference that's already complete with the given value.\n   *\n   * This is the equivalent of `Promise.resolve(a)`.\n   *\n   * ```typescript\n   * const f: Future<number> = Future.pure(10)\n   *\n   * // Prints Success(10)\n   * f.onComplete(r => console.info(r))\n   * ```\n   *\n   * @param a is the value to lift in the `Future` context and that will\n   *        get signaled in `onComplete` callbacks\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static pure<A>(a: A, ec: Scheduler = Scheduler.global.get()): Future<A> {\n    return new PureFuture(Success(a), ec)\n  }\n\n  /**\n   * Lifts an error in the `Future` context, returning a `Future` reference\n   * that's already failed with the given error.\n   *\n   * This is the equivalent of `Promise.reject`.\n   *\n   * ```typescript\n   * const f: Future<number> = Future.raise(\"Oops!\")\n   *\n   * // Prints Failure(\"Oops!\")\n   * f.onComplete(r => console.info(r))\n   * ```\n   *\n   * @param e is the error to lift in the `Future` context and that will\n   *        get signaled as a failure in `onComplete` callbacks\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static raise(e: Throwable, ec: Scheduler = Scheduler.global.get()): Future<never> {\n    return new PureFuture(Failure(e), ec)\n  }\n\n  /**\n   * Given a side-effectful function that triggers an asynchronous computation,\n   * execute it and return a `Future` reference.\n   *\n   * The given `register` function will be invoked immediately to \"schedule\"\n   * the asynchronous callback, where the callback is the parameter injected in\n   * that function.\n   *\n   * The `register` function can optionally return a {@link ICancelable}\n   * reference that can get used to cancel the running asynchronous\n   * computation.\n   *\n   * Example:\n   *\n   * ```typescript\n   * import { Scheduler, Future, Try, Duration, Cancelable } from \"funfix\"\n   *\n   * const delay = <A>(d: Duration, f: () => A, ec: Scheduler = Scheduler.global.get()) =>\n   *   Future.create<A>(\n   *     cb => {\n   *       const task = ec.scheduleOnce(d, () => cb(Try.of(f)))\n   *\n   *       return Cancelable.of(() => {\n   *         console.warn(\"Delayed task was cancelled\")\n   *         task.cancel()\n   *       })\n   *     },\n   *     ec\n   *   )\n   * ```\n   *\n   * Note that by not returning a cancelable, the returned `Future` reference\n   * will NOT BE cancelable.\n   *\n   * ```typescript\n   * // This future is not cancelable, because we are not\n   * // returning a cancelable reference\n   * Future.create<number>(cb => {\n   *   setTimeout(1000, () => cb(Success(10)))\n   * })\n   * ```\n   *\n   * @param register is the side-effectful function that will get invoked\n   *        to build our `Future`, receiving a callback that's supposed to\n   *        get invoked (only once) when the asynchronous computation completes,\n   *        and that can optionally return a cancelable reference that can\n   *        get used to cancel the running computation\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static create<A>(register: (cb: (a: Try<A>) => void) => (ICancelable | void), ec: Scheduler = Scheduler.global.get()): Future<A> {\n    const ref = FutureMaker.empty<A>(ec)\n    try {\n      const cRef = register(ref.complete)\n      return ref.future(cRef || undefined)\n    } catch (e) {\n      return Future.raise(e, ec)\n    }\n  }\n\n  /**\n   * Returns a `Future` reference that's already completed with a `void` value.\n   *\n   * Alias for:\n   *\n   * ```typescript\n   * Future.pure(undefined)\n   * ```\n   *\n   * Note that the same reference is always returned, so this property holds:\n   *\n   * ```typescript\n   * Future.unit() === Future.unit()\n   * ```\n   */\n  static unit(ec: Scheduler = Scheduler.global.get()): Future<void> {\n    // Given that this reference is immutable once built for the given\n    // Scheduler, and that schedulers don't change that much, we are\n    // caching the reference in order to preserve memory\n    const ecAny = ec as any\n    let ref = ecAny[\"_funCache\"] && ecAny[\"_funCache\"][\"futureUnit\"]\n    if (!ref) {\n      ref = new PureFuture(Success(undefined), ec)\n      ecAny[\"_funCache\"] = ecAny[\"_funCache\"] || {}\n      ecAny[\"_funCache\"][\"futureUnit\"] = ref\n    }\n    return ref\n  }\n\n  /**\n   * Returns a `Future` that will complete after the given `delay`.\n   *\n   * This can be used to do delayed execution. For example:\n   *\n   * ```typescript\n   * Future.delayedTick(1000).flatMap(_ =>\n   *   Future.of(() => console.info(\"Hello!\"))\n   * )\n   * ```\n   *\n   * @param delay is the duration to wait before signaling the tick\n   * @param ec is the scheduler that will actually schedule the tick's execution\n   */\n  static delayedTick<A>(delay: number | Duration, ec: Scheduler = Scheduler.global.get()): Future<void> {\n    return Future.create<void>(cb => ec.scheduleOnce(delay, () => cb(Success(undefined))), ec)\n  }\n\n  /**\n   * Keeps calling `f` until it returns a `Right` value.\n   *\n   * Based on Phil Freeman's\n   * [[http://functorial.com/stack-safety-for-free/index.pdf Stack Safety for Free]].\n   *\n   * ```typescript\n   * const generate = () => {\n   *   const n = Math.random() * 1000\n   *   return n & n\n   * }\n   *\n   * // Keeps looping until an odd number is returned\n   * Future.tailRecM(0, a => Future.of(() => {\n   *   return a % 2 == 0 ? Left(generate()) : Right(a)\n   * })\n   * ```\n   *\n   * @param a is the initial seed\n   * @param f is the function that keeps being invoked with the previous\n   *          `Left(a)` value, until a `Right(b)` value is returned,\n   *          which will be the `onComplete` result of the `Future`\n   *          reference\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static tailRecM<A, B>(a: A, f: (a: A) => Future<Either<A, B>>, ec: Scheduler = Scheduler.global.get()): Future<B> {\n    // Recursive loop based on flatMap\n    return f(a).flatMap(r => {\n      if (r.isRight()) return Future.pure(r.get(), ec)\n      return Future.tailRecM(r.swap().get(), f, ec)\n    })\n  }\n\n  /**\n   * Transforms any `Promise`-like data type into a `Future`.\n   *\n   * ```typescript\n   * const p: Promise<number> = Promise.resolve(10)\n   *\n   * const f: Future<number> = Future.fromPromise(p)\n   * ```\n   *\n   * @param ref is the promise reference that we want to convert into a `Future`\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static fromPromise<A>(ref: IPromiseLike<A>, ec: Scheduler = Scheduler.global.get()): Future<A> {\n    if (ref instanceof Future)\n      return (ref as Future<A>).withScheduler(ec)\n    else\n      return Future.create<A>(\n        cb => { ref.then(value => cb(Success(value)),err => cb(Failure(err))) },\n        ec\n      )\n  }\n\n  /**\n   * Builds an already complete `Future` from a `Try` value.\n   *\n   * ```typescript\n   * import { Success, Failure, Future } from \"funfix\"\n   *\n   * // Already completed with 1\n   * const f1 = Future.fromTry(Success(1))\n   *\n   * // Already completed in error\n   * const f2 = Future.fromTry(Failure(\"err\"))\n   * ```\n   *\n   * @param value is the `Try` value to stream in `onComplete` listeners\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static fromTry<A>(value: Try<A>, ec: Scheduler = Scheduler.global.get()): Future<A> {\n    return new PureFuture(value, ec)\n  }\n\n  /**\n   * Creates a race condition between multiple futures, returning the result\n   * of the first one that completes, cancelling the rest.\n   *\n   * ```typescript\n   * const failure = Future.raise(new TimeoutError()).delayResult(2000)\n   *\n   * // Will yield 1\n   * const fa1 = Future.of(() => 1).delayResult(1000)\n   * Future.firstCompletedOf([fa1, failure])\n   *\n   * // Will yield a TimeoutError\n   * const fa2 = Future.of(() => 1).delayResult(10000)\n   * Future.firstCompletedOf([fa2, failure])\n   * ```\n   *\n   * @param list is the list of futures for which the race is started\n   * @param ec is the scheduler doing the needed scheduling and error reporting\n   *\n   * @return a future that will complete with the result of the first\n   *         future form the list to complete, the rest being cancelled\n   */\n  static firstCompletedOf<A>(list: Future<A>[] | Iterable<Future<A>>, ec: Scheduler = Scheduler.global.get()): Future<A> {\n    return futureFirstCompletedOf(list, ec)\n  }\n\n  /**\n   * Given a list of items, builds future results out of it with the specified\n   * mapping function and returns a new future that's going to be completed\n   * with the list of all generated results.\n   *\n   * This is the generic version of {@link Future.sequence}. Useful for\n   * processing futures in parallel, with the `parallelism` factor being\n   * configurable.\n   *\n   * Example:\n   *\n   * ```typescript\n   * const list = [1, 2, 3, 4]\n   *\n   * // Yields [2, 4, 6, 8]\n   * Future.traverse(list)(a => Future.pure(a * 2))\n   * // ... is equivalent to:\n   * Future.sequence(list.map(_ => _ * 2))\n   * ```\n   *\n   * Note that the given `list` is strictly processed, so no lazy behavior\n   * should be expected if an `Iterable` is given.\n   *\n   * But in comparison with {@link Future.sequence}, this builder has lazy\n   * behavior in applying the given mapping function. Coupled with the\n   * `parallelism` factor, this can be used to do batched processing:\n   *\n   * ```typescript\n   * const userIDs = [1, 2, 3, 4]\n   *\n   * // Make at most 2 requests in parallel:\n   * Future.traverse(userIDs, 2)(fetchUserDetails)\n   * ```\n   *\n   * @param list are the values that get fed in the generator function for\n   *        building a list of future results\n   *\n   * @param parallelism is the maximum number of futures that are going to\n   *        be processed in parallel, defaults to `Infinity`\n   *\n   * @param ec is an optional scheduler that's going to be used for scheduling\n   *        the needed asynchronous boundaries\n   *\n   * @return a function that takes as parameter a the generator function that's\n   *         going to map the given `list`, transforming it into a list of\n   *         futures, finally returning a future that's going to complete\n   *         with the list of all asynchronously generated results\n   */\n  static traverse<A>(list: A[] | Iterable<A>, parallelism: number = Infinity, ec: Scheduler = Scheduler.global.get()):\n    <B>(f: (a: A) => Future<B>) => Future<B[]> {\n\n    return <B>(f: (a: A) => Future<B>) =>\n      futureTraverse(list, f, parallelism, ec)\n  }\n\n  /**\n   * Asynchronously transforms a list of futures into a future of a list.\n   *\n   * The equivalent of `Promise.all`, this is the specialized version of\n   * {@link Future.traverse}.\n   *\n   * Contract:\n   *\n   * - the given `Iterable<Future<A>>` list is eagerly evaluated, transformed\n   *   from the start into an `Array<Future<A>>`, so don't expect laziness in\n   *   evaluating it\n   * - In case one of the future fails, then all other futures that are still\n   *   pending get cancelled\n   * - In case the returned future gets cancelled, then all in-progress futures\n   *   from that list get cancelled\n   *\n   * Sample:\n   *\n   * ```typescript\n   * const f1 = Future.of(() => 1)\n   * const f2 = Future.of(() => 2)\n   * const f3 = Future.of(() => 3)\n   *\n   * // Yields [1, 2, 3]\n   * const all: Future<number[]> = Future.sequence([f1, f2, f3])\n   * ```\n   */\n  static sequence<A>(list: Future<A>[] | Iterable<Future<A>>, ec: Scheduler = Scheduler.global.get()): Future<A[]> {\n    return futureSequence(list, ec)\n  }\n\n  /**\n   * Maps 2 `Future` values by the mapping function, returning a new\n   * `Future` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link Future.sequence} operation and as such\n   * on cancellation or failure all future values get cancelled.\n   *\n   * ```typescript\n   * const fa1 = Future.of(() => 1)\n   * const fa2 = Future.of(() => 2)\n   *\n   *\n   * // Yields Success(3)\n   * Future.map2(fa1, fa2, (a, b) => a + b)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Future.map2(fa1, Future.raise(\"error\"),\n   *   (a, b) => a + b\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map2`.\n   */\n  static map2<A1, A2, R>(\n    fa1: Future<A1>, fa2: Future<A2>, f: (a1: A1, a2: A2) => R,\n    ec: Scheduler = Scheduler.global.get()): Future<R> {\n\n    const fl: Future<any[]> = Future.sequence([fa1, fa2] as any[], ec)\n    return fl.map(lst => f(lst[0], lst[1]))\n  }\n\n  /**\n   * Maps 3 `Future` values by the mapping function, returning a new\n   * `Future` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link Future.sequence} operation and as such\n   * on cancellation or failure all future values get cancelled.\n   *\n   * ```typescript\n   * const fa1 = Future.of(() => 1)\n   * const fa2 = Future.of(() => 2)\n   * const fa3 = Future.of(() => 3)\n   *\n   *\n   * // Yields Success(6)\n   * Future.map3(fa1, fa2, fa3, (a, b, c) => a + b + c)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Future.map3(\n   *   fa1, fa2, Future.raise(\"error\"),\n   *   (a, b, c) => a + b + c\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map3`.\n   */\n  static map3<A1, A2, A3, R>(\n    fa1: Future<A1>, fa2: Future<A2>, fa3: Future<A3>,\n    f: (a1: A1, a2: A2, a3: A3) => R,\n    ec: Scheduler = Scheduler.global.get()): Future<R> {\n\n    const fl: Future<any[]> = Future.sequence([fa1, fa2, fa3] as any[], ec)\n    return fl.map(lst => f(lst[0], lst[1], lst[2]))\n  }\n\n  /**\n   * Maps 4 `Future` values by the mapping function, returning a new\n   * `Future` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link Future.sequence} operation and as such\n   * on cancellation or failure all future values get cancelled.\n   *\n   * ```typescript\n   * const fa1 = Future.of(() => 1)\n   * const fa2 = Future.of(() => 2)\n   * const fa3 = Future.of(() => 3)\n   * const fa4 = Future.of(() => 4)\n   *\n   * // Yields Success(10)\n   * Future.map4(fa1, fa2, fa3, fa4, (a, b, c, d) => a + b + c + d)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Future.map4(\n   *   fa1, fa2, fa3, Future.raise(\"error\"),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map4`.\n   */\n  static map4<A1, A2, A3, A4, R>(\n    fa1: Future<A1>, fa2: Future<A2>, fa3: Future<A3>, fa4: Future<A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R,\n    ec: Scheduler = Scheduler.global.get()): Future<R> {\n\n    const fl: Future<any[]> = Future.sequence([fa1, fa2, fa3, fa4] as any[], ec)\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3]))\n  }\n\n  /**\n   * Maps 5 `Future` values by the mapping function, returning a new\n   * `Future` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link Future.sequence} operation and as such\n   * on cancellation or failure all future values get cancelled.\n   *\n   * ```typescript\n   * const fa1 = Future.of(() => 1)\n   * const fa2 = Future.of(() => 2)\n   * const fa3 = Future.of(() => 3)\n   * const fa4 = Future.of(() => 4)\n   * const fa5 = Future.of(() => 5)\n   *\n   * // Yields Success(15)\n   * Future.map5(fa1, fa2, fa3, fa4, fa5,\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Future.map5(\n   *   fa1, fa2, fa3, fa4, Future.raise(\"error\"),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map5`.\n   */\n  static map5<A1, A2, A3, A4, A5, R>(\n    fa1: Future<A1>, fa2: Future<A2>, fa3: Future<A3>, fa4: Future<A4>, fa5: Future<A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R,\n    ec: Scheduler = Scheduler.global.get()): Future<R> {\n\n    const fl: Future<any[]> = Future.sequence([fa1, fa2, fa3, fa4, fa5] as any[], ec)\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3], lst[4]))\n  }\n\n  /**\n   * Maps 6 `Future` values by the mapping function, returning a new\n   * `Future` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link Future.sequence} operation and as such\n   * on cancellation or failure all future values get cancelled.\n   *\n   * ```typescript\n   * const fa1 = Future.of(() => 1)\n   * const fa2 = Future.of(() => 2)\n   * const fa3 = Future.of(() => 3)\n   * const fa4 = Future.of(() => 4)\n   * const fa5 = Future.of(() => 5)\n   * const fa6 = Future.of(() => 6)\n   *\n   * // Yields Success(21)\n   * Future.map6(\n   *   fa1, fa2, fa3, fa4, fa5, fa6,\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Future.map6(\n   *   fa1, fa2, fa3, fa4, fa5, Future.raise(\"error\"),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map6`.\n   */\n  static map6<A1, A2, A3, A4, A5, A6, R>(\n    fa1: Future<A1>, fa2: Future<A2>, fa3: Future<A3>, fa4: Future<A4>, fa5: Future<A5>, fa6: Future<A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R,\n    ec: Scheduler = Scheduler.global.get()): Future<R> {\n\n    const fl: Future<any[]> = Future.sequence([fa1, fa2, fa3, fa4, fa5, fa6] as any[], ec)\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3], lst[4], lst[5]))\n  }\n}\n\nclass PureFuture<A> extends Future<A> {\n  constructor(\n    private readonly _value: Try<A>,\n    protected readonly _scheduler: Scheduler) { super() }\n\n  cancel(): void {}\n  value(): Option<Try<A>> { return Some(this._value) }\n\n  withScheduler(ec: Scheduler): Future<A> {\n    if (this._scheduler === ec) return this\n    return new PureFuture(this._value, ec)\n  }\n\n  onComplete(f: (a: Try<A>) => void): void {\n    this._scheduler.executeBatched(() => f(this._value))\n  }\n\n  transformWith<B>(failure: (e: Throwable) => Future<B>, success: (a: A) => Future<B>): Future<B> {\n    return genericTransformWith(this, failure, success, this._scheduler)\n  }\n\n  toPromise(): Promise<A> {\n    return this._value.fold(e => Promise.reject(e), a => Promise.resolve(a))\n  }\n}\n\n/**\n * Internal state shared between {@link AsyncFuture} and\n * {@link FutureMaker}.\n *\n * @Hidden\n */\nclass AsyncFutureState<A> {\n  id: null | \"chained\" | \"complete\"\n  ref: null | ((a: Try<A>) => void)[] | AsyncFutureState<A> | Try<A>\n\n  constructor() {\n    this.id = null\n    this.ref = null\n  }\n\n  compressedRoot(): AsyncFutureState<A> {\n    let cursor: AsyncFutureState<A> = this\n    while (cursor.id === \"chained\") {\n      cursor = cursor.ref as AsyncFutureState<A>\n      this.ref = cursor\n    }\n    return cursor\n  }\n\n  value(): Option<Try<A>> {\n    switch (this.id) {\n      case null: return None\n      case \"complete\":\n        return Some(this.ref as Try<A>)\n      case \"chained\":\n        return this.compressedRoot().value()\n    }\n  }\n\n  tryComplete(r: Try<A>, ec: Scheduler): boolean {\n    switch (this.id) {\n      case null:\n        const xs = (this.ref as (null | ((a: Try<A>) => void)[]))\n        this.ref = r\n        this.id = \"complete\"\n        if (xs) {\n          for (let i = 0; i < xs.length; i++)\n            ec.executeBatched(() => xs[i](r))\n        }\n        return true\n\n      case \"complete\":\n        return false\n\n      case \"chained\":\n        const ref = (this.ref as AsyncFutureState<A>).compressedRoot()\n        const result = ref.tryComplete(r, ec)\n        this.id = \"complete\"\n        this.ref = result ? r : ref.value().get()\n        return result\n    }\n  }\n\n  chainTo(target: AsyncFutureState<A>, ec: Scheduler): void {\n    switch (this.id) {\n      case null:\n        const xs = (this.ref as (null | ((a: Try<A>) => void)[]))\n        this.id = \"chained\"\n        this.ref = target.compressedRoot()\n\n        if (xs && xs.length > 0) {\n          // Transferring all listeners to chained future\n          for (let i = 0; i < xs.length; i++)\n            target.onComplete(xs[i], ec)\n        }\n        break\n\n      case \"chained\":\n        this.compressedRoot().chainTo(target.compressedRoot(), ec)\n        break\n\n      case \"complete\":\n        target.tryComplete(this.ref as Try<A>, ec)\n        break\n    }\n  }\n\n  onComplete(f: (a: Try<A>) => void, ec: Scheduler): void {\n    switch (this.id) {\n      case null:\n        if (!this.ref) this.ref = [];\n        (this.ref as ((a: Try<A>) => void)[]).push(f)\n        break\n      case \"complete\":\n        // Forced async boundary\n        ec.executeBatched(() => f(this.ref as Try<A>))\n        break\n      case \"chained\":\n        (this.ref as AsyncFutureState<A>).onComplete(f, ec)\n        break\n    }\n  }\n}\n\n/**\n * Internal `Future` implementation that's the result of a\n * {@link FutureMaker.future}.\n *\n * @Hidden\n */\nclass AsyncFuture<A> extends Future<A> {\n  readonly _state: AsyncFutureState<A>\n  readonly _scheduler: Scheduler\n  _cancelable?: ICancelable\n\n  constructor(state: AsyncFutureState<A>, cRef: ICancelable | undefined, ec: Scheduler) {\n    super()\n    this._state = state\n    this._scheduler = ec\n    if (cRef) this._cancelable = cRef\n  }\n\n  value(): Option<Try<A>> {\n    return this._state.value()\n  }\n\n  onComplete(f: (a: Try<A>) => void): void {\n    return this._state.onComplete(f, this._scheduler)\n  }\n\n  cancel(): void {\n    if (this._cancelable) {\n      try { this._cancelable.cancel() }\n      finally { delete this._cancelable }\n    }\n  }\n\n  withScheduler(ec: Scheduler): Future<A> {\n    if (this._scheduler === ec) return this\n    return new AsyncFuture(this._state, this._cancelable, ec)\n  }\n\n  transformWith<B>(failure: (e: Throwable) => Future<B>, success: (a: A) => Future<B>): Future<B> {\n    return genericTransformWith(this, failure, success, this._scheduler, this._cancelable)\n  }\n}\n\n/**\n * A write interface for {@link Future} to use when implementing\n * producers.\n *\n * This would be the equivalent of the now deprecated `Deferred`\n * data type in JavaScript.\n *\n * Example:\n *\n * ```typescript\n * import { Future, FutureMaker, Scheduler, Success } from \"funfix\"\n *\n * const ec = Scheduler.global.get()\n * const m = FutureMaker.empty<number>()\n *\n * // The producer\n * ec.scheduleOnce(1000, () => m.complete(Success(1)))\n *\n * // The future that will eventually complete when\n * // `m.complete` gets called\n * const f: Future<number> = maker.future()\n * ```\n */\nexport class FutureMaker<A> {\n  private readonly _state: AsyncFutureState<A>\n  private readonly _scheduler: Scheduler\n\n  private constructor(state: AsyncFutureState<A>, ec: Scheduler) {\n    this[\"_state\"] = state\n    this._scheduler = ec\n  }\n\n  /**\n   * Tries to complete this future builder either with a successful\n   * value or with a failure.\n   *\n   * This function can be used in concurrent races where multiple\n   * actors compete for completing the same `FutureMaker`.\n   *\n   * ```typescript\n   * const m = FutureMaker.empty<number>()\n   *\n   * m.tryComplete(Success(1)) //=> true\n   * m.tryComplete(Success(2)) //=> false\n   *\n   * m.future() //=> Yields 1\n   * ```\n   *\n   * In case you have a guarantee that the completion only\n   * happens once, then usage of {@link complete} is recommended.\n   *\n   * @return `false` in case the `FutureMaker` has been already\n   *         completed, or `true` otherwise\n   */\n  readonly tryComplete: (result: Try<A>) => boolean =\n    r => this[\"_state\"].tryComplete(r, this._scheduler)\n\n  /**\n   * Completes this `FutureMaker` either with a successful value or\n   * with a failure, but throws an exception if this maker was\n   * already completed.\n   *\n   * Due to throwing exceptions, this function is recommended for\n   * usage in cases where there's a guarantee that the completion\n   * of the `FutureMaker` is attempted only once.\n   *\n   * ```typescript\n   * const m = FutureMaker.empty<number>()\n   *\n   * m.complete(Success(1))\n   *\n   * m.complete(Success(2)) //=> throws IllegalStateError\n   * ```\n   *\n   * In case you have a concurrent race, see {@link tryComplete}\n   * for a version that does not throw exceptions.\n   */\n  readonly complete: (result: Try<A>) => void =\n    r => {\n      if (!this.tryComplete(r))\n        throw new IllegalStateError(\"Cannot complete a FutureMaker twice!\")\n    }\n\n  /**\n   * Alias for `tryComplete(Success(value))`.\n   *\n   * See {@link tryComplete}.\n   */\n  trySuccess(value: A): boolean {\n    return this.tryComplete(Success(value))\n  }\n\n  /**\n   * Alias for `complete(Success(value))`.\n   *\n   * See {@link complete}.\n   */\n  success(value: A): void {\n    return this.complete(Success(value))\n  }\n\n  /**\n   * Alias for `tryComplete(Failure(error))`.\n   *\n   * See {@link tryComplete}.\n   */\n  tryFailure(error: Throwable): boolean {\n    return this.tryComplete(Failure(error))\n  }\n\n  /**\n   * Alias for `complete(Failure(value))`.\n   *\n   * See {@link complete}.\n   */\n  failure(error: Throwable): void {\n    return this.complete(Failure(error))\n  }\n\n  /**\n   * Chains this to `target` such that any subsequent operations on\n   * this future maker is reflected on `target`.\n   *\n   * ```typescript\n   * const main = FutureMaker.empty<number>()\n   * const child = FutureMaker.empty<number>()\n   *\n   * // Now all operations on `child` will be redirected to `main`\n   * child.chainTo(main)\n   *\n   * // Completing `child` will complete `main`\n   * child.complete(Success(1))\n   *\n   * main.future() //=> Yields 1\n   * child.future() //=> Yields 1\n   * ```\n   *\n   * The purpose of this method is the same as with\n   * {@link ChainedCancelable}, to be used in pieces of logic where\n   * the chaining of `onComplete` calls creates a memory leaks,\n   * chaining being used to get rid of such chains.\n   *\n   * This method is being used in the implementation of\n   * {@link Future.flatMap} for example to make it memory safe.\n   *\n   * CREDITS: this was inspired by Scala's `scala.concurrent.Scala`\n   * implementation.\n   */\n  chainTo(target: FutureMaker<A>): void {\n    this[\"_state\"].chainTo(target[\"_state\"], this._scheduler)\n  }\n\n  /**\n   * Creates and returns a {@link Future} that will complete when this\n   * future maker is completed.\n   *\n   * ```typescript\n   * const m = FutureMaker.empty<number>()\n   *\n   * // Creates a simple future, no cancellation logic:\n   * m.future()\n   *\n   * // Creates a future with baked in cancellation logic:\n   * const cRef = Cancelable.of(() => console.log(\"Cancelled!\"))\n   * m.future(cRef)\n   * ```\n   *\n   * @param cancelable is an optional reference that can indicate\n   *        cancellation logic to be baked into the created future\n   */\n  future(cancelable?: ICancelable): Future<A> {\n    switch (this._state.id) {\n      case \"complete\":\n        return new PureFuture(this[\"_state\"].ref as Try<A>, this._scheduler)\n      default:\n        return new AsyncFuture(this[\"_state\"], cancelable, this._scheduler)\n    }\n  }\n\n  /**\n   * Returns a new `FutureMaker` that mirrors the state of the source,\n   * but that uses the given {@link Scheduler} reference for\n   * managing the required async boundaries.\n   *\n   * The given `Scheduler` reference is used for inserting async\n   * boundaries when the registered listeners are triggered when\n   * [.complete]{@link complete} is called or for data transformations\n   * executed on the future references returned by\n   * [.future]{@link FutureMaker.future}.\n   *\n   * See {@link Future.withScheduler}.\n   */\n  withScheduler(ec: Scheduler): FutureMaker<A> {\n    if (this._scheduler === ec) return this\n    return new FutureMaker(this._state, ec)\n  }\n\n  /**\n   * Returns an empty `FutureMaker` reference awaiting completion.\n   *\n   * This is the builder that one should use for building\n   * `FutureMaker` instances, since the default constructor is not\n   * exposed due to it exposing internal state.\n   */\n  static empty<A>(ec: Scheduler = Scheduler.global.get()): FutureMaker<A> {\n    return new FutureMaker(new AsyncFutureState(), ec)\n  }\n\n  /**\n   * Returns an already completed {@link FutureMaker} reference.\n   *\n   * Example:\n   *\n   * ```typescript\n   * const m = FutureMaker.completed(Success(1))\n   *\n   * m.future() // Yields 1\n   *\n   * m.complete(Success(2)) // Throws IllegalStateError\n   * ```\n   *\n   * If all you need is a `Future`, then use {@link Future.fromTry}\n   * instead.\n   */\n  static completed<A>(value: Try<A>, ec: Scheduler = Scheduler.global.get()): FutureMaker<A> {\n    const state = new AsyncFutureState<A>()\n    state.id = \"complete\"\n    state.ref = value\n    return new FutureMaker(state, ec)\n  }\n}\n\n/**\n * Internal, common `transformWith` implementation.\n *\n * @Hidden\n */\nfunction genericTransformWith<A, B>(\n  self: Future<A>,\n  failure: (e: Throwable) => Future<B>,\n  success: (a: A) => Future<B>,\n  scheduler: Scheduler,\n  cancelable?: ICancelable): Future<B> {\n\n  const defer = FutureMaker.empty<B>(scheduler)\n  const cRef = new ChainedCancelable(cancelable)\n\n  self.onComplete(tryA => {\n    let fb: Future<B>\n    try {\n      fb = tryA.fold(failure, success)\n    } catch (e) {\n      fb = Future.raise(e)\n    }\n\n    // If the resulting Future is already completed, there's no point\n    // in treating it as being cancelable\n    if (fb.value().isEmpty()) {\n      const fbb = fb as any\n      const cNext = fbb._cancelable\n\n      if (cNext && cNext instanceof ChainedCancelable) {\n        // Trick we are doing to get rid of extraneous memory\n        // allocations, otherwise we can leak memory\n        cNext.chainTo(cRef)\n      } else if (cNext && !(cNext instanceof DummyCancelable)) {\n        cRef.update(cNext)\n      }\n    } else {\n      // GC purposes\n      cRef.clear()\n    }\n\n    if (fb instanceof AsyncFuture) {\n      fb._state.chainTo(defer[\"_state\"] as AsyncFutureState<B>, scheduler)\n    } else {\n      (fb as Future<B>).onComplete(defer.tryComplete)\n    }\n  })\n\n  return defer.future(cRef)\n}\n\n/**\n * Internal, reusable function used in the implementation of {@link Future.then}.\n *\n * @Hidden\n */\nfunction promiseThen<T, R>(\n  f: ((t: T) => IPromiseLike<R> | R) | undefined | null,\n  alt: (t: T) => Future<T>,\n  ec: Scheduler):\n  ((value: T) => Future<R | T>) {\n\n  return value => {\n    if (typeof f !== \"function\") return alt(value)\n\n    const fb = f(value)\n    if (!fb) return Future.pure(value, ec)\n\n    if (typeof (fb as any).then === \"function\")\n      return Future.fromPromise(fb as IPromiseLike<R>, ec)\n    else\n      return Future.pure(fb as R, ec)\n  }\n}\n\n/** @Hidden */\nfunction futureCancelAll<A>(list: Future<A>[], ec: Scheduler, skip: number = -1): void {\n  const errors = []\n  for (let i = 0; i < list.length; i++) {\n    if (i !== skip)\n      try { list[i].cancel() } catch (e) { errors.push(e) }\n  }\n\n  if (errors.length > 0) {\n    for (const e of errors) ec.reportFailure(e)\n  }\n}\n\n/** @Hidden */\nfunction futureIterableToArray<A>(values: Future<A>[] | Iterable<Future<A>>, ec: Scheduler): Future<A>[] {\n  if (!values) return []\n  if (Object.prototype.toString.call(values) === \"[object Array]\")\n    return values as Future<A>[]\n\n  const arr: Future<A>[] = []\n  try {\n    const cursor = values[Symbol.iterator]()\n\n    while (true) {\n      const item = cursor.next()\n      if (item.value) arr.push(item.value)\n      if (item.done) break\n    }\n\n    return arr\n  } catch (e) {\n    futureCancelAll(arr, ec)\n    throw e\n  }\n}\n\n/**\n * Internal implementation for `Future.sequence`.\n *\n * @Hidden\n */\nfunction futureSequence<A>(values: Future<A>[] | Iterable<Future<A>>, ec: Scheduler): Future<A[]> {\n  return Future.create<A[]>(cb => {\n    try {\n      // This can throw, handling error below\n      const futures = futureIterableToArray(values, ec)\n      // Short-circuit in case the list is empty, otherwise the\n      // futureSequenceLoop fails (must be non-empty as an invariant)\n      if (futures.length === 0) return cb(Success([]))\n      const cRef = Cancelable.of(() => futureCancelAll(futures, ec))\n\n      // Creating race condition\n      let isDone = false\n      let finishedCount = 0\n      let finalArray: A[] = []\n\n      for (let index = 0; index < futures.length; index++) {\n        const fi = index\n        const fa = futures[index]\n\n        fa.onComplete(result => {\n          finishedCount += 1\n\n          if (result.isSuccess()) {\n            if (!isDone) {\n              finalArray[fi] = result.get()\n              isDone = finishedCount === futures.length\n              if (isDone) cb(Success(finalArray))\n            }\n          } else {\n            if (!isDone) {\n              isDone = true\n              cRef.cancel()\n              cb(result as any)\n            } else {\n              ec.reportFailure(result.failed().get())\n            }\n          }\n        })\n      }\n\n      return cRef\n    } catch (e) {\n      // If an error happens here, it means the conversion from iterable to\n      // array failed, and the futures we've seen are already canceled\n      cb(Failure(e))\n    }\n  }, ec)\n}\n\n/**\n * Internal implementation for `Future.firstCompletedOf`.\n *\n * @Hidden\n */\nfunction futureFirstCompletedOf<A>(iterable: Future<A>[] | Iterable<Future<A>>, ec: Scheduler): Future<A> {\n  return Future.create<A>(cb => {\n    try {\n      // This can throw, handling error below\n      const futures = futureIterableToArray(iterable, ec)\n      // Short-circuit in case the list is empty, otherwise the\n      // futureSequenceLoop fails (must be non-empty as an invariant)\n      if (futures.length === 0) return cb(Failure(new IllegalArgumentError(\"empty list of futures\")))\n\n      // Creating race condition\n      let isDone = false\n\n      for (let index = 0; index < futures.length; index++) {\n        const fi = index\n        const fa = futures[index]\n\n        fa.onComplete(result => {\n          if (!isDone) {\n            isDone = true\n            futureCancelAll(futures, ec, fi)\n            cb(result)\n          } else if (result.isFailure()) {\n            ec.reportFailure(result.failed().get())\n          }\n        })\n      }\n\n      return Cancelable.of(() => futureCancelAll(futures, ec))\n    } catch (e) {\n      // If an error happens here, it means the conversion from iterable to\n      // array failed, and the futures we've seen are already canceled\n      cb(Failure(e))\n    }\n  }, ec)\n}\n\n/**\n * Internal implementation for `Future.traverse`.\n *\n * @Hidden\n */\nfunction futureTraverse<A, B>(\n  list: A[] | Iterable<A>,\n  f: (a: A) => Future<B>,\n  parallelism: number,\n  ec: Scheduler): Future<B[]> {\n\n  if (parallelism <= 0) {\n    throw new IllegalArgumentError(`parallelism <= 0`)\n  }\n  return Future.of(() => iterableToArray(list), ec)\n    .flatMap(values => futureTraverseLoop(values, f, parallelism, ec, 0, []))\n}\n\n/** @Hidden */\nfunction futureTraverseLoop<A, B>(\n  list: A[],\n  f: (a: A) => Future<B>,\n  parallelism: number,\n  ec: Scheduler,\n  index: number,\n  result: B[]): Future<B[]> {\n\n  if (index >= list.length) return Future.pure(result, ec)\n  let batch: Future<B>[] = []\n  let length = 0\n\n  try {\n    while (index < list.length && length < parallelism) {\n      batch.push(f(list[index++]))\n      length += 1\n    }\n\n    const fa = Future.sequence(batch, ec).map(b => {\n      for (let i = 0; i < b.length; i++) result.push(b[i])\n    })\n\n    if (index >= list.length) {\n      // We are done, signal final result\n      return fa.map(_ => result)\n    } else {\n      // Continue with the next batch\n      return fa.flatMap(_ => futureTraverseLoop(list, f, parallelism, ec, index, result))\n    }\n  } catch (e) {\n    // Batch generation triggered an error\n    futureCancelAll(batch, ec)\n    return Future.raise(e)\n  }\n}\n","/*!\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Either,\n  Try,\n  Success,\n  Failure,\n  Throwable,\n  TimeoutError,\n  Option, Some, None\n} from \"funfix-core\"\n\nimport {\n  ICancelable,\n  Cancelable,\n  StackedCancelable,\n  Scheduler,\n  Future, ExecutionModel,\n  execInternals, Duration\n} from \"funfix-exec\"\n\nimport {\n  IteratorLike,\n  iteratorOf\n} from \"./internals\"\n\n/**\n * `IO` represents a specification for a possibly lazy or\n * asynchronous computation, which when executed will produce an `A`\n * as a result, along with possible side-effects.\n *\n * Compared with Funfix's\n * [Future](https://funfix.org/api/exec/classes/future.html) (see\n * [funfix-exec](https://funfix.org/api/exec/)) or JavaScript's\n * [Promise](https://promisesaplus.com/),\n * `IO` does not represent a running computation or a value detached\n * from time, as `IO` does not execute anything when working with its\n * builders or operators and it does not submit any work into the\n * [Scheduler](https://funfix.org/api/exec/classes/scheduler.html) or any\n * run-loop for execution, the execution eventually\n * taking place only after {@link IO.run} is called and not before\n * that.\n *\n * In order to understand `IO`, here's the design space:\n *\n * |                  | Strict                     | Lazy                               |\n * |------------------|:--------------------------:|:----------------------------------:|\n * | **Synchronous**  | `A`                        | `() => A`                          |\n * |                  |                            | [Eval&lt;A&gt;]{@link Eval}        |\n * | **Asynchronous** | `(Try<A> => void) => void` | `() => ((Try<A> => void) => void)` |\n * |                  | `Future<A>` / `Promise`    | [IO&lt;A&gt;]{@link IO}            |\n *\n * JavaScript is a language (and runtime) that's strict by default,\n * meaning that expressions are evaluated immediately instead of\n * being evaluated on a by-need basis, like in Haskell.\n *\n * So a value `A` is said to be strict. To turn an `A` value into a lazy\n * value, you turn that expression into a parameterless function of\n * type `() => A`, also called a \"thunk\".\n *\n * A [Future](https://funfix.org/api/exec/classes/future.html) is a\n * value that's produced by an asynchronous process, but it is said\n * to have strict behavior, meaning that when you receive a `Future`\n * reference, whatever process that's supposed to complete the\n * `Future` has probably started already. This goes for\n * [JavaScript's Promise](https://promisesaplus.com) as well.\n *\n * But there are cases where we don't want strict values, but lazily\n * evaluated ones. In some cases we want functions, or\n * `Future`-generators. Because we might want better handling of\n * parallelism, or we might want to suspend *side effects*. As\n * without suspending *side effects* we don't have *referential\n * transparency*, which really helps with reasoning about the code,\n * being the essence of *functional programming*.\n *\n * This `IO` type is thus the complement to `Future`, a lazy, lawful\n * monadic type that can describe any side effectful action, including\n * asynchronous ones, also capable of suspending side effects.\n *\n * ## Getting Started\n *\n * To build an `IO` from a parameterless function returning a value\n * (a thunk), we can use `IO.of`:\n *\n * ```typescript\n * const hello = IO.of(() => \"Hello \")\n * const world = IO.of(() => \"World!\")\n * ```\n *\n * Nothing gets executed yet, as `IO` is lazy, nothing executes\n * until you trigger [run]{@link IO.run} on it.\n *\n * To combine `IO` values we can use `map` and `flatMap`, which\n * describe sequencing and this time is in a very real sense because\n * of the laziness involved:\n *\n * ```typescript\n * const sayHello = hello\n *   .flatMap(h => world.map(w => h + w))\n *   .map(console.info)\n * ```\n *\n * This `IO` reference will trigger a side effect on evaluation, but\n * not yet. To make the above print its message:\n *\n * ```typescript\n * const f: Future<void> = sayHello.run()\n *\n * //=> Hello World!\n * ```\n *\n * The returned type is a\n * [Future](https://funfix.org/api/exec/classes/future.html), a value\n * that can be completed already or might be completed at some point\n * in the future, once the running asynchronous process finishes.\n * It's the equivalent of JavaScript's `Promise`, only better and\n * cancelable, see next topic.\n *\n * ## Laziness\n *\n * The fact that `IO` is lazy, whereas `Future` and `Promise` are not\n * has real consequences. For example with `IO` you can do this:\n *\n * ```typescript\n * function retryOnFailure<A>(times: number, io: IO<A>): IO<A> {\n *   return source.recoverWith(err => {\n *     // No more retries left? Re-throw error:\n *     if (times <= 0) return IO.raise(err)\n *     // Recursive call, yes we can!\n *     return retryOnFailure(times - 1, io)\n *       // Adding 500 ms delay for good measure\n *       .delayExecution(500)\n *   })\n * }\n * ```\n *\n * `Future` being a strict value-wannabe means that the actual value\n * gets \"memoized\" (means cached), however `IO` is basically a function\n * that can be repeated for as many times as you want. `IO` can also\n * do memoization of course:\n *\n * ```typescript\n * io.memoize()\n * ```\n *\n * The difference between this and just calling `run()` is that\n * `memoize()` still returns an `IO` and the actual memoization\n * happens on the first `run()` (with idempotency guarantees of\n * course).\n *\n * But here's something else that `Future` or your favorite\n * `Promise`-like data type cannot do:\n *\n * ```typescript\n * io.memoizeOnSuccess()\n * ```\n *\n * This keeps repeating the computation for as long as the result is a\n * failure and caches it only on success. Yes we can!\n *\n * ### Parallelism\n *\n * Because of laziness, invoking {@link IO.sequence} will not work like\n * it does for `Future.sequence` or `Promise.all`, the given `IO` values\n * being evaluated one after another, in *sequence*, not in *parallel*.\n * If you want parallelism, then you need to use {@link IO.gather} and\n * thus be explicit about it.\n *\n * This is great because it gives you the possibility of fine tuning the\n * execution. For example, say you want to execute things in parallel,\n * but with a maximum limit of 30 tasks being executed in parallel.\n * One way of doing that is to process your list in batches.\n *\n * This sample assumes you have [lodash](https://lodash.com/) installed,\n * for manipulating our array:\n *\n * ```typescript\n * import * as _ from \"lodash\"\n * import { IO } from \"funfix\"\n *\n * // Some array of IOs, you come up with something good :-)\n * const list: IO<string>[] = ???\n *\n * // Split our list in chunks of 30 items per chunk,\n * // this being the maximum parallelism allowed\n * const chunks = _.chunks(list, 30)\n * // Specify that each batch should process stuff in parallel\n * const batchedIOs = _.map(chunks, chunk => IO.gather(chunk))\n * // Sequence the batches\n * const allBatches = IO.sequence(batchedIOs)\n *\n * // Flatten the result, within the context of IO\n * const all: IO<string[]> =\n *   allBatches.map(batches => _.flatten(batches))\n * ```\n *\n * Note that the built `IO` reference is just a specification at this point,\n * or you can view it as a function, as nothing has executed yet, you need\n * to call {@link IO.run .run} explicitly.\n *\n * ## Cancellation\n *\n * The logic described by an `IO` task could be cancelable, depending\n * on how the `IO` gets built. This is where the `IO`-`Future`\n * symbiosis comes into play.\n *\n * Futures can also be canceled, in case the described computation can\n * be canceled. When describing `IO` tasks with `IO.of` nothing can be\n * cancelled, since there's nothing about a plain function that you\n * can cancel, but, we can build cancelable tasks with\n * {@link IO.async}:\n *\n * ```typescript\n * import { Cancelable, Success, IO } from \"funfix\"\n *\n * const delayedHello = IO.async((scheduler, callback) => {\n *   const task = scheduler.scheduleOnce(1000, () => {\n *     console.info(\"Delayed Hello!\")\n *     // Signaling successful completion\n *     // (\"undefined\" inhabits type \"void\")\n *     callback(Success(undefined))\n *   })\n *\n *   return Cancelable.of(() => {\n *     console.info(\"Cancelling!\")\n *     task.cancel()\n *   })\n * })\n * ```\n *\n * The sample above prints a message with a delay, where the delay\n * itself is scheduled with the injected `Scheduler`. The `Scheduler`\n * is in fact an optional parameter to {@link IO.run} and if one\n * isn't explicitly provided, then `Scheduler.global` is assumed.\n *\n * This action can be cancelled, because it specifies cancellation\n * logic. If we wouldn't return an explicit `Cancelable` there,\n * then cancellation wouldn't work. But for this `IO` reference\n * it does:\n *\n * ```typescript\n * // Triggering execution, which sends a task to execute by means\n * // of JavaScript's setTimeout (under the hood):\n * const f: Future<void> = delayedHello.run()\n *\n * // If we change our mind before the timespan has passed:\n * f.cancel()\n * ```\n *\n * Also, given an `IO` task, we can specify actions that need to be\n * triggered in case of cancellation:\n *\n * ```typescript\n * const io = IO.of(() => console.info(\"Hello!\"))\n *   .executeForked()\n *\n * io.doOnCancel(IO.of(() => {\n *   console.info(\"A cancellation attempt was made!\")\n * })\n *\n * const f: Future<void> = io.run()\n *\n * // Note that in this case cancelling the resulting Future\n * // will not stop the actual execution, since it doesn't know\n * // how, but it will trigger our on-cancel callback:\n *\n * f.cancel()\n * //=> A cancellation attempt was made!\n * ```\n *\n * ## Note on the ExecutionModel\n *\n * `IO` is conservative in how it introduces async boundaries.\n * Transformations like `map` and `flatMap` for example will default\n * to being executed on the current call stack on which the\n * asynchronous computation was started. But one shouldn't make\n * assumptions about how things will end up executed, as ultimately\n * it is the implementation's job to decide on the best execution\n * model. All you are guaranteed is asynchronous execution after\n * executing `run`.\n *\n * Currently the default `ExecutionModel` specifies batched execution\n * by default and `IO` in its evaluation respects the injected\n * `ExecutionModel`. If you want a different behavior, you need to\n * execute the `IO` reference with a different scheduler.\n *\n * In order to configure a different execution model, this config\n * can be injected by means of a custom scheduler:\n *\n * ```typescript\n * import { Scheduler, ExecutionModel } from \"funfix\"\n *\n * const ec = Scheduler.global.get()\n *   .withExecutionModel(ExecutionModel.alwaysAsync())\n *\n * // ...\n * io.run(ec)\n * ```\n *\n * Or you can configure an `IO` reference to execute with a certain\n * execution model that overrides the configuration of the injected\n * scheduler, by means of {@link IO.executeWithModel}:\n *\n * ```typescript\n * io.executeWithModel(ExecutionModel.batched(256))\n * ```\n *\n * ## Versus Eval\n *\n * For dealing with lazy evaluation, the other alternative is\n * the {@link Eval} data type.\n *\n * Differences between `Eval` and `IO`:\n *\n * 1. `IO` is capable of describing asynchronous computations as well\n * 2. `IO` is capable of error handling (it implements `MonadError`),\n *    whereas `Eval` does not provide error handling capabilities,\n *    being meant to be used for pure expressions (it implements\n *    `Comonad`, which is incompatible with `MonadError`)\n * 3. You cannot rely on `IO` to produce a value immediately, since\n *    we cannot block threads on top of JavaScript engines\n *\n * So if you need error handling capabilities\n * (i.e. `MonadError<Throwable, ?>`), or if you need to describe\n * asynchronous processes, then `IO` is for you. {@link Eval}\n * is a simpler data type with the sole purpose of controlling the\n * evaluation of expressions (i.e. strict versus lazy).\n *\n * ## Credits\n *\n * This type is inspired by `cats.effect.IO` from\n * {@link http://typelevel.org/cats/|Typelevel Cats},\n * by `monix.eval.Task` from {@link https://monix.io|Monix}, by\n * `scalaz.effect.IO` from [Scalaz](https://github.com/scalaz/scalaz),\n * which are all inspired by Haskell's `IO` data type.\n *\n * @final\n */\nexport class IO<A> {\n  /**\n   * Triggers the asynchronous execution.\n   *\n   * Without invoking `run` on a `IO`, nothing gets evaluated, as an\n   * `IO` has lazy behavior.\n   *\n   * ```typescript\n   * // Describing a side effect\n   * const io = IO.of(() => console.log(\"Hello!\"))\n   *   // Delaying it for 1 second, for didactical purposes\n   *   .delayExecution(1000)\n   *\n   * // Nothing executes until we call run on it, which gives\n   * // us a Future in return:\n   * const f: Future<void> = io.run()\n   *\n   * // The given Future is cancelable, in case the logic\n   * // decribed by our IO is cancelable, so we can do this:\n   * f.cancel()\n   * ```\n   *\n   * Note that `run` takes a\n   * [Scheduler](https://funfix.org/api/exec/classes/scheduler.html)\n   * as an optional parameter and if one isn't provided, then the\n   * default scheduler gets used. The `Scheduler` is in charge\n   * of scheduling asynchronous boundaries, executing tasks\n   * with a delay (e.g. `setTimeout`) or of reporting failures\n   * (with `console.error` by default).\n   *\n   * Also see {@link IO.runOnComplete} for a version that takes a\n   * callback as parameter.\n   *\n   * @return a `Future` that will eventually complete with the\n   *         result produced by this `IO` on evaluation\n   */\n  run(ec: Scheduler = Scheduler.global.get()): Future<A> {\n    return taskToFutureRunLoop(this, ec)\n  }\n\n  /**\n   * Triggers the asynchronous execution.\n   *\n   * Without invoking `run` on a `IO`, nothing gets evaluated, as an\n   * `IO` has lazy behavior.\n   *\n   * `runComplete` starts the evaluation and takes a callback which\n   * will be triggered when the computation is complete.\n   *\n   * Compared with JavaScript's `Promise.then` the provided callback\n   * is a function that receives a\n   * [Try](https://funfix.org/api/core/classes/try.html) value, a data\n   * type which is what's called a \"logical disjunction\", or a \"tagged\n   * union type\", a data type that can represent both successful\n   * results and failures. This is because in Funfix we don't work\n   * with `null`.\n   *\n   * Also the returned value is an\n   * [ICancelable](https://funfix.org/api/exec/interfaces/icancelable.html)\n   * reference, which can be used to cancel the running computation,\n   * in case the logic described by our `IO` is cancelable (note that\n   * some procedures cannot be cancelled, it all depends on how the\n   * `IO` value was described, see {@link IO.async} for how cancelable\n   * `IO` values can be built).\n   *\n   * Example:\n   *\n   * ```typescript\n   * // Describing a side effect\n   * const io = IO.of(() => console.log(\"Hello!\"))\n   *   .delayExecution(1000)\n   *\n   * // Nothing executes until we explicitly run our `IO`:\n   * const c: ICancelable = io.runOnComplete(r =>\n   *   r.fold(\n   *     err => console.error(err),\n   *     _ => console.info(\"Done!\")\n   *   ))\n   *\n   * // In case we change our mind and the logic described by\n   * // our `IO` is cancelable, we can cancel it:\n   * c.cancel()\n   * ```\n   *\n   * Note that `runOnComplete` takes a\n   * [Scheduler](https://funfix.org/api/exec/classes/scheduler.html)\n   * as an optional parameter and if one isn't provided, then the\n   * default scheduler gets used. The `Scheduler` is in charge\n   * of scheduling asynchronous boundaries, executing tasks\n   * with a delay (e.g. `setTimeout`) or of reporting failures\n   * (with `console.error` by default).\n   *\n   * Also see {@link IO.run} for a version that returns a `Future`,\n   * which might be easier to work with, especially since a `Future`\n   * is `Promise`-like.\n   *\n   * @param cb is the callback that will be eventually called with\n   *        the final result, or error, when the evaluation completes\n   *\n   * @param ec is the scheduler that controls the triggering of\n   *        asynchronous boundaries (e.g. `setTimeout`)\n   *\n   * @return a cancelable action that can be triggered to cancel\n   *         the running computation, assuming that the implementation\n   *         of the source `IO` can be cancelled\n   */\n  runOnComplete(\n    cb: (result: Try<A>) => void,\n    ec: Scheduler = Scheduler.global.get()): ICancelable {\n\n    const ref = ioGenericRunLoop(this, ec, null, cb, null, null, null)\n    return ref || Cancelable.empty()\n  }\n\n  /**\n   * Handle errors by lifting results into `Either` values.\n   *\n   * If there's an error, then a `Left` value will be signaled. If\n   * there is no error, then a `Right` value will be signaled instead.\n   *\n   * The returned type is an\n   * [Either](https://funfix.org/api/core/classes/either.html) value,\n   * which is what's called a \"logical disjunction\" or a \"tagged union\n   * type\", representing a choice between two values, in this case\n   * errors on the \"Left\" and successful results on the \"Right\".\n   *\n   * ```typescript\n   * // Describing an IO that can fail on execution:\n   * const io: IO<number> = IO.of(() => {\n   *   const n = Math.random() * 1000\n   *   const m = n & n // to integer\n   *   if (m % 2) throw new Error(\"No odds please!\")\n   *   return m\n   * })\n   *\n   * // By using attempt() we can observe and use errors\n   * // in `map` and `flatMap` transformations:\n   * io.attempt().map(either =>\n   *   either.fold(\n   *     err => \"odd\",\n   *     val => \"even\"\n   *   ))\n   * ```\n   *\n   * For other error handling capabilities, see {@link IO.recoverWith}\n   * and {@link IO.transformWith}.\n   */\n  attempt(): IO<Either<Throwable, A>> {\n    return this.transform(\n      _ => Either.left<Throwable, A>(_),\n      Either.right)\n  }\n\n  /**\n   * Introduces an asynchronous boundary at the current stage in the\n   * asynchronous processing pipeline (after the source has been\n   * evaluated).\n   *\n   * Consider the following example:\n   *\n   * ```typescript\n   * const readPath: () => \"path/to/file\"\n   *\n   * const io = IO.of(readPath)\n   *   .asyncBoundary()\n   *   .map(fs.readFileSync)\n   * ```\n   *\n   * Between reading the path and then reading the file from that\n   * path, we schedule an async boundary (it usually happens with\n   * JavaScript's `setTimeout` under the hood).\n   *\n   * This is equivalent with:\n   *\n   * ```typescript\n   * self.flatMap(a => IO.shift(ec).map(_ => a))\n   *\n   * // ... or ...\n   *\n   * self.forEffect(IO.shift(ec))\n   * ```\n   *\n   * Also see {@link IO.shift} and {@link IO.fork}.\n   *\n   * @param ec is an optional `Scheduler` implementation that can\n   *        be used for scheduling the async boundary, however if\n   *        not specified, the `IO`'s default scheduler (the one\n   *        passed to `run()`) gets used\n   */\n  asyncBoundary(ec?: Scheduler): IO<A> {\n    return this.flatMap(a => IO.shift(ec).map(_ => a))\n  }\n\n  /**\n   * Alias for {@link IO.flatMap .flatMap}.\n   */\n  chain<B>(f: (a: A) => IO<B>): IO<B> {\n    return this.flatMap(f)\n  }\n\n  /**\n   * Delays the evaluation of this `IO` by the specified duration.\n   *\n   * ```typescript\n   * const fa = IO.of(() => \"Hello\")\n   *\n   * // Delays the evaluation by 1 second\n   * fa.delayExecution(1000)\n   * ```\n   *\n   * @param delay is the duration to wait before signaling the\n   *        final result\n   */\n  delayExecution(delay: number | Duration): IO<A> {\n    return IO.delayedTick(delay).flatMap(_ => this)\n  }\n\n  /**\n   * Delays signaling the result of this `IO` on evaluation by the\n   * specified duration.\n   *\n   * It works for successful results:\n   *\n   * ```typescript\n   * const fa = IO.of(() => \"Alex\")\n   *\n   * // Delays the signaling by 1 second\n   * fa.delayResult(1000)\n   * ```\n   *\n   * And for failures as well:\n   *\n   * ```typescript\n   * Future.raise(new TimeoutError()).delayResult(1000)\n   * ```\n   *\n   * @param delay is the duration to wait before signaling the\n   *        final result\n   */\n  delayResult(delay: number | Duration): IO<A> {\n    return this.transformWith(\n      err => IO.delayedTick(delay).flatMap(_ => IO.raise(err)),\n      a => IO.delayedTick(delay).map(_ => a)\n    )\n  }\n\n  /**\n   * Returns a new `IO` in which `f` is scheduled to be run on\n   * completion. This would typically be used to release any\n   * resources acquired by this `IO`.\n   *\n   * The returned `IO` completes when both the source and the task\n   * returned by `f` complete.\n   *\n   * NOTE: The given function is only called when the task is\n   * complete.  However the function does not get called if the task\n   * gets canceled. Cancellation is a process that's concurrent with\n   * the execution of a task and hence needs special handling.\n   *\n   * See {@link IO.doOnCancel} for specifying a callback to call on\n   * canceling a task.\n   */\n  doOnFinish(f: (e: Option<Throwable>) => IO<void>): IO<A> {\n    return this.transformWith(\n      e => f(Some(e)).flatMap(_ => IO.raise(e)),\n      a => f(None).map(_ => a)\n    )\n  }\n\n  /**\n   * Returns a new `IO` that will mirror the source, but that will\n   * execute the given `callback` if the task gets canceled before\n   * completion.\n   *\n   * This only works for premature cancellation. See\n   * {@link IO.doOnFinish} for triggering callbacks when the\n   * source finishes.\n   *\n   * @param callback is the `IO` value to execute if the task gets\n   *        canceled prematurely\n   */\n  doOnCancel(callback: IO<void>): IO<A> {\n    return IO.asyncUnsafe<A>((ctx, cb) => {\n      const ec = ctx.scheduler\n      ec.trampoline(() => {\n        const conn = ctx.connection\n        conn.push(Cancelable.of(() => callback.run(ec)))\n        IO.unsafeStart(this, ctx, ioSafeCallback(ec, conn, cb))\n      })\n    })\n  }\n\n  /**\n   * Ensures that an asynchronous boundary happens before the\n   * execution, managed by the provided scheduler.\n   *\n   * Alias for {@link IO.fork}.\n   *\n   * Calling this is equivalent with:\n   *\n   * ```typescript\n   * IO.shift(ec).flatMap(_ => self)\n   *\n   * // ... or ...\n   *\n   * IO.shift(ec).followedBy(self)\n   * ```\n   *\n   * See {@link IO.fork}, {@link IO.asyncBoundary} and {@link IO.shift}.\n   */\n  executeForked(ec?: Scheduler): IO<A> {\n    return IO.fork(this, ec)\n  }\n\n  /**\n   * Override the `ExecutionModel` of the default scheduler.\n   *\n   * ```typescript\n   * import { ExecutionModel } from \"funfix\"\n   *\n   * io.executeWithModel(ExecutionModel.alwaysAsync())\n   * ```\n   */\n  executeWithModel(em: ExecutionModel): IO<A> {\n    return IO.asyncUnsafe<A>((ctx, cb) => {\n      const ec = ctx.scheduler.withExecutionModel(em)\n      const ctx2 = new IOContext(ec, ctx.connection, ctx.options)\n      ec.trampoline(() => IO.unsafeStart(this, ctx2, cb))\n    })\n  }\n\n  /**\n   * Returns a new `IO` that upon evaluation will execute with the\n   * given set of {@link IOOptions}, allowing for tuning the run-loop.\n   *\n   * This allows for example making run-loops \"auto-cancelable\",\n   * an option that's off by default due to safety concerns:\n   *\n   * ```typescript\n   * io.executeWithOptions({\n   *   autoCancelableRunLoops: true\n   * })\n   * ```\n   */\n  executeWithOptions(set: IOOptions): IO<A> {\n    return IO.asyncUnsafe<A>((ctx, cb) => {\n      const ec = ctx.scheduler\n      const ctx2 = new IOContext(ec, ctx.connection, set)\n      ec.trampoline(() => IO.unsafeStart(this, ctx2, cb))\n    })\n  }\n\n  /**\n   * Creates a new `IO` by applying a function to the successful\n   * result of the source, and returns a new instance equivalent to\n   * the result of the function.\n   *\n   * ```typescript\n   * const rndInt = IO.of(() => {\n   *   const nr = Math.random() * 1000000\n   *   return nr & nr\n   * })\n   *\n   * const evenInt = () =>\n   *   rndInt.flatMap(int => {\n   *     if (i % 2 == 0)\n   *       return IO.now(i)\n   *     else // Retry until we have an even number!\n   *       return evenInt()\n   *   })\n   * ```\n   */\n  flatMap<B>(f: (a: A) => IO<B>): IO<B> {\n    return new IOFlatMap(this, f)\n  }\n\n  /**\n   * Sequentially compose two `IO` actions, discarding any value\n   * produced by the first.\n   *\n   * So this:\n   *\n   * ```typescript\n   * ioA.followedBy(ioB)\n   * ```\n   *\n   * Is equivalent with this:\n   *\n   * ```typescript\n   * ioA.flatMap(_ => fb)\n   * ```\n   */\n  followedBy<B>(fb: IO<B>): IO<B> {\n    return this.flatMap(_ => fb)\n  }\n\n  /**\n   * Returns a new `IO` that upon evaluation will execute the given\n   * function for the generated element, transforming the source into\n   * an `IO<void>`.\n   */\n  forEach(cb: (a: A) => void): IO<void> {\n    return this.map(cb)\n  }\n\n  /**\n   * Sequentially compose two actions, discarding any value\n   * produced by the second.\n   *\n   * So this:\n   *\n   * ```typescript\n   * ioA.forEffect(ioB)\n   * ```\n   *\n   * Is equivalent with this:\n   *\n   * ```typescript\n   * ioA.flatMap(a => ioB.map(_ => a))\n   * ```\n   */\n  forEffect<B>(fb: IO<B>): IO<A> {\n    return this.flatMap(a => fb.map(_ => a))\n  }\n\n  /**\n   * Returns a new `IO` that applies the mapping function to the\n   * successful result emitted by the source.\n   *\n   * ```typescript\n   * IO.now(111).map(_ => _ * 2).get() // 222\n   * ```\n   *\n   * Note there's a correspondence between `flatMap` and `map`:\n   *\n   * ```typescript\n   * fa.map(f) <-> fa.flatMap(x => IO.pure(f(x)))\n   * ```\n   */\n  map<B>(f: (a: A) => B): IO<B> {\n    return new IOFlatMap(this, (a: A) => IO.now(f(a)))\n  }\n\n  /**\n   * Memoizes (caches) the result of the source `IO` and reuses it on\n   * subsequent invocations of `run`.\n   *\n   * The resulting task will be idempotent, meaning that\n   * evaluating the resulting task multiple times will have the\n   * same effect as evaluating it once.\n   *\n   * @see {@link IO.memoizeOnSuccess} for a version that only caches\n   *     successful results.\n   */\n  memoize(): IO<A> {\n    switch (this._funADType) {\n      case \"pure\":\n        return this\n      case \"always\":\n        const always = (this as any) as IOAlways<A>\n        return new IOOnce(always.thunk, false)\n      case \"memoize\":\n        const mem = (this as any) as IOMemoize<A>\n        if (!mem.onlySuccess) return mem\n        return new IOMemoize(this, false)\n      default: // flatMap | async\n        return new IOMemoize(this, false)\n    }\n  }\n\n  /**\n   * Memoizes (caches) the successful result of the source task\n   * and reuses it on subsequent invocations of `run`.\n   * Thrown exceptions are not cached.\n   *\n   * The resulting task will be idempotent, but only if the\n   * result is successful.\n   *\n   * @see {@link IO.memoize} for a version that caches both successful\n   *     results and failures\n   */\n  memoizeOnSuccess(): IO<A> {\n    switch (this._funADType) {\n      case \"pure\":\n      case \"once\":\n      case \"memoize\":\n        return this\n      case \"always\":\n        const always = (this as any) as IOAlways<A>\n        return new IOOnce(always.thunk, true)\n      default: // flatMap | async\n        return new IOMemoize(this, true)\n    }\n  }\n\n  /**\n   * Creates a new `IO` that will mirror the source on success,\n   * but on failure it will try to recover and yield a successful\n   * result by applying the given function `f` to the thrown error.\n   *\n   * This function is the equivalent of a `try/catch` statement,\n   * or the equivalent of {@link IO.map .map} for errors.\n   *\n   * ```typescript\n   * io.recover(err => {\n   *   console.error(err)\n   *   fallback\n   * })\n   * ```\n   */\n  recover<AA>(f: (e: Throwable) => AA): IO<A | AA> {\n    return this.recoverWith(a => IO.now(f(a)))\n  }\n\n  /**\n   * Creates a new `IO` that will mirror the source on success,\n   * but on failure it will try to recover and yield a successful\n   * result by applying the given function `f` to the thrown error.\n   *\n   * This function is the equivalent of a `try/catch` statement,\n   * or the equivalent of {@link IO.flatMap .flatMap} for errors.\n   *\n   * Note that because of `IO`'s laziness, this can describe retry\n   * loop:\n   *\n   * ```typescript\n   * function retryOnFailure<A>(times: number, io: IO<A>): IO<A> {\n   *   return source.recoverWith(err => {\n   *     // No more retries left? Re-throw error:\n   *     if (times <= 0) return IO.raise(err)\n   *     // Recursive call, yes we can!\n   *     return retryOnFailure(times - 1, io)\n   *       // Adding 500 ms delay for good measure\n   *       .delayExecution(500)\n   *   })\n   * }\n   * ```\n   */\n  recoverWith<AA>(f: (e: Throwable) => IO<AA>): IO<A | AA> {\n    return this.transformWith(f, IO.now as any)\n  }\n\n  /**\n   * Returns an `IO` that mirrors the source in case the result of\n   * the source is signaled within the required `after` duration\n   * on evaluation, otherwise it fails with a `TimeoutError`,\n   * cancelling the source.\n   *\n   * ```typescript\n   * const fa = IO.of(() => 1).delayResult(10000)\n   *\n   * // Will fail with a TimeoutError on run()\n   * fa.timeout(1000)\n   * ```\n   *\n   * @param after is the duration to wait until it triggers\n   *        the timeout error\n   */\n  timeout(after: number | Duration): IO<A> {\n    const fb = IO.raise(new TimeoutError(Duration.of(after).toString()))\n    return this.timeoutTo(after, fb)\n  }\n\n  /**\n   * Returns an `IO` value that mirrors the source in case the result\n   * of the source is signaled within the required `after` duration\n   * when evaluated (with `run()`), otherwise it triggers the\n   * execution of the given `fallback` after the duration has passed,\n   * cancelling the source.\n   *\n   * This is literally the implementation of {@link IO.timeout}:\n   *\n   * ```typescript\n   * const fa = IO.of(() => 1).delayResult(10000)\n   *\n   * fa.timeoutTo(1000, IO.raise(new TimeoutError()))\n   * ```\n   *\n   * @param after is the duration to wait until it triggers the `fallback`\n   * @param fallback is a fallback `IO` to timeout to\n   */\n  timeoutTo<AA>(after: number | Duration, fallback: IO<AA>): IO<A | AA> {\n    const other = IO.delayedTick(after).flatMap(_ => fallback)\n    const lst: IO<A | AA>[] = [this, other]\n    return IO.firstCompletedOf(lst)\n  }\n\n  /**\n   * Creates a new `IO` by applying the 'success' function to the\n   * successful result of the source, or the 'error' function to the\n   * potential errors that might happen.\n   *\n   * This function is similar with {@link IO.map .map}, except that\n   * it can also transform errors and not just successful results.\n   *\n   * @param success is a function for transforming a successful result\n   * @param failure is a function for transforming failures\n   */\n  transform<R>(failure: (e: Throwable) => R, success: (a: A) => R): IO<R> {\n    return this.transformWith(\n      e => IO.now(failure(e)),\n      a => IO.now(success(a))\n    )\n  }\n\n  /**\n   * Creates a new `IO` by applying the 'success' function to the\n   * successful result of the source, or the 'error' function to the\n   * potential errors that might happen.\n   *\n   * This function is similar with {@link IO.flatMap .flatMap},\n   * except that it can also transform errors and not just successful\n   * results.\n   *\n   * @param success is a function for transforming a successful result\n   * @param failure is a function for transforming failures\n   */\n  transformWith<R>(failure: (e: Throwable) => IO<R>, success: (a: A) => IO<R>): IO<R> {\n    return new IOFlatMap(this, success, failure)\n  }\n\n  /**\n   * Identifies the `IO` reference type, useful for debugging and\n   * for pattern matching in the implementation.\n   *\n   * @hidden\n   */\n  readonly _funADType: \"pure\" | \"always\" | \"once\" | \"flatMap\" | \"async\" | \"memoize\"\n\n  // Implements HK<F, A>\n  /** @hidden */ readonly _funKindF: IO<any>\n  /** @hidden */ readonly _funKindA: A\n\n  // Implements Constructor<T>\n  /** @hidden */ static readonly _funErasure: IO<any>\n\n  /**\n   * Promote a `thunk` function to an `IO`, catching exceptions in\n   * the process.\n   *\n   * Note that since `IO` is not memoized by global, this will\n   * recompute the value each time the `IO` is executed.\n   *\n   * ```typescript\n   * const io = IO.always(() => { console.log(\"Hello!\") })\n   *\n   * io.run()\n   * //=> Hello!\n   * io.run()\n   * //=> Hello!\n   * io.run()\n   * //=> Hello!\n   * ```\n   */\n  static always<A>(thunk: () => A): IO<A> {\n    return new IOAlways(thunk)\n  }\n\n  /**\n   * Create a `IO` from an asynchronous computation, which takes\n   * the form of a function with which we can register a callback.\n   *\n   * This can be used to translate from a callback-based API to a\n   * straightforward monadic version.\n   */\n  static async<A>(register: (ec: Scheduler, cb: (a: Try<A>) => void) => ICancelable | void): IO<A> {\n    return IO.asyncUnsafe<A>((ctx, cb) => {\n      const ec = ctx.scheduler\n      const conn = ctx.connection\n\n      // Forcing a light asynchronous boundary, otherwise\n      // stack overflows are possible\n      ec.trampoline(() => {\n        // Wrapping the callback in a safe implementation that\n        // provides idempotency guarantees and that pops from\n        // the given `StackedCancelable` at the right time\n        const safe = ioSafeCallback(ec, conn, cb)\n        try {\n          const ref = register(ec, safe)\n          // This `push` can be executed after `register`, even the\n          // `safe` callback gets executed immediately, because of\n          // the light async boundary in `ioSafeCallback`\n          conn.push(ref || Cancelable.empty())\n        } catch (e) {\n          safe(Failure(e))\n        }\n      })\n    })\n  }\n\n  /**\n   * Constructs a lazy [[IO]] instance whose result will be computed\n   * asynchronously.\n   *\n   * **WARNING:** Unsafe to use directly, only use if you know\n   * what you're doing. For building `IO` instances safely\n   * see {@link IO.async}.\n   *\n   * Rules of usage:\n   *\n   *  - the received `StackedCancelable` can be used to store\n   *    cancelable references that will be executed upon cancel;\n   *    every `push` must happen at the beginning, before any\n   *    execution happens and `pop` must happen afterwards\n   *    when the processing is finished, before signaling the\n   *    result\n   *  - before execution, an asynchronous boundary is recommended,\n   *    to avoid stack overflow errors, but can happen using the\n   *    scheduler's facilities for trampolined execution\n   *  - on signaling the result (`Success` or `Failure`),\n   *    another async boundary is necessary, but can also\n   *    happen with the scheduler's facilities for trampolined\n   *    execution (e.g. `Scheduler.trampoline`)\n   *\n   * **WARNING:** note that not only is this builder unsafe, but also\n   * unstable, as the {@link IORegister} callback type is exposing\n   * volatile internal implementation details. This builder is meant\n   * to create optimized asynchronous tasks, but for normal usage\n   * prefer {@link IO.async}.\n   */\n  static asyncUnsafe<A>(register: IORegister<A>): IO<A> {\n    return new IOAsync(register)\n  }\n\n  /**\n   * Promote a `thunk` function generating `IO` results to an `IO`\n   * of the same type.\n   *\n   * Alias for {@link IO.suspend}.\n   */\n  static defer<A>(thunk: () => IO<A>): IO<A> {\n    return IO.unit().flatMap(_ => thunk())\n  }\n\n  /**\n   * Defers the creation of an `IO` by using the provided function,\n   * which has the ability to inject a needed `Scheduler`.\n   *\n   * Example:\n   *\n   * ```typescript\n   * function measureLatency<A>(source: IO<A>): IO<[A, Long]> {\n   *   return IO.deferAction<[A, Long]>(s => {\n   *     // We have our Scheduler, which can inject time, we\n   *     // can use it for side-effectful operations\n   *     const start = s.currentTimeMillis()\n   *\n   *     return source.map(a => {\n   *       const finish = s.currentTimeMillis()\n   *       return [a, finish - start]\n   *     })\n   *   })\n   * }\n   * ```\n   *\n   * @param f is the function that's going to be called when the\n   *        resulting `IO` gets evaluated\n   */\n  static deferAction<A>(f: (ec: Scheduler) => IO<A>): IO<A> {\n    return IO.asyncUnsafe<A>((ctx, cb) => {\n      const ec = ctx.scheduler\n      let ioa: IO<A>\n      try { ioa = f(ec) } catch (e) { ioa = IO.raise(e) }\n      ec.trampoline(() => IO.unsafeStart(ioa, ctx, cb))\n    })\n  }\n\n  /**\n   * Given a `thunk` that produces `Future` values, suspends it\n   * in the `IO` context, evaluating it on demand whenever the\n   * resulting `IO` gets evaluated.\n   *\n   * See {@link IO.fromFuture} for the strict version.\n   */\n  static deferFuture<A>(thunk: () => Future<A>): IO<A> {\n    return IO.suspend(() => IO.fromFuture(thunk()))\n  }\n\n  /**\n   * Wraps calls that generate `Future` results into `IO`, provided\n   * a callback with an injected `Scheduler`.\n   *\n   * This builder helps with wrapping `Future`-enabled APIs that need\n   * a `Scheduler` to work.\n   *\n   * @param f is the function that's going to be executed when the task\n   *        gets evaluated, generating the wrapped `Future`\n   */\n  static deferFutureAction<A>(f: (ec: Scheduler) => Future<A>): IO<A> {\n    return IO.deferAction(ec => IO.fromFuture(f(ec)))\n  }\n\n  /**\n   * Returns an `IO` that on evaluation will complete after the\n   * given `delay`.\n   *\n   * This can be used to do delayed execution. For example:\n   *\n   * ```typescript\n   * IO.delayedTick(1000).flatMap(_ =>\n   *   IO.of(() => console.info(\"Hello!\"))\n   * )\n   * ```\n   *\n   * @param delay is the duration to wait before signaling the tick\n   */\n  static delayedTick<A>(delay: number | Duration): IO<void> {\n    return IO.asyncUnsafe<void>((ctx, cb) => {\n      const conn = ctx.connection\n      const task = ctx.scheduler.scheduleOnce(delay, () => {\n        conn.pop()\n        cb(Try.unit())\n      })\n      conn.push(task)\n    })\n  }\n\n  /**\n   * Creates a race condition between multiple `IO` values, on\n   * evaluation returning the result of the first one that completes,\n   * cancelling the rest.\n   *\n   * ```typescript\n   * const failure = IO.raise(new TimeoutError()).delayResult(2000)\n   *\n   * // Will yield 1\n   * const fa1 = IO.of(() => 1).delayResult(1000)\n   * IO.firstCompletedOf([fa1, failure])\n   *\n   * // Will yield a TimeoutError\n   * const fa2 = IO.of(() => 1).delayResult(10000)\n   * IO.firstCompletedOf([fa2, failure])\n   * ```\n   *\n   * @param list is the list of `IO` values for which the\n   *        race is started\n   *\n   * @return a new `IO` that will evaluate to the result of the first\n   *         in the list to complete, the rest being cancelled\n   */\n  static firstCompletedOf<A>(list: IO<A>[] | Iterable<IO<A>>): IO<A> {\n    return ioListToFutureProcess(list, Future.firstCompletedOf)\n  }\n\n  /**\n   * Converts any strict `Future` value into an {@link IO}.\n   *\n   * Note that this builder does not suspend any side effects, since\n   * the given parameter is strict (and not a function) and because\n   * `Future` has strict behavior.\n   *\n   * See {@link IO.deferFuture} for an alternative that evaluates\n   * lazy thunks that produce future results.\n   */\n  static fromFuture<A>(fa: Future<A>): IO<A> {\n    if (!fa.value().isEmpty())\n      return IO.fromTry<A>(fa.value().get() as any)\n\n    return IO.asyncUnsafe<A>((ctx, cb) => {\n      ctx.connection.push(fa)\n      fa.onComplete(result => {\n        ctx.connection.pop()\n        cb(result as any)\n      })\n    })\n  }\n\n  /**\n   * Returns a `IO` reference that will signal the result of the\n   * given `Try<A>` reference upon evaluation.\n   */\n  static fromTry<A>(a: Try<A>): IO<A> { return new IOPure(a) }\n\n  /**\n   * Mirrors the given source `IO`, but before execution trigger\n   * an asynchronous boundary (usually by means of `setTimeout` on\n   * top of JavaScript, depending on the provided `Scheduler`\n   * implementation).\n   *\n   * If a `Scheduler` is not explicitly provided, the implementation\n   * ends up using the one provided in {@link IO.run}.\n   *\n   * Note that {@link IO.executeForked} is the method version of this\n   * function (e.g. `io.executeForked() == IO.fork(this)`).\n   *\n   * ```typescript\n   * IO.of(() => fs.readFileSync(path))\n   *   .executeForked()\n   * ```\n   *\n   * Also see {@link IO.shift} and {@link IO.asyncBoundary}.\n   *\n   * @param fa is the task that will get executed asynchronously\n   *\n   * @param ec is the `Scheduler` used for triggering the async\n   *        boundary, or if not provided it will default to the\n   *        scheduler passed on evaluation in {@link IO.run}\n   */\n  static fork<A>(fa: IO<A>, ec?: Scheduler): IO<A> {\n    return IO.shift(ec).flatMap(_ => fa)\n  }\n\n  /**\n   * Maps 2 `IO` values by the mapping function, returning a new\n   * `IO` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link IO.sequence} operation and as such\n   * on cancellation or failure all pending tasks get cancelled.\n   *\n   * ```typescript\n   * const fa1 = IO.of(() => 1)\n   * const fa2 = IO.of(() => 2)\n   *\n   *\n   * // Yields Success(3)\n   * IO.map2(fa1, fa2, (a, b) => a + b)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * IO.map2(fa1, IO.raise(\"error\"),\n   *   (a, b) => a + b\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map2`.\n   */\n  static map2<A1, A2, R>(\n    fa1: IO<A1>, fa2: IO<A2>,\n    f: (a1: A1, a2: A2) => R): IO<R> {\n\n    const fl: IO<any[]> = IO.sequence([fa1, fa2] as any[])\n    return fl.map(lst => f(lst[0], lst[1]))\n  }\n\n  /**\n   * Maps 3 `IO` values by the mapping function, returning a new\n   * `IO` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link IO.sequence} operation and as such\n   * on cancellation or failure all pending tasks get cancelled.\n   *\n   * ```typescript\n   * const fa1 = IO.of(() => 1)\n   * const fa2 = IO.of(() => 2)\n   * const fa3 = IO.of(() => 3)\n   *\n   *\n   * // Yields Success(6)\n   * IO.map3(fa1, fa2, fa3, (a, b, c) => a + b + c)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * IO.map3(\n   *   fa1, fa2, IO.raise(\"error\"),\n   *   (a, b, c) => a + b + c\n   * )\n   * ```\n   */\n  static map3<A1, A2, A3, R>(\n    fa1: IO<A1>, fa2: IO<A2>, fa3: IO<A3>,\n    f: (a1: A1, a2: A2, a3: A3) => R): IO<R> {\n\n    const fl: IO<any[]> = IO.sequence([fa1, fa2, fa3] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2]))\n  }\n\n  /**\n   * Maps 4 `IO` values by the mapping function, returning a new\n   * `IO` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link IO.sequence} operation and as such\n   * on cancellation or failure all pending tasks get cancelled.\n   *\n   * ```typescript\n   * const fa1 = IO.of(() => 1)\n   * const fa2 = IO.of(() => 2)\n   * const fa3 = IO.of(() => 3)\n   * const fa4 = IO.of(() => 4)\n   *\n   * // Yields Success(10)\n   * IO.map4(fa1, fa2, fa3, fa4, (a, b, c, d) => a + b + c + d)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * IO.map4(\n   *   fa1, fa2, fa3, IO.raise(\"error\"),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   * ```\n   */\n  static map4<A1, A2, A3, A4, R>(\n    fa1: IO<A1>, fa2: IO<A2>, fa3: IO<A3>, fa4: IO<A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R): IO<R> {\n\n    const fl: IO<any[]> = IO.sequence([fa1, fa2, fa3, fa4] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3]))\n  }\n\n  /**\n   * Maps 5 `IO` values by the mapping function, returning a new\n   * `IO` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link IO.sequence} operation and as such\n   * on cancellation or failure all pending tasks get cancelled.\n   *\n   * ```typescript\n   * const fa1 = IO.of(() => 1)\n   * const fa2 = IO.of(() => 2)\n   * const fa3 = IO.of(() => 3)\n   * const fa4 = IO.of(() => 4)\n   * const fa5 = IO.of(() => 5)\n   *\n   * // Yields Success(15)\n   * IO.map5(fa1, fa2, fa3, fa4, fa5,\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * IO.map5(\n   *   fa1, fa2, fa3, fa4, IO.raise(\"error\"),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   * ```\n   */\n  static map5<A1, A2, A3, A4, A5, R>(\n    fa1: IO<A1>, fa2: IO<A2>, fa3: IO<A3>, fa4: IO<A4>, fa5: IO<A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R): IO<R> {\n\n    const fl: IO<any[]> = IO.sequence([fa1, fa2, fa3, fa4, fa5] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3], lst[4]))\n  }\n\n  /**\n   * Maps 6 `IO` values by the mapping function, returning a new\n   * `IO` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link IO.sequence} operation and as such\n   * on cancellation or failure all pending tasks get cancelled.\n   *\n   * ```typescript\n   * const fa1 = IO.of(() => 1)\n   * const fa2 = IO.of(() => 2)\n   * const fa3 = IO.of(() => 3)\n   * const fa4 = IO.of(() => 4)\n   * const fa5 = IO.of(() => 5)\n   * const fa6 = IO.of(() => 6)\n   *\n   * // Yields Success(21)\n   * IO.map6(\n   *   fa1, fa2, fa3, fa4, fa5, fa6,\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * IO.map6(\n   *   fa1, fa2, fa3, fa4, fa5, IO.raise(\"error\"),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   * ```\n   */\n  static map6<A1, A2, A3, A4, A5, A6, R>(\n    fa1: IO<A1>, fa2: IO<A2>, fa3: IO<A3>, fa4: IO<A4>, fa5: IO<A5>, fa6: IO<A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R): IO<R> {\n\n    const fl: IO<any[]> = IO.sequence([fa1, fa2, fa3, fa4, fa5, fa6] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3], lst[4], lst[5]))\n  }\n\n  /**\n   * Returns an `IO` that on execution is always successful,\n   * emitting the given strict value.\n   */\n  static now<A>(value: A): IO<A> { return new IOPure(Success(value)) }\n\n  /**\n   * Alias for {@link IO.always}.\n   */\n  static of<A>(thunk: () => A): IO<A> {\n    return IO.always(thunk)\n  }\n\n  /**\n   * Promote a `thunk` function to a `Coeval` that is memoized on the\n   * first evaluation, the result being then available on subsequent\n   * evaluations.\n   *\n   * Note this is equivalent with:\n   *\n   * ```typescript\n   * IO.always(thunk).memoize()\n   * ```\n   */\n  static once<A>(thunk: () => A): IO<A> {\n    return new IOOnce(thunk, false)\n  }\n\n  /**\n   * Maps 2 `IO` values evaluated nondeterministically, returning a new\n   * `IO` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link IO.gather} operation. As such\n   * the `IO` operations are potentially executed in parallel\n   * (if the operations are asynchronous) and on cancellation or\n   * failure all pending tasks get cancelled.\n   *\n   * ```typescript\n   * const fa1 = IO.of(() => 1)\n   * const fa2 = IO.of(() => 2)\n   *\n   *\n   * // Yields Success(3)\n   * IO.parMap2(fa1, fa2, (a, b) => a + b)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * IO.parMap2(fa1, IO.raise(\"error\"),\n   *   (a, b) => a + b\n   * )\n   * ```\n   */\n  static parMap2<A1, A2, R>(\n    fa1: IO<A1>, fa2: IO<A2>,\n    f: (a1: A1, a2: A2) => R): IO<R> {\n\n    const fl: IO<any[]> = IO.gather([fa1, fa2] as any[])\n    return fl.map(lst => f(lst[0], lst[1]))\n  }\n\n  /**\n   * Maps 3 `IO` values evaluated nondeterministically, returning a new\n   * `IO` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link IO.gather} operation. As such\n   * the `IO` operations are potentially executed in parallel\n   * (if the operations are asynchronous) and on cancellation or\n   * failure all pending tasks get cancelled.\n   *\n   * ```typescript\n   * const fa1 = IO.of(() => 1)\n   * const fa2 = IO.of(() => 2)\n   * const fa3 = IO.of(() => 3)\n   *\n   *\n   * // Yields Success(6)\n   * IO.parMap3(fa1, fa2, fa3, (a, b, c) => a + b + c)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * IO.parMap3(\n   *   fa1, fa2, IO.raise(\"error\"),\n   *   (a, b, c) => a + b + c\n   * )\n   * ```\n   */\n  static parMap3<A1, A2, A3, R>(\n    fa1: IO<A1>, fa2: IO<A2>, fa3: IO<A3>,\n    f: (a1: A1, a2: A2, a3: A3) => R): IO<R> {\n\n    const fl: IO<any[]> = IO.gather([fa1, fa2, fa3] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2]))\n  }\n\n  /**\n   * Maps 4 `IO` values evaluated nondeterministically, returning a new\n   * `IO` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link IO.gather} operation. As such\n   * the `IO` operations are potentially executed in parallel\n   * (if the operations are asynchronous) and on cancellation or\n   * failure all pending tasks get cancelled.\n   *\n   * ```typescript\n   * const fa1 = IO.of(() => 1)\n   * const fa2 = IO.of(() => 2)\n   * const fa3 = IO.of(() => 3)\n   * const fa4 = IO.of(() => 4)\n   *\n   * // Yields Success(10)\n   * IO.parMap4(fa1, fa2, fa3, fa4, (a, b, c, d) => a + b + c + d)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * IO.parMap4(\n   *   fa1, fa2, fa3, IO.raise(\"error\"),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   * ```\n   */\n  static parMap4<A1, A2, A3, A4, R>(\n    fa1: IO<A1>, fa2: IO<A2>, fa3: IO<A3>, fa4: IO<A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R): IO<R> {\n\n    const fl: IO<any[]> = IO.gather([fa1, fa2, fa3, fa4] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3]))\n  }\n\n  /**\n   * Maps 5 `IO` values evaluated nondeterministically, returning a new\n   * `IO` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link IO.gather} operation. As such\n   * the `IO` operations are potentially executed in parallel\n   * (if the operations are asynchronous) and on cancellation or\n   * failure all pending tasks get cancelled.\n   *\n   * ```typescript\n   * const fa1 = IO.of(() => 1)\n   * const fa2 = IO.of(() => 2)\n   * const fa3 = IO.of(() => 3)\n   * const fa4 = IO.of(() => 4)\n   * const fa5 = IO.of(() => 5)\n   *\n   * // Yields Success(15)\n   * IO.parMap5(fa1, fa2, fa3, fa4, fa5,\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * IO.parMap5(\n   *   fa1, fa2, fa3, fa4, IO.raise(\"error\"),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   * ```\n   */\n  static parMap5<A1, A2, A3, A4, A5, R>(\n    fa1: IO<A1>, fa2: IO<A2>, fa3: IO<A3>, fa4: IO<A4>, fa5: IO<A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R): IO<R> {\n\n    const fl: IO<any[]> = IO.gather([fa1, fa2, fa3, fa4, fa5] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3], lst[4]))\n  }\n\n  /**\n   * Maps 6 `IO` values evaluated nondeterministically, returning a new\n   * `IO` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link IO.gather} operation. As such\n   * the `IO` operations are potentially executed in parallel\n   * (if the operations are asynchronous) and on cancellation or\n   * failure all pending tasks get cancelled.\n   *\n   * ```typescript\n   * const fa1 = IO.of(() => 1)\n   * const fa2 = IO.of(() => 2)\n   * const fa3 = IO.of(() => 3)\n   * const fa4 = IO.of(() => 4)\n   * const fa5 = IO.of(() => 5)\n   * const fa6 = IO.of(() => 6)\n   *\n   * // Yields Success(21)\n   * IO.parMap6(\n   *   fa1, fa2, fa3, fa4, fa5, fa6,\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * IO.parMap6(\n   *   fa1, fa2, fa3, fa4, fa5, IO.raise(\"error\"),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   * ```\n   */\n  static parMap6<A1, A2, A3, A4, A5, A6, R>(\n    fa1: IO<A1>, fa2: IO<A2>, fa3: IO<A3>, fa4: IO<A4>, fa5: IO<A5>, fa6: IO<A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R): IO<R> {\n\n    const fl: IO<any[]> = IO.gather([fa1, fa2, fa3, fa4, fa5, fa6] as any[])\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3], lst[4], lst[5]))\n  }\n\n  /**\n   * Lifts a value into the `IO` context.\n   *\n   * Alias for {@link IO.now}.\n   */\n  static pure<A>(value: A): IO<A> { return IO.now(value) }\n\n  /**\n   * Returns an `IO` that on execution is always finishing in error\n   * emitting the specified exception.\n   */\n  static raise<A = never>(e: Throwable): IO<A> { return new IOPure(Failure(e)) }\n\n  /**\n   * Transforms a list of `IO` values into an `IO` of a list,\n   * ordering both results and side effects.\n   *\n   * This operation would be the equivalent of `Promise.all` or of\n   * `Future.sequence`, however because of the laziness of `IO`\n   * the given values are processed in order.\n   *\n   * Sequencing means that on evaluation the tasks won't get processed\n   * in parallel. If parallelism is desired, see {@link IO.gather}.\n   *\n   * Sample:\n   *\n   * ```typescript\n   * const io1 = IO.of(() => 1)\n   * const io2 = IO.of(() => 2)\n   * const io3 = IO.of(() => 3)\n   *\n   * // Yields [1, 2, 3]\n   * const all: IO<number[]> = IO.sequence([f1, f2, f3])\n   * ```\n   */\n  static sequence<A>(list: IO<A>[] | Iterable<IO<A>>): IO<A[]> {\n    return ioSequence(list)\n  }\n\n  /**\n   * Nondeterministically gather results from the given collection of\n   * tasks, returning a task that will signal the same type of\n   * collection of results once all tasks are finished.\n   *\n   * This function is the nondeterministic analogue of `sequence`\n   * and should behave identically to `sequence` so long as there is\n   * no interaction between the effects being gathered. However,\n   * unlike `sequence`, which decides on a total order of effects,\n   * the effects in a `gather` are unordered with respect to each\n   * other.\n   *\n   * In other words `gather` can execute `IO` tasks in parallel,\n   * whereas {@link IO.sequence} forces an execution order.\n   *\n   * Although the effects are unordered, the order of results matches\n   * the order of the input sequence.\n   *\n   * ```typescript\n   * const io1 = IO.of(() => 1)\n   * const io2 = IO.of(() => 2)\n   * const io3 = IO.of(() => 3)\n   *\n   * // Yields [1, 2, 3]\n   * const all: IO<number[]> = IO.gather([f1, f2, f3])\n   * ```\n   */\n  static gather<A>(list: IO<A>[] | Iterable<IO<A>>): IO<A[]> {\n    return ioListToFutureProcess(list, Future.sequence)\n  }\n\n  /**\n   * Shifts the bind continuation of the `IO` onto the specified\n   * scheduler, for triggering asynchronous execution.\n   *\n   * Asynchronous actions cannot be shifted, since they are scheduled\n   * rather than run. Also, no effort is made to re-shift synchronous\n   * actions which *follow* asynchronous actions within a bind chain;\n   * those actions will remain on the continuation call stack inherited\n   * from their preceding async action.  The only computations which\n   * are shifted are those which are defined as synchronous actions and\n   * are contiguous in the bind chain *following* the `shift`.\n   *\n   * For example this sample forces an asynchronous boundary\n   * (which usually means that the continuation is scheduled\n   * for asynchronous execution with `setTimeout`) before the\n   * file will be read synchronously:\n   *\n   * ```typescript\n   * IO.shift().flatMap(_ => fs.readFileSync(path))\n   * ```\n   *\n   * On the other hand in this example the asynchronous boundary\n   * is inserted *after* the file has been read:\n   *\n   * ```typescript\n   * IO.of(() => fs.readFileSync(path)).flatMap(content =>\n   *   IO.shift().map(_ => content))\n   * ```\n   *\n   * The definition of {@link IO.async} is literally:\n   *\n   * ```typescript\n   * source.flatMap(a => IO.shift(ec).map(_ => a))\n   * ```\n   *\n   * And the definition of {@link IO.fork} is:\n   *\n   * ```typescript\n   * IO.shift(ec).flatMap(_ => source)\n   * ```\n   *\n   * @param ec is the `Scheduler` used for triggering the async\n   *        boundary, or if not provided it will default to the\n   *        scheduler passed on evaluation in {@link IO.run}\n   */\n  static shift(ec?: Scheduler): IO<void> {\n    if (!ec) return ioShiftDefaultRef\n    return ioShift(ec)\n  }\n\n  /**\n   * Promote a `thunk` function generating `IO` results to an `IO`\n   * of the same type.\n   */\n  static suspend<A>(thunk: () => IO<A>): IO<A> {\n    return IO.unit().flatMap(_ => thunk())\n  }\n\n  /**\n   * Keeps calling `f` until a `Right(b)` is returned.\n   *\n   * Based on Phil Freeman's\n   * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.\n   *\n   * Described in `FlatMap.tailRecM`.\n   */\n  static tailRecM<A, B>(a: A, f: (a: A) => IO<Either<A, B>>): IO<B> {\n    try {\n      return f(a).flatMap(either => {\n        if (either.isRight()) {\n          return IO.now(either.get())\n        } else {\n          // Recursive call\n          return IO.tailRecM(either.swap().get(), f)\n        }\n      })\n    } catch (e) {\n      return IO.raise(e)\n    }\n  }\n\n  /**\n   * Shorthand for `now(undefined as void)`, always returning\n   * the same reference as optimization.\n   */\n  static unit(): IO<void> {\n    return ioUnitRef\n  }\n\n  /**\n   * Unsafe utility - starts the execution of an `IO`.\n   *\n   * This function allows for specifying a custom {@link IOContext}\n   * when evaluating the `IO` reference.\n   *\n   * DO NOT use directly, as it is UNSAFE to use, unless you know\n   * what you're doing. Prefer {@link IO.run} instead.\n   */\n  static unsafeStart<A>(source: IO<A>, context: IOContext, cb: (r: Try<A>) => void): void | ICancelable {\n    return ioGenericRunLoop(source, context.scheduler, context, cb, null, null, null)\n  }\n}\n\n/**\n * `Pure` is an internal `IO` state that wraps any strict\n * value in an `IO` reference. Returned by {@link IO.now}\n * and {@link IO.raise}.\n *\n * @private\n */\nclass IOPure<A> extends IO<A> {\n  readonly _funADType: \"pure\" = \"pure\"\n\n  /**\n   * @param value is the value that's going to be returned\n   * when `get()` is called.\n   */\n  constructor(public value: Try<A>) { super() }\n}\n\n/**\n * Reusable reference, to use in {@link IO.unit}.\n *\n * @private\n */\nconst ioUnitRef: IOPure<void> = new IOPure(Try.unit())\n\n/**\n * `Once` is an internal `IO` state that executes the given `thunk`\n * only once, upon calling `get()` and then memoize its result for\n * subsequent invocations.\n *\n * Returned by [[IO.once]].\n *\n * @private\n */\nclass IOOnce<A> extends IO<A> {\n  readonly _funADType: \"once\" = \"once\"\n\n  private _thunk: () => A\n  public cache: Try<A>\n  public onlyOnSuccess: boolean\n\n  constructor(thunk: () => A, onlyOnSuccess: boolean) {\n    super()\n    this._thunk = thunk\n    this.onlyOnSuccess = onlyOnSuccess\n  }\n\n  memoize(): IO<A> {\n    if (this.onlyOnSuccess && this._thunk)\n      return new IOOnce(this._thunk, false)\n    else\n      return this\n  }\n\n  runTry(): Try<A> {\n    if (this._thunk) {\n      const result = Try.of(this._thunk)\n      if (result.isSuccess() || !this.onlyOnSuccess) {\n        // GC purposes\n        delete this._thunk\n        delete this.onlyOnSuccess\n        this.cache = result\n      }\n      return result\n    }\n    return this.cache\n  }\n}\n\n/**\n * `Always` is an internal `IO` state that executes the given `thunk`\n * every time the call to `get()` happens. Returned by [[IO.always]].\n *\n * @private\n */\nclass IOAlways<A> extends IO<A> {\n  readonly _funADType: \"always\" = \"always\"\n\n  constructor(public thunk: () => A) { super() }\n}\n\n/**\n * `FlatMap` is an internal `IO` state that represents a\n * [[IO.flatMap .flatMap]], [[IO.map .map]], [[IO.transform .transform]]\n * or a [[IO.transformWith .transformWith]] operation, all of them\n * being expressed with this state.\n *\n * @private\n */\nclass IOFlatMap<A, B> extends IO<B> {\n  readonly _funADType: \"flatMap\" = \"flatMap\"\n\n  constructor(\n    public readonly source: IO<A>,\n    public readonly f: ((a: A) => IO<B>),\n    public readonly g?: ((e: Throwable) => IO<B>)) { super() }\n}\n\n/**\n * Type alias representing registration callbacks for tasks\n * created with `asyncUnsafe`, that are going to get executed\n * when the asynchronous task gets evaluated.\n */\nexport type IORegister<A> =\n  (context: IOContext, callback: (result: Try<A>) => void) => void\n\n/**\n * Constructs a lazy [[IO]] instance whose result will\n * be computed asynchronously.\n *\n * Unsafe to build directly, only use if you know what you're doing.\n * For building `Async` instances safely, see {@link IO.async}.\n *\n * @private\n * @hidden\n */\nclass IOAsync<A> extends IO<A> {\n  readonly _funADType: \"async\" = \"async\"\n\n  constructor(public readonly register: IORegister<A>) { super() }\n}\n\nclass IOMemoize<A> extends IO<A> {\n  readonly _funADType: \"memoize\" = \"memoize\"\n\n  public result: Try<A> | Future<A> | null\n  public source?: IO<A>\n  public readonly onlySuccess: boolean\n\n  constructor(source: IO<A>, onlySuccess: boolean) {\n    super()\n    this.source = source\n    this.result = null\n    this.onlySuccess = onlySuccess\n  }\n}\n\n/**\n * The `Context` under which {@link IO} is supposed to be executed.\n *\n * This definition is of interest only when creating\n * tasks with {@link IO.asyncUnsafe}, which exposes internals and\n * is considered unsafe to use.\n *\n * @final\n */\nexport class IOContext {\n  /**\n   * The `Scheduler` in charge of evaluating asynchronous boundaries\n   * on `run`.\n   */\n  public readonly scheduler: Scheduler\n\n  /**\n   * Is the `StackedCancelable` that accumulates cancelable\n   * actions, to be triggered if cancellation happens.\n   */\n  public readonly connection: StackedCancelable\n\n  /**\n   * Options passed to the run-loop implementation, determining\n   * its behavior. See {@link IOOptions} for the available\n   * options.\n   */\n  public readonly options: IOOptions\n\n  constructor(\n    scheduler: Scheduler,\n    connection: StackedCancelable = new StackedCancelable(),\n    options: IOOptions = { autoCancelableRunLoops: false }) {\n\n    this.scheduler = scheduler\n    this.options = options\n    this.connection = connection\n\n    // Enables auto-cancelable run-loops\n    if (options.autoCancelableRunLoops)\n      this.shouldCancel = () => connection.isCanceled()\n  }\n\n  /**\n   * Resets the stored `frameIndex`.\n   *\n   * Calling this method inside the logic of a {@link IO.asyncUnsafe}\n   * lets the run-loop know that an async boundary happened. This\n   * works in tandem with the logic for `ExecutionModel.batched(n)`,\n   * for better detection of synchronous cycles, to avoid introducing\n   * forced async boundaries where not needed.\n   */\n  markAsyncBoundary(): void {\n    this.scheduler.batchIndex = 0\n  }\n\n  /**\n   * Returns `true` in case the run-loop should be canceled,\n   * but this can only happen if `autoCancelableRunLoops` is\n   * set to `true`.\n   */\n  shouldCancel(): boolean { return false }\n}\n\n/**\n * Set of options for customizing IO's behavior.\n *\n * @param autoCancelableRunLoops should be set to `true` in\n *        case you want `flatMap` driven loops to be\n *        auto-cancelable. Defaults to `false` because of\n *        safety concerns.\n */\nexport type IOOptions = {\n  autoCancelableRunLoops: boolean\n}\n\n/** @hidden */\nfunction ioShift(ec?: Scheduler): IO<void> {\n  return IO.asyncUnsafe<void>((ctx, cb) => {\n    (ec || ctx.scheduler).executeAsync(() => cb(Try.unit()))\n  })\n}\n\n/** @hidden */\nconst ioShiftDefaultRef: IO<void> = ioShift()\n\n/** @hidden */\ntype Current = IO<any>\n/** @hidden */\ntype Bind = ((a: any) => IO<any>)\n/** @hidden */\ntype BindT = Bind | [Bind, Bind]\n/** @hidden */\ntype CallStack = Array<BindT>\n\n/** @hidden */\nfunction _ioPopNextBind(bFirst: BindT | null, bRest: CallStack | null): Bind | null {\n  let f: Bind | [Bind, Bind] | null | undefined = undefined\n  if (bFirst) f = bFirst\n  else if (bRest && bRest.length > 0) f = bRest.pop()\n  if (f) return typeof f === \"function\" ? f : f[0]\n  return null\n}\n\n/** @hidden */\nfunction _ioFindErrorHandler(bFirst: BindT | null, bRest: CallStack | null): Bind | null {\n  let cursor: any = bFirst\n  do {\n    if (cursor && typeof cursor !== \"function\") return cursor[1]\n    cursor = bRest ? bRest.pop() : null\n  } while (cursor)\n\n  return null\n}\n\n/**\n * We need to build a callback on each cycle involving an `IOAsync`\n * state. This class builds a mutable callback to reuse on each\n * cycle in order to reduce GC pressure.\n *\n * @hidden\n * @final\n */\nclass RestartCallback {\n  private canCall = false\n  private bFirst: BindT | null = null\n  private bRest: CallStack | null = null\n\n  public readonly asFunction: (result: Try<any>) => void\n\n  constructor(\n    private context: IOContext,\n    private callback: (r: Try<any>) => void) {\n\n    this.asFunction = this.signal.bind(this)\n  }\n\n  prepare(bFirst: BindT | null, bRest: CallStack | null) {\n    this.bFirst = bFirst\n    this.bRest = bRest\n    this.canCall = true\n  }\n\n  signal(result: Try<any>): void {\n    if (this.canCall) {\n      this.canCall = false\n      ioGenericRunLoop(\n        new IOPure(result),\n        this.context.scheduler,\n        this.context,\n        this.callback,\n        this,\n        this.bFirst,\n        this.bRest\n      )\n    } else if (result.isFailure()) {\n      this.context.scheduler.reportFailure(result.failed().get())\n    }\n  }\n}\n\n/** @hidden */\nfunction ioExecuteAsync(\n  register: IORegister<any>,\n  context: IOContext,\n  cb: (result: Try<any>) => void,\n  rcb: RestartCallback | null,\n  bFirst: BindT | null,\n  bRest: CallStack | null,\n  frameIndex: number) {\n\n  if (!context.shouldCancel()) {\n    context.scheduler.batchIndex = frameIndex\n\n    const restart = rcb || new RestartCallback(context, cb)\n    restart.prepare(bFirst, bRest)\n    register(context, restart.asFunction)\n  }\n}\n\n/** @hidden */\nfunction ioRestartAsync(\n  start: IO<any>,\n  context: IOContext,\n  cb: (result: Try<any>) => void,\n  rcb: RestartCallback | null,\n  bFirstInit: BindT | null,\n  bRestInit: CallStack | null): void {\n\n  if (!context.shouldCancel())\n    context.scheduler.executeAsync(() => {\n      ioGenericRunLoop(start, context.scheduler, context, cb, rcb, bFirstInit, bRestInit)\n    })\n}\n\n/** @hidden */\nfunction ioGenericRunLoop(\n  start: IO<any>,\n  scheduler: Scheduler,\n  context: IOContext | null,\n  cb: (result: Try<any>) => void,\n  rcb: RestartCallback | null,\n  bFirstInit: BindT | null,\n  bRestInit: CallStack | null): ICancelable | void {\n\n  let current: Current | Try<any> = start\n  let bFirst: BindT | null = bFirstInit\n  let bRest: CallStack | null = bRestInit\n\n  const modulus = scheduler.executionModel.recommendedBatchSize - 1\n  let frameIndex = scheduler.batchIndex\n\n  while (true) {\n    if (current instanceof Try) {\n      if (current.isSuccess()) {\n        const bind = _ioPopNextBind(bFirst, bRest)\n        if (!bind) {\n          scheduler.batchIndex = frameIndex\n          return cb(current)\n        }\n\n        try {\n          current = bind(current.get())\n        } catch (e) {\n          current = Try.failure(e)\n        }\n      } else {\n        const bind = _ioFindErrorHandler(bFirst, bRest)\n        if (!bind) {\n          scheduler.batchIndex = frameIndex\n          return cb(current)\n        }\n\n        try {\n          current = bind(current.failed().get())\n        } catch (e) {\n          current = Try.failure(e)\n        }\n      }\n\n      bFirst = null\n      const nextIndex = (frameIndex + 1) & modulus\n      // Should we force an asynchronous boundary?\n      if (nextIndex) {\n        frameIndex = nextIndex\n      } else {\n        const ctx = context || new IOContext(scheduler)\n        /* istanbul ignore next */\n        const boxed = current instanceof Try ? new IOPure(current) : current\n        ioRestartAsync(boxed, ctx, cb, rcb, bFirst, bRest)\n        return ctx.connection\n      }\n    }\n    else switch (current._funADType) {\n      case \"pure\":\n        current = (current as IOPure<any>).value\n        break\n\n      case \"always\":\n        current = Try.of((current as IOAlways<any>).thunk)\n        break\n\n      case \"once\":\n        current = (current as IOOnce<any>).runTry()\n        break\n\n      case \"flatMap\":\n        const flatM: IOFlatMap<any, any> = current as any\n        if (bFirst) {\n          if (!bRest) bRest = []\n          bRest.push(bFirst)\n        }\n\n        bFirst = !flatM.g ? flatM.f : [flatM.f, flatM.g]\n        current = flatM.source\n        break\n\n      case \"async\":\n        const async: IOAsync<any> = current as any\n        const ctx = context || new IOContext(scheduler)\n        ioExecuteAsync(async.register, ctx, cb, rcb, bFirst, bRest, frameIndex)\n        return ctx.connection\n\n      case \"memoize\":\n        const mem: IOMemoize<any> = current as any\n        return ioStartMemoize(mem, scheduler, context, cb, bFirst, bRest, frameIndex)\n    }\n  }\n}\n\n/** @hidden */\nfunction ioToFutureGoAsync(\n  start: IO<any>,\n  scheduler: Scheduler,\n  bFirst: BindT | null,\n  bRest: CallStack | null,\n  forcedAsync: boolean): Future<any> {\n\n  return Future.create<any>(cb => {\n    const ctx = new IOContext(scheduler)\n    if (forcedAsync)\n      ioRestartAsync(start as any, ctx, cb as any, null, bFirst, bRest)\n    else\n      ioGenericRunLoop(start as any, scheduler, ctx, cb as any, null, bFirst, bRest)\n\n    return ctx.connection\n  })\n}\n\n/** @hidden */\nfunction taskToFutureRunLoop(\n  start: IO<any>,\n  scheduler: Scheduler): Future<any> {\n\n  let current: Current | Try<any> = start\n  let bFirst: BindT | null = null\n  let bRest: CallStack | null = null\n\n  const modulus = scheduler.executionModel.recommendedBatchSize - 1\n  let frameIndex = scheduler.batchIndex\n\n  while (true) {\n    if (current instanceof Try) {\n      if (current.isSuccess()) {\n        const bind = _ioPopNextBind(bFirst, bRest)\n        if (!bind) {\n          scheduler.batchIndex = frameIndex\n          return Future.pure(current.get())\n        }\n\n        try {\n          current = bind(current.get())\n        } catch (e) {\n          current = new IOPure(Try.failure(e))\n        }\n      } else {\n        const err = current.failed().get()\n        const bind = _ioFindErrorHandler(bFirst, bRest)\n        if (!bind) {\n          scheduler.batchIndex = frameIndex\n          return Future.raise(err)\n        }\n\n        try {\n          current = bind(err)\n        } catch (e) {\n          current = new IOPure(Try.failure(e))\n        }\n      }\n\n      bFirst = null\n      const nextIndex = (frameIndex + 1) & modulus\n      // Should we force an asynchronous boundary?\n      if (nextIndex) {\n        frameIndex = nextIndex\n      } else {\n        return ioToFutureGoAsync(current, scheduler, bFirst, bRest, true)\n      }\n    }\n    else switch (current._funADType) {\n      case \"pure\":\n        current = (current as IOPure<any>).value\n        break\n\n      case \"always\":\n        current = Try.of((current as IOAlways<any>).thunk)\n        break\n\n      case \"once\":\n        current = (current as IOOnce<any>).runTry()\n        break\n\n      case \"flatMap\":\n        const flatM: IOFlatMap<any, any> = current as any\n        if (bFirst) {\n          if (!bRest) bRest = []\n          bRest.push(bFirst)\n        }\n\n        bFirst = !flatM.g ? flatM.f : [flatM.f, flatM.g]\n        current = flatM.source\n        break\n\n      case \"async\":\n      case \"memoize\":\n        return ioToFutureGoAsync(current, scheduler, bFirst, bRest, false)\n    }\n  }\n}\n\n/**\n * Internal utility used in the implementation of `IO.async`.\n *\n * @hidden\n */\nfunction ioSafeCallback<A>(\n  ec: Scheduler,\n  conn: StackedCancelable,\n  cb: (r: Try<A>) => void): ((r: Try<A>) => void) {\n\n  let called = false\n  return (r: Try<A>) => {\n    if (!called) {\n      called = true\n      // Inserting a light async boundary, otherwise we can have\n      // stack overflow issues, but also ordering issues with\n      // StackedCancelable.push in IO.async!\n      ec.trampoline(() => {\n        conn.pop()\n        cb(r)\n      })\n    } else if (r.isFailure()) {\n      ec.reportFailure(r.failed().get())\n    }\n  }\n}\n\n/** @hidden */\nfunction ioStartMemoize<A>(\n  fa: IOMemoize<A>,\n  ec: Scheduler,\n  context: IOContext | null,\n  cb: (r: Try<A>) => void,\n  bFirstInit: BindT | null,\n  bRestInit: CallStack | null,\n  frameIndex: number): ICancelable | void {\n\n  // Storing the current frameIndex because invoking this\n  // function effectively ends the current run-loop\n  ec.batchIndex = frameIndex\n  // The state that we'll use for subscribing listeners below\n  let state: Try<A> | Future<A>\n\n  // The first evaluation has to trigger the initial run-loop that\n  // will eventually set our completed state\n  if (fa.result) {\n    state = fa.result\n  } else {\n    // NOTE this isn't using the passed `IOContext`, or the bindings\n    // stack because it would be wrong. This has to be executed\n    // independently, within its own context.\n    const f = ioToFutureGoAsync(fa.source as any, ec, null, null, false)\n\n    if (f.value().isEmpty()) {\n      fa.result = f\n      state = f\n\n      f.onComplete(r => {\n        if (r.isSuccess() || !fa.onlySuccess) {\n          // Caching result for subsequent listeners\n          fa.result = r as any\n          // GC purposes\n          delete fa.source\n        } else {\n          // Reverting the state to the original IO reference, such\n          // that it can be retried again\n          fa.result = null\n        }\n      })\n    } else {\n      state = (f.value().get() as any) as Try<any>\n      // Not storing the state on memoizeOnSuccess if it's a failure\n      if (state.isSuccess() || !fa.onlySuccess)\n        fa.result = state as any\n    }\n  }\n\n  // We have the IOMemoize in an already completed state,\n  // so running with it\n  const io: IO<A> = state instanceof Try\n    ? new IOPure(state)\n    : IO.fromFuture(state)\n\n  ioGenericRunLoop(io, ec, context, cb, null, bFirstInit, bRestInit)\n}\n\n/**\n * Implementation for `IO.sequence`.\n * @hidden\n */\nfunction ioSequence<A>(list: IO<A>[] | Iterable<IO<A>>): IO<A[]> {\n  return IO.of(() => iteratorOf(list))\n    .flatMap(cursor => ioSequenceLoop([], cursor))\n}\n\n/**\n * Recursive loop that goes through the given `cursor`, element by\n * element, gathering the results of all generated `IO` elements.\n *\n * @hidden\n */\nfunction ioSequenceLoop<A>(acc: A[], cursor: IteratorLike<IO<A>>): IO<A[]> {\n  while (true) {\n    const elem = cursor.next()\n    const isDone = elem.done\n\n    if (elem.value) {\n      const io: IO<A> = elem.value\n      return io.flatMap(a => {\n        acc.push(a)\n        if (isDone) return IO.pure(acc)\n        return ioSequenceLoop(acc, cursor)\n      })\n    } else {\n      /* istanbul ignore else */\n      if (isDone) return IO.pure(acc)\n    }\n  }\n}\n\n/** @hidden */\nfunction ioListToFutureProcess<A, B>(list: IO<A>[] | Iterable<IO<A>>, f: (list: Future<A>[], ec: Scheduler) => Future<B>): IO<B> {\n  return IO.asyncUnsafe<B>((ctx, cb) => {\n    ctx.scheduler.trampoline(() => {\n      let streamErrors = true\n      try {\n        const futures: Future<A>[] = []\n        const array: IO<A>[] = execInternals.iterableToArray(list)\n        streamErrors = false\n\n        for (let i = 0; i < array.length; i++) {\n          const io = array[i]\n          const f = io.run(ctx.scheduler) as Future<A>\n          futures.push(f)\n        }\n\n        const all = f(futures, ctx.scheduler)\n        ctx.connection.push(all)\n        all.onComplete(ioSafeCallback(ctx.scheduler, ctx.connection, cb) as any)\n      } catch (e) {\n        /* istanbul ignore else */\n        if (streamErrors) cb(Failure(e))\n        else ctx.scheduler.reportFailure(e)\n      }\n    })\n  })\n}\n"],"names":["emptyIteratorRef","next","done","list","Object","prototype","toString","call","Symbol","iterator","array","length","cursor","value","evalRunLoop","f","FlatMap","a","Eval","now","flatMap","_funADType","Once","get","cb","map","forEachL","thunk","always","Now","evalUnitRef","Always","Suspend","suspend","either","isRight","tailRecM","swap","evalSequence","fa1","fa2","fl","sequence","lst","fa3","fa4","fa5","fa6","JSON","stringify","undefined","_thunk","_cache","_isError","e","source","String","bFirst","bRest","pop","start","current","bind","_popNextBind","push","fm","of","iteratorOf","evalSequenceLoop","acc","elem","isDone","io","pure","WrapFn","Empty","refs","CollectionCancelable","errors","c","cancel","CompositeError","ref","Cancelable","DummyCancelable","BoolWrapFn","BoolEmpty","AlreadyCanceledRef","_refs","cancelAll","BoolCancelable","canceled","AlreadyCanceledBoolCancelable","AlreadyCanceledAssignCancelableRef","MultiAssignCancelable","empty","AlreadyCanceledAssignCancelable","initial","_underlying","_canceled","SerialCancelable","_wasAssigned","IllegalStateError","SingleAssignCancelable","update","slice","StackedCancelable","_chained","IllegalArgumentError","isCanceled","other","keepSearching","ref2","prev","ChainedCancelable","label","toUpperCase","C0","C1","C2","C3","C4","C5","C6","MIN","MAX","trunc","Math","x","isNaN","NaN","floor","ceil","d","m","over","duration","unit","toNanos","TimeUnit","NANOSECONDS","Nanoseconds","toMicros","MICROSECONDS","Microseconds","toMillis","MILLISECONDS","Milliseconds","toSeconds","SECONDS","Seconds","toMinutes","MINUTES","Minutes","toHours","HOURS","Hours","toDays","DAYS","Days","isFinite","convert","Duration","Infinity","negInf","inf","d1","d2","ord","convertTo","plus","negate","s","o","n","cmp","millis","fn","setL","_previous","bindL","oldFn","oldPrev","ta","DynamicRef","minIndex","maxIndex","index","search","values","arr","item","lnOf2","log","maxPowerOf2","nr","bit","log2","em","executionModel","type","executeBatched","executeAsync","trampoline","modulus","recommendedBatchSize","r","batchIndex","initialDelay","delay","runnable","loop","self","delayNow","scheduleOnce","task","period","delayNowMs","periodMs","startAt","currentTimeMillis","elapsedMs","nextDelayMs","max","Scheduler","globalSchedulerRef","batchSize","nextPowerOf2","hashCodeOfString","ExecutionModel","batched","reporter","_isActive","_queue","_reporter","runLoop","canUseSetImmediate","global","reportFailure","_trampoline","Trampoline","_useSetImmediate","setImmediate","safeRunnable","setTimeout","NotImplementedError","execute","error","Date","ms","clearTimeout","GlobalScheduler","synchronous","_stateRef","TestSchedulerState","updateTasks","_state","triggeredFailures","tasks","clock","state","scheduleAt","insertAt","tasksSearch","splice","filtered","ec2","TestScheduler","toExecute","jumpMs","executed","peek","random","nextTaskJump","add","min","arrayBSearchInsertPos","failure","success","transformWith","Future","_scheduler","transform","Left","Right","raise","onFulfilled","onRejected","ec","promiseThen","Promise","resolve","reject","onComplete","_","fold","delayedTick","err","after","fb","TimeoutError","timeoutTo","fallback","firstCompletedOf","FutureMaker","tryComplete","Try","future","PureFuture","Success","Failure","register","cRef","complete","ecAny","create","withScheduler","then","futureFirstCompletedOf","parallelism","futureTraverse","futureSequence","_value","Some","genericTransformWith","id","None","compressedRoot","xs","i","result","target","chainTo","_cancelable","AsyncFuture","cancelable","AsyncFutureState","scheduler","defer","tryA","isEmpty","fbb","cNext","clear","alt","fromPromise","skip","futures","futureIterableToArray","futureCancelAll","finishedCount","finalArray","fi","fa","isSuccess","failed","iterable","isFailure","iterableToArray","futureTraverseLoop","batch","b","taskToFutureRunLoop","ioGenericRunLoop","Either","left","right","IO","shift","callback","asyncUnsafe","ctx","conn","connection","run","unsafeStart","ioSafeCallback","fork","withExecutionModel","ctx2","IOContext","options","set","IOFlatMap","IOOnce","mem","onlySuccess","IOMemoize","recoverWith","IOAlways","safe","IOAsync","ioa","fromFuture","deferAction","ioListToFutureProcess","fromTry","IOPure","gather","ioSequence","ioShiftDefaultRef","ioShift","ioUnitRef","context","onlyOnSuccess","cache","g","autoCancelableRunLoops","shouldCancel","asFunction","signal","canCall","rcb","frameIndex","restart","RestartCallback","prepare","bFirstInit","bRestInit","_ioPopNextBind","_ioFindErrorHandler","nextIndex","boxed","runTry","flatM","async","ioStartMemoize","forcedAsync","ioRestartAsync","ioToFutureGoAsync","called","ioSequenceLoop","streamErrors","execInternals","all"],"mappings":"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"}